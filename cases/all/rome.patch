diff --git a/internal/cli-layout/ansi.ts b/internal/cli-layout/ansi.ts
index d70a9366e..356a8eca3 100644
--- a/internal/cli-layout/ansi.ts
+++ b/internal/cli-layout/ansi.ts
@@ -120,10 +120,10 @@ export const formatAnsi = {
 	},
 	fileHyperlink(name: string, filename: string): string {
 		let href = "file://";
-		const {HOSTNAME} = process.env;
-		if (HOSTNAME != null) {
-			href += `${HOSTNAME}/`;
-		}
+		// const {HOSTNAME} = process.env;
+		// if (HOSTNAME != null) {
+		// 	href += `${HOSTNAME}/`;
+		// }
 		href += filename;
 		return formatAnsi.hyperlink(name, href);
 	},
diff --git a/internal/formatter/builders/css/core/CSSAtRule.ts b/internal/formatter/builders/css/core/CSSAtRule.ts
index 439416029..9ae7015ed 100644
--- a/internal/formatter/builders/css/core/CSSAtRule.ts
+++ b/internal/formatter/builders/css/core/CSSAtRule.ts
@@ -1,6 +1,5 @@
-import {CSSAtRule} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
 export default function CSSAtRule(builder: Builder, node: CSSAtRule): Token {
-	throw new Error("unimplemented");
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/css/core/CSSBlock.ts b/internal/formatter/builders/css/core/CSSBlock.ts
index 1eef1fef7..55da78741 100644
--- a/internal/formatter/builders/css/core/CSSBlock.ts
+++ b/internal/formatter/builders/css/core/CSSBlock.ts
@@ -1,6 +1,5 @@
-import {CSSBlock} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
 export default function CSSBlock(builder: Builder, node: CSSBlock): Token {
-	throw new Error("unimplemented");
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/css/core/CSSDeclaration.ts b/internal/formatter/builders/css/core/CSSDeclaration.ts
index ad9c047ae..9b1172c5d 100644
--- a/internal/formatter/builders/css/core/CSSDeclaration.ts
+++ b/internal/formatter/builders/css/core/CSSDeclaration.ts
@@ -1,9 +1,5 @@
-import {CSSDeclaration} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function CSSDeclaration(
-	builder: Builder,
-	node: CSSDeclaration,
-): Token {
-	throw new Error("unimplemented");
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function CSSDeclaration(builder: Builder, node: CSSDeclaration): Token {
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/css/core/CSSDimension.ts b/internal/formatter/builders/css/core/CSSDimension.ts
index 0b59d4729..f8b358b6b 100644
--- a/internal/formatter/builders/css/core/CSSDimension.ts
+++ b/internal/formatter/builders/css/core/CSSDimension.ts
@@ -1,9 +1,5 @@
-import {CSSDimension} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function CSSDimension(
-	builder: Builder,
-	node: CSSDimension,
-): Token {
-	throw new Error("unimplemented");
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function CSSDimension(builder: Builder, node: CSSDimension): Token {
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/css/core/CSSFunction.ts b/internal/formatter/builders/css/core/CSSFunction.ts
index 16443ce0e..2ee43a16d 100644
--- a/internal/formatter/builders/css/core/CSSFunction.ts
+++ b/internal/formatter/builders/css/core/CSSFunction.ts
@@ -1,6 +1,5 @@
-import {CSSFunction} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
 export default function CSSFunction(builder: Builder, node: CSSFunction): Token {
-	throw new Error("unimplemented");
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/css/core/CSSIdentifier.ts b/internal/formatter/builders/css/core/CSSIdentifier.ts
index 601bd293d..f1f25b9d9 100644
--- a/internal/formatter/builders/css/core/CSSIdentifier.ts
+++ b/internal/formatter/builders/css/core/CSSIdentifier.ts
@@ -1,9 +1,5 @@
-import {CSSIdentifier} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function CSSIdentifier(
-	builder: Builder,
-	node: CSSIdentifier,
-): Token {
-	throw new Error("unimplemented");
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function CSSIdentifier(builder: Builder, node: CSSIdentifier): Token {
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/css/core/CSSNumber.ts b/internal/formatter/builders/css/core/CSSNumber.ts
index d61bd7366..89171b339 100644
--- a/internal/formatter/builders/css/core/CSSNumber.ts
+++ b/internal/formatter/builders/css/core/CSSNumber.ts
@@ -1,6 +1,5 @@
-import {CSSNumber} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
 export default function CSSNumber(builder: Builder, node: CSSNumber): Token {
-	throw new Error("unimplemented");
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/css/core/CSSPercentage.ts b/internal/formatter/builders/css/core/CSSPercentage.ts
index 16f4e1ae4..a95a49856 100644
--- a/internal/formatter/builders/css/core/CSSPercentage.ts
+++ b/internal/formatter/builders/css/core/CSSPercentage.ts
@@ -1,9 +1,5 @@
-import {CSSPercentage} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function CSSPercentage(
-	builder: Builder,
-	node: CSSPercentage,
-): Token {
-	throw new Error("unimplemented");
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function CSSPercentage(builder: Builder, node: CSSPercentage): Token {
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/css/core/CSSRaw.ts b/internal/formatter/builders/css/core/CSSRaw.ts
index a588551d3..fbbaaa39e 100644
--- a/internal/formatter/builders/css/core/CSSRaw.ts
+++ b/internal/formatter/builders/css/core/CSSRaw.ts
@@ -1,6 +1,5 @@
-import {CSSRaw} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
 export default function CSSRaw(builder: Builder, node: CSSRaw): Token {
-	throw new Error("unimplemented");
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/css/core/CSSRoot.ts b/internal/formatter/builders/css/core/CSSRoot.ts
index 76648799a..260ea10ed 100644
--- a/internal/formatter/builders/css/core/CSSRoot.ts
+++ b/internal/formatter/builders/css/core/CSSRoot.ts
@@ -1,6 +1,5 @@
-import {CSSRoot} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
 export default function CSSRoot(builder: Builder, node: CSSRoot): Token {
-	throw new Error("unimplemented");
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/css/core/CSSRule.ts b/internal/formatter/builders/css/core/CSSRule.ts
index 85b739ecd..c51b9c039 100644
--- a/internal/formatter/builders/css/core/CSSRule.ts
+++ b/internal/formatter/builders/css/core/CSSRule.ts
@@ -1,6 +1,5 @@
-import {CSSRule} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
 export default function CSSRule(builder: Builder, node: CSSRule): Token {
-	throw new Error("unimplemented");
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/html/attributes/HTMLAttribute.ts b/internal/formatter/builders/html/attributes/HTMLAttribute.ts
index 280e8f7f3..5477ecca4 100644
--- a/internal/formatter/builders/html/attributes/HTMLAttribute.ts
+++ b/internal/formatter/builders/html/attributes/HTMLAttribute.ts
@@ -1,13 +1,9 @@
-import {HTMLAttribute} from "@internal/ast";
-import {Builder, Token, concat} from "@internal/formatter";
-
-export default function HTMLAttribute(
-	builder: Builder,
-	node: HTMLAttribute,
-): Token {
-	return concat([
-		builder.tokenize(node.name, node),
-		"=",
-		builder.tokenize(node.value, node),
-	]);
+import {} from "@internal/ast";
+import { Builder, Token, concat } from "@internal/formatter";
+export default function HTMLAttribute(builder: Builder, node: HTMLAttribute): Token {
+    return concat([
+        builder.tokenize(node.name, node),
+        "=",
+        builder.tokenize(node.value, node),
+    ]);
 }
diff --git a/internal/formatter/builders/html/core/HTMLIdentifier.ts b/internal/formatter/builders/html/core/HTMLIdentifier.ts
index 3330dc115..5b0aeff14 100644
--- a/internal/formatter/builders/html/core/HTMLIdentifier.ts
+++ b/internal/formatter/builders/html/core/HTMLIdentifier.ts
@@ -1,9 +1,5 @@
-import {HTMLIdentifier} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function HTMLIdentifier(
-	builder: Builder,
-	node: HTMLIdentifier,
-): Token {
-	return node.name;
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function HTMLIdentifier(builder: Builder, node: HTMLIdentifier): Token {
+    return node.name;
 }
diff --git a/internal/formatter/builders/html/core/HTMLRoot.ts b/internal/formatter/builders/html/core/HTMLRoot.ts
index feb4ecda5..e05ceb304 100644
--- a/internal/formatter/builders/html/core/HTMLRoot.ts
+++ b/internal/formatter/builders/html/core/HTMLRoot.ts
@@ -1,6 +1,5 @@
-import {HTMLRoot} from "@internal/ast";
-import {Builder, Token, concat, hardline} from "@internal/formatter";
-
+import {} from "@internal/ast";
+import { Builder, Token, concat, hardline } from "@internal/formatter";
 export default function HTMLRoot(builder: Builder, node: HTMLRoot): Token {
-	return concat([builder.tokenizeStatementList(node.body, node), hardline]);
+    return concat([builder.tokenizeStatementList(node.body, node), hardline]);
 }
diff --git a/internal/formatter/builders/html/core/HTMLString.ts b/internal/formatter/builders/html/core/HTMLString.ts
index 4b16604c2..6e5f1cec7 100644
--- a/internal/formatter/builders/html/core/HTMLString.ts
+++ b/internal/formatter/builders/html/core/HTMLString.ts
@@ -1,6 +1,5 @@
-import {HTMLString} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
 export default function HTMLString(builder: Builder, node: HTMLString): Token {
-	return JSON.stringify(node.value);
+    return JSON.stringify(node.value);
 }
diff --git a/internal/formatter/builders/html/core/HTMLText.ts b/internal/formatter/builders/html/core/HTMLText.ts
index d8da64261..d45f7e251 100644
--- a/internal/formatter/builders/html/core/HTMLText.ts
+++ b/internal/formatter/builders/html/core/HTMLText.ts
@@ -1,7 +1,6 @@
-import {HTMLText} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
 export default function HTMLText(builder: Builder, node: HTMLText): Token {
-	// TODO Escape <
-	return node.value;
+    // TODO Escape <
+    return node.value;
 }
diff --git a/internal/formatter/builders/html/tags/HTMLDoctypeTag.ts b/internal/formatter/builders/html/tags/HTMLDoctypeTag.ts
index 5af875f01..2e508e1bf 100644
--- a/internal/formatter/builders/html/tags/HTMLDoctypeTag.ts
+++ b/internal/formatter/builders/html/tags/HTMLDoctypeTag.ts
@@ -1,9 +1,5 @@
-import {HTMLDoctypeTag} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function HTMLDoctypeTag(
-	builder: Builder,
-	node: HTMLDoctypeTag,
-): Token {
-	throw new Error("unimplemented");
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function HTMLDoctypeTag(builder: Builder, node: HTMLDoctypeTag): Token {
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/html/tags/HTMLElement.ts b/internal/formatter/builders/html/tags/HTMLElement.ts
index 3cb46c8cf..6cb4ef35c 100644
--- a/internal/formatter/builders/html/tags/HTMLElement.ts
+++ b/internal/formatter/builders/html/tags/HTMLElement.ts
@@ -1,57 +1,38 @@
-import {HTMLElement} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	Tokens,
-	concat,
-	indent,
-	join,
-	softline,
-	space,
-} from "@internal/formatter";
-import {hasInnerComments} from "../../comments";
-
+import {} from "@internal/ast";
+import { Builder, Token, Tokens, concat, indent, join, softline, space, } from "@internal/formatter";
+import { hasInnerComments } from "../../comments";
 export default function HTMLElement(builder: Builder, node: HTMLElement): Token {
-	const name = builder.tokenize(node.name, node);
-	const tokens: Tokens = ["<", name];
-
-	for (const attr of node.attributes) {
-		tokens.push(space);
-		tokens.push(builder.tokenize(attr.name, attr));
-		tokens.push("=");
-		tokens.push(builder.tokenize(attr.value, attr));
-	}
-
-	if (
-		node.children.length === 0 &&
-		node.selfClosing !== false &&
-		!hasInnerComments(node)
-	) {
-		tokens.push(space, "/>");
-	} else {
-		tokens.push(">");
-
-		const children: Tokens = [];
-
-		children.push(builder.tokenizeInnerComments(node, true));
-
-		for (let i = 0; i < node.children.length; i++) {
-			const child = node.children[i];
-			const printed = builder.tokenize(child, node);
-
-			if (i > 0 && builder.getLinesBetween(node.children[i - 1], child) > 1) {
-				children.push(concat([softline, printed]));
-			} else {
-				children.push(printed);
-			}
-		}
-
-		tokens.push(concat([indent(join(softline, children)), softline]));
-
-		tokens.push("</");
-		tokens.push(name);
-		tokens.push(">");
-	}
-
-	return concat(tokens);
+    const name = builder.tokenize(node.name, node);
+    const tokens: Tokens = ["<", name];
+    for (const attr of node.attributes) {
+        tokens.push(space);
+        tokens.push(builder.tokenize(attr.name, attr));
+        tokens.push("=");
+        tokens.push(builder.tokenize(attr.value, attr));
+    }
+    if (node.children.length === 0 &&
+        node.selfClosing !== false &&
+        !hasInnerComments(node)) {
+        tokens.push(space, "/>");
+    }
+    else {
+        tokens.push(">");
+        const children: Tokens = [];
+        children.push(builder.tokenizeInnerComments(node, true));
+        for (let i = 0; i < node.children.length; i++) {
+            const child = node.children[i];
+            const printed = builder.tokenize(child, node);
+            if (i > 0 && builder.getLinesBetween(node.children[i - 1], child) > 1) {
+                children.push(concat([softline, printed]));
+            }
+            else {
+                children.push(printed);
+            }
+        }
+        tokens.push(concat([indent(join(softline, children)), softline]));
+        tokens.push("</");
+        tokens.push(name);
+        tokens.push(">");
+    }
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/auxiliary/JSArrayHole.ts b/internal/formatter/builders/js/auxiliary/JSArrayHole.ts
index 134c03f12..e5704c757 100644
--- a/internal/formatter/builders/js/auxiliary/JSArrayHole.ts
+++ b/internal/formatter/builders/js/auxiliary/JSArrayHole.ts
@@ -4,10 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-import {JSArrayHole} from "@internal/ast";
-
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
 export default function JSArrayHole(builder: Builder, node: JSArrayHole): Token {
-	return builder.tokenizeInnerComments(node, false);
+    return builder.tokenizeInnerComments(node, false);
 }
diff --git a/internal/formatter/builders/js/auxiliary/JSCatchClause.ts b/internal/formatter/builders/js/auxiliary/JSCatchClause.ts
index 4207557f2..273fdd2e0 100644
--- a/internal/formatter/builders/js/auxiliary/JSCatchClause.ts
+++ b/internal/formatter/builders/js/auxiliary/JSCatchClause.ts
@@ -4,25 +4,20 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {JSCatchClause} from "@internal/ast";
-
-export default function JSCatchClause(
-	builder: Builder,
-	node: JSCatchClause,
-): Token {
-	if (node.param) {
-		return concat([
-			"catch",
-			space,
-			"(",
-			builder.tokenize(node.param, node),
-			") ",
-			builder.tokenize(node.body, node),
-		]);
-	} else {
-		return concat(["catch", space, builder.tokenize(node.body, node)]);
-	}
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSCatchClause(builder: Builder, node: JSCatchClause): Token {
+    if (node.param) {
+        return concat([
+            "catch",
+            space,
+            "(",
+            builder.tokenize(node.param, node),
+            ") ",
+            builder.tokenize(node.body, node),
+        ]);
+    }
+    else {
+        return concat(["catch", space, builder.tokenize(node.body, node)]);
+    }
 }
diff --git a/internal/formatter/builders/js/auxiliary/JSComputedMemberProperty.ts b/internal/formatter/builders/js/auxiliary/JSComputedMemberProperty.ts
index 284f4f21c..2156e35a1 100644
--- a/internal/formatter/builders/js/auxiliary/JSComputedMemberProperty.ts
+++ b/internal/formatter/builders/js/auxiliary/JSComputedMemberProperty.ts
@@ -4,22 +4,13 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSComputedMemberProperty} from "@internal/ast";
-
-export default function JSComputedMemberProperty(
-	builder: Builder,
-	node: JSComputedMemberProperty,
-): Token {
-	const tokens: Array<Token> = [];
-
-	if (node.optional) {
-		tokens.push("?.");
-	}
-
-	tokens.push("[", builder.tokenize(node.value, node), "]");
-
-	return concat(tokens);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSComputedMemberProperty(builder: Builder, node: JSComputedMemberProperty): Token {
+    const tokens: Array<Token> = [];
+    if (node.optional) {
+        tokens.push("?.");
+    }
+    tokens.push("[", builder.tokenize(node.value, node), "]");
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/auxiliary/JSFunctionHead.ts b/internal/formatter/builders/js/auxiliary/JSFunctionHead.ts
index 2e787ca1e..441334d95 100644
--- a/internal/formatter/builders/js/auxiliary/JSFunctionHead.ts
+++ b/internal/formatter/builders/js/auxiliary/JSFunctionHead.ts
@@ -4,38 +4,23 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {JSFunctionHead} from "@internal/ast";
-import {Builder, Token, concat, group, space} from "@internal/formatter";
-import {printBindingPatternParams} from "../utils";
-
-export default function JSFunctionHead(
-	builder: Builder,
-	node: JSFunctionHead,
-): Token {
-	const tokens: Array<Token> = [];
-
-	if (builder.options.typeAnnotations && node.typeParameters) {
-		tokens.push(builder.tokenize(node.typeParameters, node));
-	}
-
-	const printedParameters = printBindingPatternParams(
-		builder,
-		node,
-		node.params,
-		node.rest,
-	);
-
-	let printedReturnType: Token = "";
-	if (builder.options.typeAnnotations) {
-		if (node.returnType) {
-			const tokens: Array<Token> = [":"];
-			tokens.push(space, builder.tokenize(node.returnType, node));
-			printedReturnType = concat(tokens);
-		}
-	}
-
-	tokens.push(group(concat([printedParameters, printedReturnType])));
-
-	return concat(tokens);
+import {} from "@internal/ast";
+import { Builder, Token, concat, group, space } from "@internal/formatter";
+import { printBindingPatternParams } from "../utils";
+export default function JSFunctionHead(builder: Builder, node: JSFunctionHead): Token {
+    const tokens: Array<Token> = [];
+    if (builder.options.typeAnnotations && node.typeParameters) {
+        tokens.push(builder.tokenize(node.typeParameters, node));
+    }
+    const printedParameters = printBindingPatternParams(builder, node, node.params, node.rest);
+    let printedReturnType: Token = "";
+    if (builder.options.typeAnnotations) {
+        if (node.returnType) {
+            const tokens: Array<Token> = [":"];
+            tokens.push(space, builder.tokenize(node.returnType, node));
+            printedReturnType = concat(tokens);
+        }
+    }
+    tokens.push(group(concat([printedParameters, printedReturnType])));
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/auxiliary/JSIdentifier.ts b/internal/formatter/builders/js/auxiliary/JSIdentifier.ts
index f92bfc163..239bdb63b 100644
--- a/internal/formatter/builders/js/auxiliary/JSIdentifier.ts
+++ b/internal/formatter/builders/js/auxiliary/JSIdentifier.ts
@@ -4,23 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {
-	JSAssignmentIdentifier,
-	JSBindingIdentifier,
-	JSIdentifier,
-	JSReferenceIdentifier,
-} from "@internal/ast";
-
-export default function JSIdentifier(
-	builder: Builder,
-	node:
-		| JSAssignmentIdentifier
-		| JSBindingIdentifier
-		| JSIdentifier
-		| JSReferenceIdentifier,
-): Token {
-	return node.name;
+import { Builder, Token } from "@internal/formatter";
+import { JSAssignmentIdentifier, JSBindingIdentifier, JSReferenceIdentifier, } from "@internal/ast";
+export default function JSIdentifier(builder: Builder, node: JSAssignmentIdentifier | JSBindingIdentifier | JSIdentifier | JSReferenceIdentifier): Token {
+    return node.name;
 }
diff --git a/internal/formatter/builders/js/auxiliary/JSSpreadElement.ts b/internal/formatter/builders/js/auxiliary/JSSpreadElement.ts
index e50d95def..310c39c9d 100644
--- a/internal/formatter/builders/js/auxiliary/JSSpreadElement.ts
+++ b/internal/formatter/builders/js/auxiliary/JSSpreadElement.ts
@@ -4,13 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-import {JSSpreadElement} from "@internal/ast";
-
-export default function JSSpreadElement(
-	builder: Builder,
-	node: JSSpreadElement,
-): Token {
-	return concat(["...", builder.tokenize(node.argument, node)]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSSpreadElement(builder: Builder, node: JSSpreadElement): Token {
+    return concat(["...", builder.tokenize(node.argument, node)]);
 }
diff --git a/internal/formatter/builders/js/auxiliary/JSStaticMemberProperty.ts b/internal/formatter/builders/js/auxiliary/JSStaticMemberProperty.ts
index 1ca294377..667fbe3de 100644
--- a/internal/formatter/builders/js/auxiliary/JSStaticMemberProperty.ts
+++ b/internal/formatter/builders/js/auxiliary/JSStaticMemberProperty.ts
@@ -4,21 +4,13 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-import {JSStaticMemberProperty} from "@internal/ast";
-
-export default function JSStaticMemberProperty(
-	builder: Builder,
-	node: JSStaticMemberProperty,
-): Token {
-	const tokens: Array<Token> = [];
-
-	if (node.optional) {
-		tokens.push("?");
-	}
-
-	tokens.push(".", builder.tokenize(node.value, node));
-
-	return concat(tokens);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSStaticMemberProperty(builder: Builder, node: JSStaticMemberProperty): Token {
+    const tokens: Array<Token> = [];
+    if (node.optional) {
+        tokens.push("?");
+    }
+    tokens.push(".", builder.tokenize(node.value, node));
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/auxiliary/JSSwitchCase.ts b/internal/formatter/builders/js/auxiliary/JSSwitchCase.ts
index 11e6e6b94..d1dae62a2 100644
--- a/internal/formatter/builders/js/auxiliary/JSSwitchCase.ts
+++ b/internal/formatter/builders/js/auxiliary/JSSwitchCase.ts
@@ -4,40 +4,23 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	Builder,
-	Token,
-	concat,
-	hardline,
-	indent,
-	space,
-} from "@internal/formatter";
-import {JSSwitchCase} from "@internal/ast";
-
-export default function JSSwitchCase(
-	builder: Builder,
-	node: JSSwitchCase,
-): Token {
-	const tokens: Array<Token> = [];
-
-	if (node.test) {
-		tokens.push("case", space, builder.tokenize(node.test, node), ":");
-	} else {
-		tokens.push("default", ":");
-	}
-
-	const {consequent} = node;
-	if (consequent.length === 1 && consequent[0].type === "JSBlockStatement") {
-		tokens.push(space);
-		tokens.push(builder.tokenize(consequent[0], node));
-	} else if (consequent.length > 0) {
-		tokens.push(
-			indent(
-				concat([hardline, builder.tokenizeStatementList(consequent, node)]),
-			),
-		);
-	}
-
-	return concat(tokens);
+import { Builder, Token, concat, hardline, indent, space, } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSSwitchCase(builder: Builder, node: JSSwitchCase): Token {
+    const tokens: Array<Token> = [];
+    if (node.test) {
+        tokens.push("case", space, builder.tokenize(node.test, node), ":");
+    }
+    else {
+        tokens.push("default", ":");
+    }
+    const { consequent } = node;
+    if (consequent.length === 1 && consequent[0].type === "JSBlockStatement") {
+        tokens.push(space);
+        tokens.push(builder.tokenize(consequent[0], node));
+    }
+    else if (consequent.length > 0) {
+        tokens.push(indent(concat([hardline, builder.tokenizeStatementList(consequent, node)])));
+    }
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/auxiliary/JSTemplateElement.ts b/internal/formatter/builders/js/auxiliary/JSTemplateElement.ts
index fb36d6f52..ee212de56 100644
--- a/internal/formatter/builders/js/auxiliary/JSTemplateElement.ts
+++ b/internal/formatter/builders/js/auxiliary/JSTemplateElement.ts
@@ -4,20 +4,12 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-import {AnyNode, JSTemplateElement, jsTemplateLiteral} from "@internal/ast";
-
-export default function JSTemplateElement(
-	builder: Builder,
-	node: JSTemplateElement,
-	parent: AnyNode,
-): Token {
-	parent = jsTemplateLiteral.assert(parent);
-
-	const isFirst = parent.quasis[0] === node;
-	const isLast = parent.quasis[parent.quasis.length - 1] === node;
-
-	const value = (isFirst ? "`" : "}") + node.raw + (isLast ? "`" : "${");
-	return value;
+import { Builder, Token } from "@internal/formatter";
+import { AnyNode, jsTemplateLiteral } from "@internal/ast";
+export default function JSTemplateElement(builder: Builder, node: JSTemplateElement, parent: AnyNode): Token {
+    parent = jsTemplateLiteral.assert(parent);
+    const isFirst = parent.quasis[0] === node;
+    const isLast = parent.quasis[parent.quasis.length - 1] === node;
+    const value = (isFirst ? "`" : "}") + node.raw + (isLast ? "`" : "${");
+    return value;
 }
diff --git a/internal/formatter/builders/js/auxiliary/JSVariableDeclaration.ts b/internal/formatter/builders/js/auxiliary/JSVariableDeclaration.ts
index faed2d61d..e89ce5805 100644
--- a/internal/formatter/builders/js/auxiliary/JSVariableDeclaration.ts
+++ b/internal/formatter/builders/js/auxiliary/JSVariableDeclaration.ts
@@ -4,38 +4,14 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	indent,
-	lineOrSpace,
-	space,
-} from "@internal/formatter";
-import {JSVariableDeclaration} from "@internal/ast";
-
-export default function JSVariableDeclaration(
-	builder: Builder,
-	node: JSVariableDeclaration,
-): Token {
-	const declarations = node.declarations.map((declaration) =>
-		builder.tokenize(declaration, node)
-	);
-
-	return group(
-		concat([
-			node.kind,
-			space,
-			declarations.shift()!,
-			indent(
-				concat(
-					declarations.map((declaration) =>
-						concat([",", lineOrSpace, declaration])
-					),
-				),
-			),
-		]),
-	);
+import { Builder, Token, concat, group, indent, lineOrSpace, space, } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSVariableDeclaration(builder: Builder, node: JSVariableDeclaration): Token {
+    const declarations = node.declarations.map((declaration) => builder.tokenize(declaration, node));
+    return group(concat([
+        node.kind,
+        space,
+        declarations.shift()!,
+        indent(concat(declarations.map((declaration) => concat([",", lineOrSpace, declaration])))),
+    ]));
 }
diff --git a/internal/formatter/builders/js/auxiliary/JSVariableDeclarator.ts b/internal/formatter/builders/js/auxiliary/JSVariableDeclarator.ts
index 54d5b9891..ccdd559c2 100644
--- a/internal/formatter/builders/js/auxiliary/JSVariableDeclarator.ts
+++ b/internal/formatter/builders/js/auxiliary/JSVariableDeclarator.ts
@@ -4,25 +4,14 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-import {JSVariableDeclarator} from "@internal/ast";
-
-import {printAssignment} from "../utils";
-
-export default function JSVariableDeclarator(
-	builder: Builder,
-	node: JSVariableDeclarator,
-): Token {
-	if (node.init) {
-		return printAssignment(
-			builder,
-			node,
-			node.id,
-			concat([space, "="]),
-			node.init,
-		);
-	} else {
-		return builder.tokenize(node.id, node);
-	}
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
+import { printAssignment } from "../utils";
+export default function JSVariableDeclarator(builder: Builder, node: JSVariableDeclarator): Token {
+    if (node.init) {
+        return printAssignment(builder, node, node.id, concat([space, "="]), node.init);
+    }
+    else {
+        return builder.tokenize(node.id, node);
+    }
 }
diff --git a/internal/formatter/builders/js/classes/JSClassDeclaration.ts b/internal/formatter/builders/js/classes/JSClassDeclaration.ts
index f0e77de74..f1fcca536 100644
--- a/internal/formatter/builders/js/classes/JSClassDeclaration.ts
+++ b/internal/formatter/builders/js/classes/JSClassDeclaration.ts
@@ -4,50 +4,27 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {JSClassDeclaration, JSClassExpression} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	concat,
-	hardline,
-	indent,
-	space,
-} from "@internal/formatter";
-
-import {hasInnerComments} from "../../comments";
-
-export default function JSClassDeclaration(
-	builder: Builder,
-	node: JSClassDeclaration | JSClassExpression,
-): Token {
-	const tokens: Array<Token> = ["class"];
-
-	if (node.id) {
-		tokens.push(space, builder.tokenize(node.id, node));
-	}
-
-	tokens.push(builder.tokenize(node.meta, node), space, "{");
-
-	if (hasInnerComments(node.meta)) {
-		tokens.push(builder.tokenizeInnerComments(node.meta, true), hardline);
-	}
-
-	if (node.meta.body.length > 0) {
-		tokens.push(
-			concat([
-				indent(
-					concat([
-						hardline,
-						builder.tokenizeStatementList(node.meta.body, node.meta),
-					]),
-				),
-				hardline,
-			]),
-		);
-	}
-
-	tokens.push("}");
-
-	return concat(tokens);
+import { JSClassExpression } from "@internal/ast";
+import { Builder, Token, concat, hardline, indent, space, } from "@internal/formatter";
+import { hasInnerComments } from "../../comments";
+export default function JSClassDeclaration(builder: Builder, node: JSClassDeclaration | JSClassExpression): Token {
+    const tokens: Array<Token> = ["class"];
+    if (node.id) {
+        tokens.push(space, builder.tokenize(node.id, node));
+    }
+    tokens.push(builder.tokenize(node.meta, node), space, "{");
+    if (hasInnerComments(node.meta)) {
+        tokens.push(builder.tokenizeInnerComments(node.meta, true), hardline);
+    }
+    if (node.meta.body.length > 0) {
+        tokens.push(concat([
+            indent(concat([
+                hardline,
+                builder.tokenizeStatementList(node.meta.body, node.meta),
+            ])),
+            hardline,
+        ]));
+    }
+    tokens.push("}");
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/classes/JSClassExpression.ts b/internal/formatter/builders/js/classes/JSClassExpression.ts
index b94515afa..83be67ec8 100644
--- a/internal/formatter/builders/js/classes/JSClassExpression.ts
+++ b/internal/formatter/builders/js/classes/JSClassExpression.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSClassExpression} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
 import JSClassDeclaration from "./JSClassDeclaration";
-
-export default function JSClassExpression(
-	builder: Builder,
-	node: JSClassExpression,
-): Token {
-	return JSClassDeclaration(builder, node);
+export default function JSClassExpression(builder: Builder, node: JSClassExpression): Token {
+    return JSClassDeclaration(builder, node);
 }
diff --git a/internal/formatter/builders/js/classes/JSClassHead.ts b/internal/formatter/builders/js/classes/JSClassHead.ts
index d3a793a9b..cfbd15513 100644
--- a/internal/formatter/builders/js/classes/JSClassHead.ts
+++ b/internal/formatter/builders/js/classes/JSClassHead.ts
@@ -4,59 +4,29 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	indent,
-	lineOrSpace,
-	space,
-} from "@internal/formatter";
-
-import {JSClassHead} from "@internal/ast";
-import {printCommaList} from "../utils";
-
+import { Builder, Token, concat, group, indent, lineOrSpace, space, } from "@internal/formatter";
+import {} from "@internal/ast";
+import { printCommaList } from "../utils";
 export default function JSClassHead(builder: Builder, node: JSClassHead): Token {
-	const tokens: Array<Token> = [];
-	const tokenGroups: Array<Token> = [];
-
-	tokens.push(builder.tokenize(node.typeParameters, node));
-
-	if (node.superClass) {
-		tokenGroups.push(
-			group(
-				concat([
-					lineOrSpace,
-					"extends",
-					space,
-					builder.tokenize(node.superClass, node),
-					builder.tokenize(node.superTypeParameters, node),
-				]),
-			),
-		);
-	}
-
-	if (
-		builder.options.typeAnnotations &&
-		node.implements &&
-		node.implements.length > 0
-	) {
-		tokenGroups.push(
-			lineOrSpace,
-			"implements",
-			group(
-				indent(
-					concat([lineOrSpace, printCommaList(builder, node.implements, node)]),
-				),
-			),
-		);
-	}
-
-	if (tokenGroups.length > 0) {
-		tokens.push(group(indent(concat(tokenGroups))));
-	}
-
-	return concat(tokens);
+    const tokens: Array<Token> = [];
+    const tokenGroups: Array<Token> = [];
+    tokens.push(builder.tokenize(node.typeParameters, node));
+    if (node.superClass) {
+        tokenGroups.push(group(concat([
+            lineOrSpace,
+            "extends",
+            space,
+            builder.tokenize(node.superClass, node),
+            builder.tokenize(node.superTypeParameters, node),
+        ])));
+    }
+    if (builder.options.typeAnnotations &&
+        node.implements &&
+        node.implements.length > 0) {
+        tokenGroups.push(lineOrSpace, "implements", group(indent(concat([lineOrSpace, printCommaList(builder, node.implements, node)]))));
+    }
+    if (tokenGroups.length > 0) {
+        tokens.push(group(indent(concat(tokenGroups))));
+    }
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/classes/JSClassMethod.ts b/internal/formatter/builders/js/classes/JSClassMethod.ts
index f97041ad7..73d10d4ce 100644
--- a/internal/formatter/builders/js/classes/JSClassMethod.ts
+++ b/internal/formatter/builders/js/classes/JSClassMethod.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSClassMethod} from "@internal/ast";
-import {printMethod} from "../utils";
-
-export default function JSClassMethod(
-	builder: Builder,
-	node: JSClassMethod,
-): Token {
-	return concat([builder.tokenize(node.meta, node), printMethod(builder, node)]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+import { printMethod } from "../utils";
+export default function JSClassMethod(builder: Builder, node: JSClassMethod): Token {
+    return concat([builder.tokenize(node.meta, node), printMethod(builder, node)]);
 }
diff --git a/internal/formatter/builders/js/classes/JSClassPrivateMethod.ts b/internal/formatter/builders/js/classes/JSClassPrivateMethod.ts
index 97c909015..a49a9a9d2 100644
--- a/internal/formatter/builders/js/classes/JSClassPrivateMethod.ts
+++ b/internal/formatter/builders/js/classes/JSClassPrivateMethod.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSClassPrivateMethod} from "@internal/ast";
-import {printMethod} from "../utils";
-
-export default function JSClassPrivateMethod(
-	builder: Builder,
-	node: JSClassPrivateMethod,
-): Token {
-	return concat([builder.tokenize(node.meta, node), printMethod(builder, node)]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+import { printMethod } from "../utils";
+export default function JSClassPrivateMethod(builder: Builder, node: JSClassPrivateMethod): Token {
+    return concat([builder.tokenize(node.meta, node), printMethod(builder, node)]);
 }
diff --git a/internal/formatter/builders/js/classes/JSClassPrivateProperty.ts b/internal/formatter/builders/js/classes/JSClassPrivateProperty.ts
index d53533a47..07e008b54 100644
--- a/internal/formatter/builders/js/classes/JSClassPrivateProperty.ts
+++ b/internal/formatter/builders/js/classes/JSClassPrivateProperty.ts
@@ -4,31 +4,22 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, group, space} from "@internal/formatter";
-import {JSClassPrivateProperty} from "@internal/ast";
-
-export default function JSClassPrivateProperty(
-	builder: Builder,
-	node: JSClassPrivateProperty,
-): Token {
-	const tokens: Array<Token> = [
-		builder.tokenize(node.meta, node),
-		builder.tokenize(node.key, node),
-	];
-
-	if (builder.options.typeAnnotations && node.typeAnnotation) {
-		tokens.push(":", space, builder.tokenize(node.typeAnnotation, node));
-	}
-
-	if (node.value) {
-		tokens.push(space);
-		tokens.push("=");
-		tokens.push(space);
-		tokens.push(builder.tokenize(node.value, node));
-	}
-
-	tokens.push(";");
-
-	return group(concat(tokens));
+import { Builder, Token, concat, group, space } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSClassPrivateProperty(builder: Builder, node: JSClassPrivateProperty): Token {
+    const tokens: Array<Token> = [
+        builder.tokenize(node.meta, node),
+        builder.tokenize(node.key, node),
+    ];
+    if (builder.options.typeAnnotations && node.typeAnnotation) {
+        tokens.push(":", space, builder.tokenize(node.typeAnnotation, node));
+    }
+    if (node.value) {
+        tokens.push(space);
+        tokens.push("=");
+        tokens.push(space);
+        tokens.push(builder.tokenize(node.value, node));
+    }
+    tokens.push(";");
+    return group(concat(tokens));
 }
diff --git a/internal/formatter/builders/js/classes/JSClassProperty.ts b/internal/formatter/builders/js/classes/JSClassProperty.ts
index fb173c151..b48fbd27f 100644
--- a/internal/formatter/builders/js/classes/JSClassProperty.ts
+++ b/internal/formatter/builders/js/classes/JSClassProperty.ts
@@ -4,37 +4,26 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, group, space} from "@internal/formatter";
-
-import {JSClassProperty} from "@internal/ast";
-
-export default function JSClassProperty(
-	builder: Builder,
-	node: JSClassProperty,
-): Token {
-	if (node.value === undefined && !builder.options.typeAnnotations) {
-		// A JSClassProperty with no value is a type annotation
-		return "";
-	}
-
-	const tokens: Array<Token> = [
-		builder.tokenize(node.meta, node),
-		builder.tokenize(node.key, node),
-	];
-
-	if (builder.options.typeAnnotations && node.typeAnnotation) {
-		tokens.push(":", space, builder.tokenize(node.typeAnnotation, node));
-	}
-
-	if (node.value) {
-		tokens.push(space);
-		tokens.push("=");
-		tokens.push(space);
-		tokens.push(builder.tokenize(node.value, node));
-	}
-
-	tokens.push(";");
-
-	return group(concat(tokens));
+import { Builder, Token, concat, group, space } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSClassProperty(builder: Builder, node: JSClassProperty): Token {
+    if (node.value === undefined && !builder.options.typeAnnotations) {
+        // A JSClassProperty with no value is a type annotation
+        return "";
+    }
+    const tokens: Array<Token> = [
+        builder.tokenize(node.meta, node),
+        builder.tokenize(node.key, node),
+    ];
+    if (builder.options.typeAnnotations && node.typeAnnotation) {
+        tokens.push(":", space, builder.tokenize(node.typeAnnotation, node));
+    }
+    if (node.value) {
+        tokens.push(space);
+        tokens.push("=");
+        tokens.push(space);
+        tokens.push(builder.tokenize(node.value, node));
+    }
+    tokens.push(";");
+    return group(concat(tokens));
 }
diff --git a/internal/formatter/builders/js/classes/JSClassPropertyMeta.ts b/internal/formatter/builders/js/classes/JSClassPropertyMeta.ts
index e47af91fa..8759fa785 100644
--- a/internal/formatter/builders/js/classes/JSClassPropertyMeta.ts
+++ b/internal/formatter/builders/js/classes/JSClassPropertyMeta.ts
@@ -4,34 +4,23 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {JSClassPropertyMeta} from "@internal/ast";
-
-export default function JSClassPropertyMeta(
-	builder: Builder,
-	node: JSClassPropertyMeta,
-): Token {
-	const tokens: Array<Token> = [];
-
-	if (builder.options.typeAnnotations) {
-		if (node.accessibility) {
-			tokens.push(node.accessibility, space);
-		}
-
-		if (node.readonly) {
-			tokens.push("readonly", space);
-		}
-
-		if (node.abstract) {
-			tokens.push("abstract", space);
-		}
-	}
-
-	if (node.static) {
-		tokens.push("static", space);
-	}
-
-	return concat(tokens);
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSClassPropertyMeta(builder: Builder, node: JSClassPropertyMeta): Token {
+    const tokens: Array<Token> = [];
+    if (builder.options.typeAnnotations) {
+        if (node.accessibility) {
+            tokens.push(node.accessibility, space);
+        }
+        if (node.readonly) {
+            tokens.push("readonly", space);
+        }
+        if (node.abstract) {
+            tokens.push("abstract", space);
+        }
+    }
+    if (node.static) {
+        tokens.push("static", space);
+    }
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/classes/JSPrivateName.ts b/internal/formatter/builders/js/classes/JSPrivateName.ts
index 50e927d12..0445faa92 100644
--- a/internal/formatter/builders/js/classes/JSPrivateName.ts
+++ b/internal/formatter/builders/js/classes/JSPrivateName.ts
@@ -4,13 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-import {JSPrivateName} from "@internal/ast";
-
-export default function JSPrivateName(
-	builder: Builder,
-	node: JSPrivateName,
-): Token {
-	return concat(["#", builder.tokenize(node.id, node)]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSPrivateName(builder: Builder, node: JSPrivateName): Token {
+    return concat(["#", builder.tokenize(node.id, node)]);
 }
diff --git a/internal/formatter/builders/js/core/JSDirective.ts b/internal/formatter/builders/js/core/JSDirective.ts
index 1eed4aa5e..b6279a870 100644
--- a/internal/formatter/builders/js/core/JSDirective.ts
+++ b/internal/formatter/builders/js/core/JSDirective.ts
@@ -4,16 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {AnyNode, JSDirective} from "@internal/ast";
+import { Builder, Token, concat } from "@internal/formatter";
+import { AnyNode } from "@internal/ast";
 import JSStringLiteral from "../literals/JSStringLiteral";
-
-export default function JSDirective(
-	builder: Builder,
-	node: JSDirective,
-	parent: AnyNode,
-): Token {
-	return concat([JSStringLiteral(builder, node, parent), ";"]);
+export default function JSDirective(builder: Builder, node: JSDirective, parent: AnyNode): Token {
+    return concat([JSStringLiteral(builder, node, parent), ";"]);
 }
diff --git a/internal/formatter/builders/js/core/JSInterpreterDirective.ts b/internal/formatter/builders/js/core/JSInterpreterDirective.ts
index 73cd0d7a1..85a47ce2b 100644
--- a/internal/formatter/builders/js/core/JSInterpreterDirective.ts
+++ b/internal/formatter/builders/js/core/JSInterpreterDirective.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, hardline} from "@internal/formatter";
-
-import {JSInterpreterDirective} from "@internal/ast";
-
-export default function JSInterpreterDirective(
-	builder: Builder,
-	node: JSInterpreterDirective,
-): Token {
-	return concat([`#!${node.value}`, hardline, hardline]);
+import { Builder, Token, concat, hardline } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSInterpreterDirective(builder: Builder, node: JSInterpreterDirective): Token {
+    return concat([`#!${node.value}`, hardline, hardline]);
 }
diff --git a/internal/formatter/builders/js/core/JSRoot.ts b/internal/formatter/builders/js/core/JSRoot.ts
index 8fc57a018..2d47569d0 100644
--- a/internal/formatter/builders/js/core/JSRoot.ts
+++ b/internal/formatter/builders/js/core/JSRoot.ts
@@ -4,29 +4,19 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, hardline} from "@internal/formatter";
-import {JSRoot} from "@internal/ast";
-
+import { Builder, Token, concat, hardline } from "@internal/formatter";
+import {} from "@internal/ast";
 export default function JSRoot(builder: Builder, node: JSRoot): Token {
-	const tokens: Array<Token> = [
-		builder.tokenizeStatementList(node.directives, node),
-	];
-
-	if (node.directives && node.directives.length) {
-		tokens.push(hardline);
-	}
-
-	if (node.interpreter && builder.options.allowInterpreterDirective) {
-		tokens.push(builder.tokenize(node.interpreter, node));
-	}
-
-	tokens.push(
-		builder.tokenizeInnerComments(node, false),
-		builder.tokenizeStatementList(node.body, node),
-	);
-
-	tokens.push(hardline);
-
-	return concat(tokens);
+    const tokens: Array<Token> = [
+        builder.tokenizeStatementList(node.directives, node),
+    ];
+    if (node.directives && node.directives.length) {
+        tokens.push(hardline);
+    }
+    if (node.interpreter && builder.options.allowInterpreterDirective) {
+        tokens.push(builder.tokenize(node.interpreter, node));
+    }
+    tokens.push(builder.tokenizeInnerComments(node, false), builder.tokenizeStatementList(node.body, node));
+    tokens.push(hardline);
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/expressions/JSArrayExpression.ts b/internal/formatter/builders/js/expressions/JSArrayExpression.ts
index 10eb5c800..863a184a2 100644
--- a/internal/formatter/builders/js/expressions/JSArrayExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSArrayExpression.ts
@@ -4,78 +4,46 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyJSArrayPattern,
-	JSArrayExpression,
-	JSAssignmentArrayPattern,
-	JSBindingArrayPattern,
-} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	ifBreak,
-	indent,
-	join,
-	lineOrSpace,
-	softline,
-} from "@internal/formatter";
-
-import {hasInnerComments} from "../../comments";
-
-export default function JSArrayExpression(
-	builder: Builder,
-	node: JSArrayExpression | JSBindingArrayPattern | JSAssignmentArrayPattern,
-): Token {
-	const hasContents = node.elements.length > 0;
-	const hasRest =
-		(node.type === "JSBindingArrayPattern" ||
-		node.type === "JSAssignmentArrayPattern") &&
-		node.rest !== undefined;
-
-	if (!hasContents && !hasRest) {
-		if (hasInnerComments(node)) {
-			return group(
-				concat(["[", builder.tokenizeInnerComments(node, true), softline, "]"]),
-			);
-		} else {
-			return "[]";
-		}
-	}
-
-	const tokens: Array<Token> = [];
-
-	if (hasContents) {
-		const elements: Array<Token> = [];
-
-		for (let i = 0; i < node.elements.length; i++) {
-			const element = node.elements[i];
-			const printed = builder.tokenize(element, node);
-
-			if (i > 0 && builder.getLinesBetween(node.elements[i - 1], element) > 1) {
-				elements.push(concat([softline, printed]));
-			} else {
-				elements.push(printed);
-			}
-		}
-
-		tokens.push(join(concat([",", lineOrSpace]), elements));
-
-		if (hasRest) {
-			tokens.push(",", lineOrSpace);
-		} else {
-			// Add trailing comma
-			tokens.push(ifBreak(","));
-		}
-	}
-
-	if (hasRest) {
-		tokens.push("...", builder.tokenize((node as AnyJSArrayPattern).rest, node));
-	}
-
-	return group(
-		concat(["[", indent(concat([softline, concat(tokens)])), softline, "]"]),
-	);
+import { AnyJSArrayPattern, JSAssignmentArrayPattern, JSBindingArrayPattern, } from "@internal/ast";
+import { Builder, Token, concat, group, ifBreak, indent, join, lineOrSpace, softline, } from "@internal/formatter";
+import { hasInnerComments } from "../../comments";
+export default function JSArrayExpression(builder: Builder, node: JSArrayExpression | JSBindingArrayPattern | JSAssignmentArrayPattern): Token {
+    const hasContents = node.elements.length > 0;
+    const hasRest = (node.type === "JSBindingArrayPattern" ||
+        node.type === "JSAssignmentArrayPattern") &&
+        node.rest !== undefined;
+    if (!hasContents && !hasRest) {
+        if (hasInnerComments(node)) {
+            return group(concat(["[", builder.tokenizeInnerComments(node, true), softline, "]"]));
+        }
+        else {
+            return "[]";
+        }
+    }
+    const tokens: Array<Token> = [];
+    if (hasContents) {
+        const elements: Array<Token> = [];
+        for (let i = 0; i < node.elements.length; i++) {
+            const element = node.elements[i];
+            const printed = builder.tokenize(element, node);
+            if (i > 0 && builder.getLinesBetween(node.elements[i - 1], element) > 1) {
+                elements.push(concat([softline, printed]));
+            }
+            else {
+                elements.push(printed);
+            }
+        }
+        tokens.push(join(concat([",", lineOrSpace]), elements));
+        if (hasRest) {
+            tokens.push(",", lineOrSpace);
+        }
+        else {
+            // Add trailing comma
+            tokens.push(ifBreak(","));
+        }
+    }
+    if (hasRest) {
+        tokens.push("...", builder.tokenize((node as AnyJSArrayPattern).rest, node));
+    }
+    return group(concat(["[", indent(concat([softline, concat(tokens)])), softline, "]"]));
 }
diff --git a/internal/formatter/builders/js/expressions/JSArrowFunctionExpression.ts b/internal/formatter/builders/js/expressions/JSArrowFunctionExpression.ts
index 2795d9ee2..e7d9e044d 100644
--- a/internal/formatter/builders/js/expressions/JSArrowFunctionExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSArrowFunctionExpression.ts
@@ -4,58 +4,32 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {JSArrowFunctionExpression} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	indent,
-	lineOrSpace,
-	softline,
-	space,
-} from "@internal/formatter";
-
-export default function JSArrowFunctionExpression(
-	builder: Builder,
-	node: JSArrowFunctionExpression,
-): Token {
-	const tokens: Array<Token> = [];
-
-	if (node.head.async === true) {
-		tokens.push("async");
-		tokens.push(space);
-	}
-
-	tokens.push(builder.tokenize(node.head, node));
-	tokens.push(space, "=>");
-
-	const body = builder.tokenize(node.body, node);
-
-	// Keep these types of node on the line as the arrow
-	if (
-		node.body.type === "JSArrayExpression" ||
-		node.body.type === "JSObjectExpression" ||
-		node.body.type === "JSBlockStatement" ||
-		node.body.type === "JSArrowFunctionExpression"
-	) {
-		return group(concat([concat(tokens), space, body]));
-	}
-
-	if (node.body.type === "JSSequenceExpression") {
-		return concat([
-			concat(tokens),
-			group(
-				concat([space, "(", indent(concat([softline, body])), softline, ")"]),
-			),
-		]);
-	}
-
-	return group(
-		concat([
-			concat(tokens),
-			group(concat([indent(concat([lineOrSpace, body])), softline])),
-		]),
-	);
+import {} from "@internal/ast";
+import { Builder, Token, concat, group, indent, lineOrSpace, softline, space, } from "@internal/formatter";
+export default function JSArrowFunctionExpression(builder: Builder, node: JSArrowFunctionExpression): Token {
+    const tokens: Array<Token> = [];
+    if (node.head.async === true) {
+        tokens.push("async");
+        tokens.push(space);
+    }
+    tokens.push(builder.tokenize(node.head, node));
+    tokens.push(space, "=>");
+    const body = builder.tokenize(node.body, node);
+    // Keep these types of node on the line as the arrow
+    if (node.body.type === "JSArrayExpression" ||
+        node.body.type === "JSObjectExpression" ||
+        node.body.type === "JSBlockStatement" ||
+        node.body.type === "JSArrowFunctionExpression") {
+        return group(concat([concat(tokens), space, body]));
+    }
+    if (node.body.type === "JSSequenceExpression") {
+        return concat([
+            concat(tokens),
+            group(concat([space, "(", indent(concat([softline, body])), softline, ")"])),
+        ]);
+    }
+    return group(concat([
+        concat(tokens),
+        group(concat([indent(concat([lineOrSpace, body])), softline])),
+    ]));
 }
diff --git a/internal/formatter/builders/js/expressions/JSAssignmentExpression.ts b/internal/formatter/builders/js/expressions/JSAssignmentExpression.ts
index 4cf14dddd..e0aed25f5 100644
--- a/internal/formatter/builders/js/expressions/JSAssignmentExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSAssignmentExpression.ts
@@ -4,21 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {JSAssignmentExpression} from "@internal/ast";
-import {printAssignment} from "../utils";
-
-export default function JSAssignmentExpression(
-	builder: Builder,
-	node: JSAssignmentExpression,
-): Token {
-	return printAssignment(
-		builder,
-		node,
-		node.left,
-		concat([space, node.operator]),
-		node.right,
-	);
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
+import { printAssignment } from "../utils";
+export default function JSAssignmentExpression(builder: Builder, node: JSAssignmentExpression): Token {
+    return printAssignment(builder, node, node.left, concat([space, node.operator]), node.right);
 }
diff --git a/internal/formatter/builders/js/expressions/JSAwaitExpression.ts b/internal/formatter/builders/js/expressions/JSAwaitExpression.ts
index 88aa892cd..ed0138569 100644
--- a/internal/formatter/builders/js/expressions/JSAwaitExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSAwaitExpression.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {JSAwaitExpression} from "@internal/ast";
-
-export default function JSAwaitExpression(
-	builder: Builder,
-	node: JSAwaitExpression,
-): Token {
-	return concat(["await", space, builder.tokenize(node.argument, node)]);
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSAwaitExpression(builder: Builder, node: JSAwaitExpression): Token {
+    return concat(["await", space, builder.tokenize(node.argument, node)]);
 }
diff --git a/internal/formatter/builders/js/expressions/JSBinaryExpression.ts b/internal/formatter/builders/js/expressions/JSBinaryExpression.ts
index 3bc5529ef..fcd46588a 100644
--- a/internal/formatter/builders/js/expressions/JSBinaryExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSBinaryExpression.ts
@@ -4,78 +4,44 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {AnyNode, JSBinaryExpression, JSLogicalExpression} from "@internal/ast";
-import {getPrecedence, isBinary} from "@internal/js-ast-utils";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	lineOrSpace,
-	space,
-} from "@internal/formatter";
-
-export default function JSBinaryExpression(
-	builder: Builder,
-	node: JSBinaryExpression | JSLogicalExpression,
-	parent: AnyNode,
-): Token {
-	const shouldNotGroup =
-		(parent.type === "JSIfStatement" && parent.test === node) ||
-		(parent.type === "JSDoWhileStatement" && parent.test === node) ||
-		(parent.type === "JSWhileStatement" && parent.test === node) ||
-		(parent.type === "JSSwitchStatement" && parent.discriminant === node);
-
-	const parts = printBinaryExpression(builder, node, parent, shouldNotGroup);
-
-	if (shouldNotGroup) {
-		return concat(parts);
-	}
-
-	return group(concat(parts));
+import { AnyNode, JSLogicalExpression } from "@internal/ast";
+import { getPrecedence, isBinary } from "@internal/js-ast-utils";
+import { Builder, Token, concat, group, lineOrSpace, space, } from "@internal/formatter";
+export default function JSBinaryExpression(builder: Builder, node: JSBinaryExpression | JSLogicalExpression, parent: AnyNode): Token {
+    const shouldNotGroup = (parent.type === "JSIfStatement" && parent.test === node) ||
+        (parent.type === "JSDoWhileStatement" && parent.test === node) ||
+        (parent.type === "JSWhileStatement" && parent.test === node) ||
+        (parent.type === "JSSwitchStatement" && parent.discriminant === node);
+    const parts = printBinaryExpression(builder, node, parent, shouldNotGroup);
+    if (shouldNotGroup) {
+        return concat(parts);
+    }
+    return group(concat(parts));
 }
-
-function printBinaryExpression(
-	builder: Builder,
-	node: JSBinaryExpression | JSLogicalExpression,
-	parent: AnyNode,
-	shouldNotGroup: boolean,
-): Array<Token> {
-	const parts: Array<Token> = [];
-
-	if (
-		isBinary(node.left) &&
-		getPrecedence(node.operator) === getPrecedence(node.left.operator)
-	) {
-		parts.push(
-			...printBinaryExpression(builder, node.left, node, shouldNotGroup),
-		);
-	} else {
-		parts.push(builder.tokenize(node.left, node));
-	}
-
-	// Inline object and array expressions:
-	//   obj && {
-	//   arr ?? [
-	const shouldInline =
-		node.type === "JSLogicalExpression" &&
-		(node.right.type === "JSArrayExpression" ||
-		node.right.type === "JSObjectExpression");
-
-	const right = concat([
-		node.operator,
-		shouldInline ? space : lineOrSpace,
-		builder.tokenize(node.right, node),
-	]);
-
-	const shouldGroup =
-		!shouldNotGroup &&
-		node.type !== parent.type &&
-		node.type !== node.left.type &&
-		node.type !== node.right.type;
-
-	parts.push(concat([space, shouldGroup ? group(right) : right]));
-
-	return parts;
+function printBinaryExpression(builder: Builder, node: JSBinaryExpression | JSLogicalExpression, parent: AnyNode, shouldNotGroup: boolean): Array<Token> {
+    const parts: Array<Token> = [];
+    if (isBinary(node.left) &&
+        getPrecedence(node.operator) === getPrecedence(node.left.operator)) {
+        parts.push(...printBinaryExpression(builder, node.left, node, shouldNotGroup));
+    }
+    else {
+        parts.push(builder.tokenize(node.left, node));
+    }
+    // Inline object and array expressions:
+    //   obj && {
+    //   arr ?? [
+    const shouldInline = node.type === "JSLogicalExpression" &&
+        (node.right.type === "JSArrayExpression" ||
+            node.right.type === "JSObjectExpression");
+    const right = concat([
+        node.operator,
+        shouldInline ? space : lineOrSpace,
+        builder.tokenize(node.right, node),
+    ]);
+    const shouldGroup = !shouldNotGroup &&
+        node.type !== parent.type &&
+        node.type !== node.left.type &&
+        node.type !== node.right.type;
+    parts.push(concat([space, shouldGroup ? group(right) : right]));
+    return parts;
 }
diff --git a/internal/formatter/builders/js/expressions/JSCallExpression.ts b/internal/formatter/builders/js/expressions/JSCallExpression.ts
index c36b1ea6a..69472d226 100644
--- a/internal/formatter/builders/js/expressions/JSCallExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSCallExpression.ts
@@ -4,83 +4,50 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	JSCallExpression,
-	JSNewExpression,
-	JSOptionalCallExpression,
-} from "@internal/ast";
-import {isFunctionNode} from "@internal/js-ast-utils";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	hardline,
-	ifBreak,
-	indent,
-	softline,
-} from "@internal/formatter";
-
-import {printCommaList} from "../utils";
-import {hasInnerComments} from "../../comments";
-
-type AnyCallableExpression =
-	| JSCallExpression
-	| JSOptionalCallExpression
-	| JSNewExpression;
-
-export default function JSCallExpression(
-	builder: Builder,
-	node: AnyCallableExpression,
-): Token {
-	const tokens: Array<Token> = [builder.tokenize(node.callee, node)];
-
-	if (node.type === "JSOptionalCallExpression") {
-		tokens.push("?.");
-	}
-
-	if (node.typeArguments) {
-		tokens.push(builder.tokenize(node.typeArguments, node));
-	}
-
-	tokens.push(printArguments(builder, node));
-
-	return concat(tokens);
+import { JSNewExpression, JSOptionalCallExpression, } from "@internal/ast";
+import { isFunctionNode } from "@internal/js-ast-utils";
+import { Builder, Token, concat, group, hardline, ifBreak, indent, softline, } from "@internal/formatter";
+import { printCommaList } from "../utils";
+import { hasInnerComments } from "../../comments";
+type AnyCallableExpression = JSCallExpression | JSOptionalCallExpression | JSNewExpression;
+export default function JSCallExpression(builder: Builder, node: AnyCallableExpression): Token {
+    const tokens: Array<Token> = [builder.tokenize(node.callee, node)];
+    if (node.type === "JSOptionalCallExpression") {
+        tokens.push("?.");
+    }
+    if (node.typeArguments) {
+        tokens.push(builder.tokenize(node.typeArguments, node));
+    }
+    tokens.push(printArguments(builder, node));
+    return concat(tokens);
 }
-
 function printArguments(builder: Builder, node: AnyCallableExpression): Token {
-	if (node.arguments.length === 0) {
-		if (hasInnerComments(node)) {
-			return concat([
-				"(",
-				builder.tokenizeInnerComments(node, true),
-				hardline,
-				")",
-			]);
-		} else {
-			return "()";
-		}
-	}
-
-	if (node.arguments.length === 1) {
-		const argument = node.arguments[0];
-		if (
-			argument.type === "JSArrayExpression" ||
-			argument.type === "JSObjectExpression" ||
-			isFunctionNode(argument)
-		) {
-			return concat(["(", builder.tokenize(argument, node), ")"]);
-		}
-	}
-
-	return group(
-		concat([
-			"(",
-			indent(concat([softline, printCommaList(builder, node.arguments, node)])),
-			ifBreak(","),
-			softline,
-			")",
-		]),
-	);
+    if (node.arguments.length === 0) {
+        if (hasInnerComments(node)) {
+            return concat([
+                "(",
+                builder.tokenizeInnerComments(node, true),
+                hardline,
+                ")",
+            ]);
+        }
+        else {
+            return "()";
+        }
+    }
+    if (node.arguments.length === 1) {
+        const argument = node.arguments[0];
+        if (argument.type === "JSArrayExpression" ||
+            argument.type === "JSObjectExpression" ||
+            isFunctionNode(argument)) {
+            return concat(["(", builder.tokenize(argument, node), ")"]);
+        }
+    }
+    return group(concat([
+        "(",
+        indent(concat([softline, printCommaList(builder, node.arguments, node)])),
+        ifBreak(","),
+        softline,
+        ")",
+    ]));
 }
diff --git a/internal/formatter/builders/js/expressions/JSConditionalExpression.ts b/internal/formatter/builders/js/expressions/JSConditionalExpression.ts
index bbc4101d9..202bc72a3 100644
--- a/internal/formatter/builders/js/expressions/JSConditionalExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSConditionalExpression.ts
@@ -4,70 +4,33 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {AnyNode, JSConditionalExpression} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	indent,
-	lineOrSpace,
-	space,
-} from "@internal/formatter";
-
-export default function JSConditionalExpression(
-	builder: Builder,
-	node: JSConditionalExpression,
-	parent: AnyNode,
-): Token {
-	return printConditionalExpression(
-		builder.tokenize(node.test, node),
-		builder.tokenize(node.consequent, node),
-		builder.tokenize(node.alternate, node),
-		parent,
-		node.consequent,
-		node.alternate,
-	);
+import { AnyNode } from "@internal/ast";
+import { Builder, Token, concat, group, indent, lineOrSpace, space, } from "@internal/formatter";
+export default function JSConditionalExpression(builder: Builder, node: JSConditionalExpression, parent: AnyNode): Token {
+    return printConditionalExpression(builder.tokenize(node.test, node), builder.tokenize(node.consequent, node), builder.tokenize(node.alternate, node), parent, node.consequent, node.alternate);
 }
-
 function isConditionalExpression(node: AnyNode): boolean {
-	return (
-		node.type === "JSConditionalExpression" || node.type === "TSConditionalType"
-	);
+    return (node.type === "JSConditionalExpression" || node.type === "TSConditionalType");
 }
-
-export function printConditionalExpression(
-	test: Token,
-	consequent: Token,
-	alternate: Token,
-	parentNode: AnyNode,
-	consequentNode: AnyNode,
-	alternateNode: AnyNode,
-): Token {
-	const printed = concat([
-		test,
-		indent(
-			concat([
-				lineOrSpace,
-				"?",
-				space,
-				isConditionalExpression(consequentNode)
-					? consequent
-					: indent(consequent),
-			]),
-		),
-		indent(
-			concat([
-				lineOrSpace,
-				":",
-				space,
-				isConditionalExpression(alternateNode) ? alternate : indent(alternate),
-			]),
-		),
-	]);
-
-	// Do not group nested conditional expressions. By doing so, if a conditional
-	// expression breaks, the hole chain breaks.
-	return isConditionalExpression(parentNode) ? printed : group(printed);
+export function printConditionalExpression(test: Token, consequent: Token, alternate: Token, parentNode: AnyNode, consequentNode: AnyNode, alternateNode: AnyNode): Token {
+    const printed = concat([
+        test,
+        indent(concat([
+            lineOrSpace,
+            "?",
+            space,
+            isConditionalExpression(consequentNode)
+                ? consequent
+                : indent(consequent),
+        ])),
+        indent(concat([
+            lineOrSpace,
+            ":",
+            space,
+            isConditionalExpression(alternateNode) ? alternate : indent(alternate),
+        ])),
+    ]);
+    // Do not group nested conditional expressions. By doing so, if a conditional
+    // expression breaks, the hole chain breaks.
+    return isConditionalExpression(parentNode) ? printed : group(printed);
 }
diff --git a/internal/formatter/builders/js/expressions/JSDoExpression.ts b/internal/formatter/builders/js/expressions/JSDoExpression.ts
index 768e22d96..074395288 100644
--- a/internal/formatter/builders/js/expressions/JSDoExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSDoExpression.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {JSDoExpression} from "@internal/ast";
-
-export default function JSDoExpression(
-	builder: Builder,
-	node: JSDoExpression,
-): Token {
-	return concat(["do", space, builder.tokenize(node.body, node)]);
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSDoExpression(builder: Builder, node: JSDoExpression): Token {
+    return concat(["do", space, builder.tokenize(node.body, node)]);
 }
diff --git a/internal/formatter/builders/js/expressions/JSFunctionExpression.ts b/internal/formatter/builders/js/expressions/JSFunctionExpression.ts
index 2eb951c65..3ba3c8fd5 100644
--- a/internal/formatter/builders/js/expressions/JSFunctionExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSFunctionExpression.ts
@@ -4,37 +4,21 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {JSFunctionDeclaration, JSFunctionExpression} from "@internal/ast";
-
-export default function JSFunctionExpression(
-	builder: Builder,
-	node: JSFunctionDeclaration | JSFunctionExpression,
-): Token {
-	const tokens: Array<Token> = [];
-
-	if (node.head.async === true) {
-		tokens.push("async");
-		tokens.push(space);
-	}
-
-	tokens.push("function");
-
-	if (node.head.generator === true) {
-		tokens.push("*");
-	}
-
-	if (node.id) {
-		tokens.push(space, builder.tokenize(node.id, node));
-	}
-
-	tokens.push(
-		builder.tokenize(node.head, node),
-		space,
-		builder.tokenize(node.body, node),
-	);
-
-	return concat(tokens);
+import { Builder, Token, concat, space } from "@internal/formatter";
+import { JSFunctionDeclaration } from "@internal/ast";
+export default function JSFunctionExpression(builder: Builder, node: JSFunctionDeclaration | JSFunctionExpression): Token {
+    const tokens: Array<Token> = [];
+    if (node.head.async === true) {
+        tokens.push("async");
+        tokens.push(space);
+    }
+    tokens.push("function");
+    if (node.head.generator === true) {
+        tokens.push("*");
+    }
+    if (node.id) {
+        tokens.push(space, builder.tokenize(node.id, node));
+    }
+    tokens.push(builder.tokenize(node.head, node), space, builder.tokenize(node.body, node));
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/expressions/JSLogicalExpression.ts b/internal/formatter/builders/js/expressions/JSLogicalExpression.ts
index e3ec3012b..6186c4dfd 100644
--- a/internal/formatter/builders/js/expressions/JSLogicalExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSLogicalExpression.ts
@@ -4,16 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {AnyNode, JSLogicalExpression} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+import { AnyNode } from "@internal/ast";
 import JSBinaryExpression from "./JSBinaryExpression";
-
-export default function JSLogicalExpression(
-	builder: Builder,
-	node: JSLogicalExpression,
-	parent: AnyNode,
-): Token {
-	return JSBinaryExpression(builder, node, parent);
+export default function JSLogicalExpression(builder: Builder, node: JSLogicalExpression, parent: AnyNode): Token {
+    return JSBinaryExpression(builder, node, parent);
 }
diff --git a/internal/formatter/builders/js/expressions/JSMemberExpression.ts b/internal/formatter/builders/js/expressions/JSMemberExpression.ts
index 4e804a193..8d5ac45aa 100644
--- a/internal/formatter/builders/js/expressions/JSMemberExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSMemberExpression.ts
@@ -4,17 +4,11 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSMemberExpression} from "@internal/ast";
-
-export default function JSMemberExpression(
-	builder: Builder,
-	node: JSMemberExpression,
-): Token {
-	return concat([
-		builder.tokenize(node.object, node),
-		builder.tokenize(node.property, node),
-	]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSMemberExpression(builder: Builder, node: JSMemberExpression): Token {
+    return concat([
+        builder.tokenize(node.object, node),
+        builder.tokenize(node.property, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/expressions/JSMetaProperty.ts b/internal/formatter/builders/js/expressions/JSMetaProperty.ts
index 4b31a668f..04ba739da 100644
--- a/internal/formatter/builders/js/expressions/JSMetaProperty.ts
+++ b/internal/formatter/builders/js/expressions/JSMetaProperty.ts
@@ -4,18 +4,12 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSMetaProperty} from "@internal/ast";
-
-export default function JSMetaProperty(
-	builder: Builder,
-	node: JSMetaProperty,
-): Token {
-	return concat([
-		builder.tokenize(node.meta, node),
-		".",
-		builder.tokenize(node.property, node),
-	]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSMetaProperty(builder: Builder, node: JSMetaProperty): Token {
+    return concat([
+        builder.tokenize(node.meta, node),
+        ".",
+        builder.tokenize(node.property, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/expressions/JSNewExpression.ts b/internal/formatter/builders/js/expressions/JSNewExpression.ts
index 6a2ee9a35..ebb4c493a 100644
--- a/internal/formatter/builders/js/expressions/JSNewExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSNewExpression.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {JSNewExpression} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
 import JSCallExpression from "./JSCallExpression";
-
-export default function JSNewExpression(
-	builder: Builder,
-	node: JSNewExpression,
-): Token {
-	return concat(["new", space, JSCallExpression(builder, node)]);
+export default function JSNewExpression(builder: Builder, node: JSNewExpression): Token {
+    return concat(["new", space, JSCallExpression(builder, node)]);
 }
diff --git a/internal/formatter/builders/js/expressions/JSOptionalCallExpression.ts b/internal/formatter/builders/js/expressions/JSOptionalCallExpression.ts
index 8b6497f59..3379d9ee8 100644
--- a/internal/formatter/builders/js/expressions/JSOptionalCallExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSOptionalCallExpression.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSOptionalCallExpression} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
 import JSCallExpression from "./JSCallExpression";
-
-export default function JSOptionalCallExpression(
-	builder: Builder,
-	node: JSOptionalCallExpression,
-): Token {
-	return JSCallExpression(builder, node);
+export default function JSOptionalCallExpression(builder: Builder, node: JSOptionalCallExpression): Token {
+    return JSCallExpression(builder, node);
 }
diff --git a/internal/formatter/builders/js/expressions/JSReferenceIdentifier.ts b/internal/formatter/builders/js/expressions/JSReferenceIdentifier.ts
index 92adc41f4..4308bfefe 100644
--- a/internal/formatter/builders/js/expressions/JSReferenceIdentifier.ts
+++ b/internal/formatter/builders/js/expressions/JSReferenceIdentifier.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSReferenceIdentifier} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
 import JSIdentifier from "../auxiliary/JSIdentifier";
-
-export default function JSReferenceIdentifier(
-	builder: Builder,
-	node: JSReferenceIdentifier,
-): Token {
-	return JSIdentifier(builder, node);
+export default function JSReferenceIdentifier(builder: Builder, node: JSReferenceIdentifier): Token {
+    return JSIdentifier(builder, node);
 }
diff --git a/internal/formatter/builders/js/expressions/JSSequenceExpression.ts b/internal/formatter/builders/js/expressions/JSSequenceExpression.ts
index 50fce340d..2659886e0 100644
--- a/internal/formatter/builders/js/expressions/JSSequenceExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSSequenceExpression.ts
@@ -4,47 +4,21 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {AnyNode, JSSequenceExpression} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	indent,
-	join,
-	lineOrSpace,
-} from "@internal/formatter";
-
-export default function JSSequenceExpression(
-	builder: Builder,
-	node: JSSequenceExpression,
-	parent: AnyNode,
-): Token {
-	if (
-		parent.type === "JSExpressionStatement" ||
-		parent.type === "JSForStatement" ||
-		parent.type === "JSSequenceExpression"
-	) {
-		// Indent expressions after the first to improve the readability
-		return group(
-			concat(
-				node.expressions.map((expr, i) =>
-					i === 0
-						? builder.tokenize(expr, node)
-						: concat([
-								",",
-								indent(concat([lineOrSpace, builder.tokenize(expr, node)])),
-							])
-				),
-			),
-		);
-	} else {
-		return group(
-			join(
-				concat([",", lineOrSpace]),
-				node.expressions.map((expr) => builder.tokenize(expr, node)),
-			),
-		);
-	}
+import { AnyNode } from "@internal/ast";
+import { Builder, Token, concat, group, indent, join, lineOrSpace, } from "@internal/formatter";
+export default function JSSequenceExpression(builder: Builder, node: JSSequenceExpression, parent: AnyNode): Token {
+    if (parent.type === "JSExpressionStatement" ||
+        parent.type === "JSForStatement" ||
+        parent.type === "JSSequenceExpression") {
+        // Indent expressions after the first to improve the readability
+        return group(concat(node.expressions.map((expr, i) => i === 0
+            ? builder.tokenize(expr, node)
+            : concat([
+                ",",
+                indent(concat([lineOrSpace, builder.tokenize(expr, node)])),
+            ]))));
+    }
+    else {
+        return group(join(concat([",", lineOrSpace]), node.expressions.map((expr) => builder.tokenize(expr, node))));
+    }
 }
diff --git a/internal/formatter/builders/js/expressions/JSTaggedTemplateExpression.ts b/internal/formatter/builders/js/expressions/JSTaggedTemplateExpression.ts
index 058c86cdb..65d7c1769 100644
--- a/internal/formatter/builders/js/expressions/JSTaggedTemplateExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSTaggedTemplateExpression.ts
@@ -4,17 +4,11 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSTaggedTemplateExpression} from "@internal/ast";
-
-export default function JSTaggedTemplateExpression(
-	builder: Builder,
-	node: JSTaggedTemplateExpression,
-): Token {
-	return concat([
-		builder.tokenize(node.tag, node),
-		builder.tokenize(node.quasi, node),
-	]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSTaggedTemplateExpression(builder: Builder, node: JSTaggedTemplateExpression): Token {
+    return concat([
+        builder.tokenize(node.tag, node),
+        builder.tokenize(node.quasi, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/expressions/JSUnaryExpression.ts b/internal/formatter/builders/js/expressions/JSUnaryExpression.ts
index 949ae9d0c..d0fe6b723 100644
--- a/internal/formatter/builders/js/expressions/JSUnaryExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSUnaryExpression.ts
@@ -4,22 +4,15 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {JSUnaryExpression} from "@internal/ast";
-
-export default function JSUnaryExpression(
-	builder: Builder,
-	node: JSUnaryExpression,
-): Token {
-	if (
-		node.operator === "void" ||
-		node.operator === "delete" ||
-		node.operator === "typeof"
-	) {
-		return concat([node.operator, space, builder.tokenize(node.argument, node)]);
-	} else {
-		return concat([node.operator, builder.tokenize(node.argument, node)]);
-	}
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSUnaryExpression(builder: Builder, node: JSUnaryExpression): Token {
+    if (node.operator === "void" ||
+        node.operator === "delete" ||
+        node.operator === "typeof") {
+        return concat([node.operator, space, builder.tokenize(node.argument, node)]);
+    }
+    else {
+        return concat([node.operator, builder.tokenize(node.argument, node)]);
+    }
 }
diff --git a/internal/formatter/builders/js/expressions/JSUpdateExpression.ts b/internal/formatter/builders/js/expressions/JSUpdateExpression.ts
index 274d30f8c..3a1085718 100644
--- a/internal/formatter/builders/js/expressions/JSUpdateExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSUpdateExpression.ts
@@ -4,18 +4,13 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSUpdateExpression} from "@internal/ast";
-
-export default function JSUpdateExpression(
-	builder: Builder,
-	node: JSUpdateExpression,
-): Token {
-	if (node.prefix === true) {
-		return concat([node.operator, builder.tokenize(node.argument, node)]);
-	} else {
-		return concat([builder.tokenize(node.argument, node), node.operator]);
-	}
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSUpdateExpression(builder: Builder, node: JSUpdateExpression): Token {
+    if (node.prefix === true) {
+        return concat([node.operator, builder.tokenize(node.argument, node)]);
+    }
+    else {
+        return concat([builder.tokenize(node.argument, node), node.operator]);
+    }
 }
diff --git a/internal/formatter/builders/js/expressions/JSYieldExpression.ts b/internal/formatter/builders/js/expressions/JSYieldExpression.ts
index f5f55e943..e48af454b 100644
--- a/internal/formatter/builders/js/expressions/JSYieldExpression.ts
+++ b/internal/formatter/builders/js/expressions/JSYieldExpression.ts
@@ -4,24 +4,15 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {JSYieldExpression} from "@internal/ast";
-
-export default function JSYieldExpression(
-	builder: Builder,
-	node: JSYieldExpression,
-): Token {
-	const tokens: Array<Token> = ["yield"];
-
-	if (node.delegate === true) {
-		tokens.push("*");
-	}
-
-	if (node.argument) {
-		tokens.push(space, builder.tokenize(node.argument, node));
-	}
-
-	return concat(tokens);
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSYieldExpression(builder: Builder, node: JSYieldExpression): Token {
+    const tokens: Array<Token> = ["yield"];
+    if (node.delegate === true) {
+        tokens.push("*");
+    }
+    if (node.argument) {
+        tokens.push(space, builder.tokenize(node.argument, node));
+    }
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/jsx/JSXAttribute.ts b/internal/formatter/builders/js/jsx/JSXAttribute.ts
index 89decac99..ebaba47fe 100644
--- a/internal/formatter/builders/js/jsx/JSXAttribute.ts
+++ b/internal/formatter/builders/js/jsx/JSXAttribute.ts
@@ -4,20 +4,14 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSXAttribute} from "@internal/ast";
-
-export default function JSXAttribute(
-	builder: Builder,
-	node: JSXAttribute,
-): Token {
-	const tokens: Array<Token> = [builder.tokenize(node.name, node)];
-
-	if (node.value) {
-		return concat([concat(tokens), "=", builder.tokenize(node.value, node)]);
-	} else {
-		return concat(tokens);
-	}
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSXAttribute(builder: Builder, node: JSXAttribute): Token {
+    const tokens: Array<Token> = [builder.tokenize(node.name, node)];
+    if (node.value) {
+        return concat([concat(tokens), "=", builder.tokenize(node.value, node)]);
+    }
+    else {
+        return concat(tokens);
+    }
 }
diff --git a/internal/formatter/builders/js/jsx/JSXElement.ts b/internal/formatter/builders/js/jsx/JSXElement.ts
index 4b54f028f..747443a96 100644
--- a/internal/formatter/builders/js/jsx/JSXElement.ts
+++ b/internal/formatter/builders/js/jsx/JSXElement.ts
@@ -4,50 +4,30 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	hardline,
-	indent,
-	join,
-	lineOrSpace,
-	space,
-} from "@internal/formatter";
-
-import {JSXElement} from "@internal/ast";
-
+import { Builder, Token, concat, group, hardline, indent, join, lineOrSpace, space, } from "@internal/formatter";
+import {} from "@internal/ast";
 export default function JSXElement(builder: Builder, node: JSXElement): Token {
-	const tokens: Array<Token> = [
-		"<",
-		builder.tokenize(node.name, node),
-		builder.tokenize(node.typeArguments, node),
-	];
-
-	if (node.attributes.length > 0) {
-		tokens.push(
-			space,
-			join(
-				lineOrSpace,
-				node.attributes.map((attr) => builder.tokenize(attr, node)),
-			),
-		);
-	}
-
-	if (node.selfClosing !== false && node.children.length === 0) {
-		return group(concat([concat(tokens), space, "/>"]));
-	} else {
-		return concat([
-			group(concat([concat(tokens), ">"])),
-			concat([
-				indent(builder.tokenizeStatementList(node.children, node), true),
-				hardline,
-			]),
-			"</",
-			builder.tokenize(node.name, node),
-			">",
-		]);
-	}
+    const tokens: Array<Token> = [
+        "<",
+        builder.tokenize(node.name, node),
+        builder.tokenize(node.typeArguments, node),
+    ];
+    if (node.attributes.length > 0) {
+        tokens.push(space, join(lineOrSpace, node.attributes.map((attr) => builder.tokenize(attr, node))));
+    }
+    if (node.selfClosing !== false && node.children.length === 0) {
+        return group(concat([concat(tokens), space, "/>"]));
+    }
+    else {
+        return concat([
+            group(concat([concat(tokens), ">"])),
+            concat([
+                indent(builder.tokenizeStatementList(node.children, node), true),
+                hardline,
+            ]),
+            "</",
+            builder.tokenize(node.name, node),
+            ">",
+        ]);
+    }
 }
diff --git a/internal/formatter/builders/js/jsx/JSXEmptyExpression.ts b/internal/formatter/builders/js/jsx/JSXEmptyExpression.ts
index 5348ac25b..833c6dc90 100644
--- a/internal/formatter/builders/js/jsx/JSXEmptyExpression.ts
+++ b/internal/formatter/builders/js/jsx/JSXEmptyExpression.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSXEmptyExpression} from "@internal/ast";
-
-export default function JSXEmptyExpression(
-	builder: Builder,
-	node: JSXEmptyExpression,
-): Token {
-	return builder.tokenizeInnerComments(node, false);
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSXEmptyExpression(builder: Builder, node: JSXEmptyExpression): Token {
+    return builder.tokenizeInnerComments(node, false);
 }
diff --git a/internal/formatter/builders/js/jsx/JSXExpressionContainer.ts b/internal/formatter/builders/js/jsx/JSXExpressionContainer.ts
index 7e5971290..30141c4d0 100644
--- a/internal/formatter/builders/js/jsx/JSXExpressionContainer.ts
+++ b/internal/formatter/builders/js/jsx/JSXExpressionContainer.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSXExpressionContainer} from "@internal/ast";
-
-export default function JSXExpressionContainer(
-	builder: Builder,
-	node: JSXExpressionContainer,
-): Token {
-	return concat(["{", builder.tokenize(node.expression, node), "}"]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSXExpressionContainer(builder: Builder, node: JSXExpressionContainer): Token {
+    return concat(["{", builder.tokenize(node.expression, node), "}"]);
 }
diff --git a/internal/formatter/builders/js/jsx/JSXFragment.ts b/internal/formatter/builders/js/jsx/JSXFragment.ts
index 03b53c0c1..5f8bac58c 100644
--- a/internal/formatter/builders/js/jsx/JSXFragment.ts
+++ b/internal/formatter/builders/js/jsx/JSXFragment.ts
@@ -4,18 +4,15 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, hardline, indent} from "@internal/formatter";
-
-import {JSXFragment} from "@internal/ast";
-
+import { Builder, Token, concat, hardline, indent } from "@internal/formatter";
+import {} from "@internal/ast";
 export default function JSXFragment(builder: Builder, node: JSXFragment): Token {
-	return concat([
-		"<>",
-		concat([
-			indent(builder.tokenizeStatementList(node.children, node), true),
-			hardline,
-		]),
-		"</>",
-	]);
+    return concat([
+        "<>",
+        concat([
+            indent(builder.tokenizeStatementList(node.children, node), true),
+            hardline,
+        ]),
+        "</>",
+    ]);
 }
diff --git a/internal/formatter/builders/js/jsx/JSXIdentifier.ts b/internal/formatter/builders/js/jsx/JSXIdentifier.ts
index 317ff023c..fedf32239 100644
--- a/internal/formatter/builders/js/jsx/JSXIdentifier.ts
+++ b/internal/formatter/builders/js/jsx/JSXIdentifier.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSXIdentifier} from "@internal/ast";
-
-export default function JSXIdentifier(
-	builder: Builder,
-	node: JSXIdentifier,
-): Token {
-	return node.name;
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSXIdentifier(builder: Builder, node: JSXIdentifier): Token {
+    return node.name;
 }
diff --git a/internal/formatter/builders/js/jsx/JSXMemberExpression.ts b/internal/formatter/builders/js/jsx/JSXMemberExpression.ts
index 3d69fa5c5..a3ba3c99e 100644
--- a/internal/formatter/builders/js/jsx/JSXMemberExpression.ts
+++ b/internal/formatter/builders/js/jsx/JSXMemberExpression.ts
@@ -4,18 +4,12 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSXMemberExpression} from "@internal/ast";
-
-export default function JSXMemberExpression(
-	builder: Builder,
-	node: JSXMemberExpression,
-): Token {
-	return concat([
-		builder.tokenize(node.object, node),
-		".",
-		builder.tokenize(node.property, node),
-	]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSXMemberExpression(builder: Builder, node: JSXMemberExpression): Token {
+    return concat([
+        builder.tokenize(node.object, node),
+        ".",
+        builder.tokenize(node.property, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/jsx/JSXNamespacedName.ts b/internal/formatter/builders/js/jsx/JSXNamespacedName.ts
index e62e24f5b..9634060a3 100644
--- a/internal/formatter/builders/js/jsx/JSXNamespacedName.ts
+++ b/internal/formatter/builders/js/jsx/JSXNamespacedName.ts
@@ -4,18 +4,12 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSXNamespacedName} from "@internal/ast";
-
-export default function JSXNamespacedName(
-	builder: Builder,
-	node: JSXNamespacedName,
-): Token {
-	return concat([
-		builder.tokenize(node.namespace, node),
-		":",
-		builder.tokenize(node.name, node),
-	]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSXNamespacedName(builder: Builder, node: JSXNamespacedName): Token {
+    return concat([
+        builder.tokenize(node.namespace, node),
+        ":",
+        builder.tokenize(node.name, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/jsx/JSXReferenceIdentifier.ts b/internal/formatter/builders/js/jsx/JSXReferenceIdentifier.ts
index 61e36d038..f209ebfb2 100644
--- a/internal/formatter/builders/js/jsx/JSXReferenceIdentifier.ts
+++ b/internal/formatter/builders/js/jsx/JSXReferenceIdentifier.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSXReferenceIdentifier} from "@internal/ast";
-
-export default function JSXReferenceIdentifier(
-	builder: Builder,
-	node: JSXReferenceIdentifier,
-): Token {
-	return node.name;
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSXReferenceIdentifier(builder: Builder, node: JSXReferenceIdentifier): Token {
+    return node.name;
 }
diff --git a/internal/formatter/builders/js/jsx/JSXSpreadAttribute.ts b/internal/formatter/builders/js/jsx/JSXSpreadAttribute.ts
index 89b7b1583..72a800650 100644
--- a/internal/formatter/builders/js/jsx/JSXSpreadAttribute.ts
+++ b/internal/formatter/builders/js/jsx/JSXSpreadAttribute.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSXSpreadAttribute} from "@internal/ast";
-
-export default function JSXSpreadAttribute(
-	builder: Builder,
-	node: JSXSpreadAttribute,
-): Token {
-	return concat(["{", "...", builder.tokenize(node.argument, node), "}"]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSXSpreadAttribute(builder: Builder, node: JSXSpreadAttribute): Token {
+    return concat(["{", "...", builder.tokenize(node.argument, node), "}"]);
 }
diff --git a/internal/formatter/builders/js/jsx/JSXSpreadChild.ts b/internal/formatter/builders/js/jsx/JSXSpreadChild.ts
index c2f49e986..ebe01ce32 100644
--- a/internal/formatter/builders/js/jsx/JSXSpreadChild.ts
+++ b/internal/formatter/builders/js/jsx/JSXSpreadChild.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSXSpreadChild} from "@internal/ast";
-
-export default function JSXSpreadChild(
-	builder: Builder,
-	node: JSXSpreadChild,
-): Token {
-	return concat(["{", "...", builder.tokenize(node.expression, node), "}"]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSXSpreadChild(builder: Builder, node: JSXSpreadChild): Token {
+    return concat(["{", "...", builder.tokenize(node.expression, node), "}"]);
 }
diff --git a/internal/formatter/builders/js/jsx/JSXText.ts b/internal/formatter/builders/js/jsx/JSXText.ts
index 19055d15f..002c3515a 100644
--- a/internal/formatter/builders/js/jsx/JSXText.ts
+++ b/internal/formatter/builders/js/jsx/JSXText.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-import {JSXText} from "@internal/ast";
-import {escapeXHTMLEntities} from "@internal/html-parser";
-import {cleanJSXText} from "@internal/js-ast-utils";
-
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
+import { escapeXHTMLEntities } from "@internal/html-parser";
+import { cleanJSXText } from "@internal/js-ast-utils";
 export default function JSXText(builder: Builder, node: JSXText): Token {
-	return escapeXHTMLEntities(cleanJSXText(node.value));
+    return escapeXHTMLEntities(cleanJSXText(node.value));
 }
diff --git a/internal/formatter/builders/js/literals/JSBigIntLiteral.ts b/internal/formatter/builders/js/literals/JSBigIntLiteral.ts
index 74b075495..74fef5f83 100644
--- a/internal/formatter/builders/js/literals/JSBigIntLiteral.ts
+++ b/internal/formatter/builders/js/literals/JSBigIntLiteral.ts
@@ -4,13 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {JSBigIntLiteral} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function JSBigIntLiteral(
-	builder: Builder,
-	node: JSBigIntLiteral,
-): Token {
-	return `${node.value}n`;
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function JSBigIntLiteral(builder: Builder, node: JSBigIntLiteral): Token {
+    return `${node.value}n`;
 }
diff --git a/internal/formatter/builders/js/literals/JSBooleanLiteral.ts b/internal/formatter/builders/js/literals/JSBooleanLiteral.ts
index e55ae9397..ee497531f 100644
--- a/internal/formatter/builders/js/literals/JSBooleanLiteral.ts
+++ b/internal/formatter/builders/js/literals/JSBooleanLiteral.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSBooleanLiteral} from "@internal/ast";
-
-export default function JSBooleanLiteral(
-	builder: Builder,
-	node: JSBooleanLiteral,
-): Token {
-	return node.value ? "true" : "false";
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSBooleanLiteral(builder: Builder, node: JSBooleanLiteral): Token {
+    return node.value ? "true" : "false";
 }
diff --git a/internal/formatter/builders/js/literals/JSNumericLiteral.ts b/internal/formatter/builders/js/literals/JSNumericLiteral.ts
index b9e72f9c6..ab20ac5d5 100644
--- a/internal/formatter/builders/js/literals/JSNumericLiteral.ts
+++ b/internal/formatter/builders/js/literals/JSNumericLiteral.ts
@@ -4,30 +4,26 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSNumericLiteral} from "@internal/ast";
-import {humanizeNumber} from "@internal/string-utils";
-
-export default function JSNumericLiteral(
-	builder: Builder,
-	node: JSNumericLiteral,
-): Token {
-	if (builder.options.format === "pretty") {
-		if (node.format === undefined) {
-			return humanizeNumber(node.value);
-		} else {
-			switch (node.format) {
-				case "binary":
-					return `0b${node.value.toString(2)}`;
-				case "octal":
-					return `0o${node.value.toString(8)}`;
-				case "hex":
-					return `0x${node.value.toString(16)}`;
-			}
-		}
-	} else {
-		return String(node.value);
-	}
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
+import { humanizeNumber } from "@internal/string-utils";
+export default function JSNumericLiteral(builder: Builder, node: JSNumericLiteral): Token {
+    if (builder.options.format === "pretty") {
+        if (node.format === undefined) {
+            return humanizeNumber(node.value);
+        }
+        else {
+            switch (node.format) {
+                case "binary":
+                    return `0b${node.value.toString(2)}`;
+                case "octal":
+                    return `0o${node.value.toString(8)}`;
+                case "hex":
+                    return `0x${node.value.toString(16)}`;
+            }
+        }
+    }
+    else {
+        return String(node.value);
+    }
 }
diff --git a/internal/formatter/builders/js/literals/JSRegExpLiteral.ts b/internal/formatter/builders/js/literals/JSRegExpLiteral.ts
index 7f0126090..524efc69a 100644
--- a/internal/formatter/builders/js/literals/JSRegExpLiteral.ts
+++ b/internal/formatter/builders/js/literals/JSRegExpLiteral.ts
@@ -4,45 +4,32 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSRegExpLiteral} from "@internal/ast";
-
-export default function JSRegExpLiteral(
-	builder: Builder,
-	node: JSRegExpLiteral,
-): Token {
-	const flags: Array<string> = [];
-
-	if (node.global === true) {
-		flags.push("g");
-	}
-
-	if (node.multiline === true) {
-		flags.push("m");
-	}
-
-	if (node.sticky === true) {
-		flags.push("y");
-	}
-
-	if (node.insensitive === true) {
-		flags.push("i");
-	}
-
-	if (node.noDotNewline === true) {
-		flags.push("s");
-	}
-
-	if (node.unicode === true) {
-		flags.push("u");
-	}
-
-	return concat([
-		"/",
-		builder.tokenize(node.expression, node),
-		"/",
-		flags.join(""),
-	]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSRegExpLiteral(builder: Builder, node: JSRegExpLiteral): Token {
+    const flags: Array<string> = [];
+    if (node.global === true) {
+        flags.push("g");
+    }
+    if (node.multiline === true) {
+        flags.push("m");
+    }
+    if (node.sticky === true) {
+        flags.push("y");
+    }
+    if (node.insensitive === true) {
+        flags.push("i");
+    }
+    if (node.noDotNewline === true) {
+        flags.push("s");
+    }
+    if (node.unicode === true) {
+        flags.push("u");
+    }
+    return concat([
+        "/",
+        builder.tokenize(node.expression, node),
+        "/",
+        flags.join(""),
+    ]);
 }
diff --git a/internal/formatter/builders/js/literals/JSStringLiteral.ts b/internal/formatter/builders/js/literals/JSStringLiteral.ts
index 2160cea6d..39d38e2e3 100644
--- a/internal/formatter/builders/js/literals/JSStringLiteral.ts
+++ b/internal/formatter/builders/js/literals/JSStringLiteral.ts
@@ -4,30 +4,14 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {escapeJSString} from "@internal/string-escape";
-import {
-	AnyNode,
-	JSDirective,
-	JSStringLiteral,
-	TSStringLiteralTypeAnnotation,
-} from "@internal/ast";
-import {escapeXHTMLEntities} from "@internal/html-parser";
-
-export default function JSStringLiteral(
-	builder: Builder,
-	node: JSDirective | JSStringLiteral | TSStringLiteralTypeAnnotation,
-	parent: AnyNode,
-): Token {
-	const quotes =
-		parent.type === "JSXAttribute" || !node.value.includes('"') ? '"' : "'";
-
-	const value =
-		parent.type === "JSXAttribute"
-			? escapeXHTMLEntities(node.value)
-			: node.value;
-
-	return escapeJSString(value, {quote: quotes});
+import { Builder, Token } from "@internal/formatter";
+import { escapeJSString } from "@internal/string-escape";
+import { AnyNode, JSDirective, TSStringLiteralTypeAnnotation, } from "@internal/ast";
+import { escapeXHTMLEntities } from "@internal/html-parser";
+export default function JSStringLiteral(builder: Builder, node: JSDirective | JSStringLiteral | TSStringLiteralTypeAnnotation, parent: AnyNode): Token {
+    const quotes = parent.type === "JSXAttribute" || !node.value.includes('"') ? '"' : "'";
+    const value = parent.type === "JSXAttribute"
+        ? escapeXHTMLEntities(node.value)
+        : node.value;
+    return escapeJSString(value, { quote: quotes });
 }
diff --git a/internal/formatter/builders/js/literals/JSTemplateLiteral.ts b/internal/formatter/builders/js/literals/JSTemplateLiteral.ts
index 85a2f31fc..f47d2673e 100644
--- a/internal/formatter/builders/js/literals/JSTemplateLiteral.ts
+++ b/internal/formatter/builders/js/literals/JSTemplateLiteral.ts
@@ -4,24 +4,16 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-import {JSTemplateLiteral} from "@internal/ast";
-
-export default function JSTemplateLiteral(
-	builder: Builder,
-	node: JSTemplateLiteral,
-): Token {
-	const tokens: Array<Token> = [];
-	const quasis = node.quasis;
-
-	for (let i = 0; i < quasis.length; i++) {
-		tokens.push(builder.tokenize(quasis[i], node));
-
-		if (i + 1 < quasis.length) {
-			tokens.push(builder.tokenize(node.expressions[i], node));
-		}
-	}
-
-	return concat(tokens);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSTemplateLiteral(builder: Builder, node: JSTemplateLiteral): Token {
+    const tokens: Array<Token> = [];
+    const quasis = node.quasis;
+    for (let i = 0; i < quasis.length; i++) {
+        tokens.push(builder.tokenize(quasis[i], node));
+        if (i + 1 < quasis.length) {
+            tokens.push(builder.tokenize(node.expressions[i], node));
+        }
+    }
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/modules/JSExportAllDeclaration.ts b/internal/formatter/builders/js/modules/JSExportAllDeclaration.ts
index ba31a6bbd..11fc6a750 100644
--- a/internal/formatter/builders/js/modules/JSExportAllDeclaration.ts
+++ b/internal/formatter/builders/js/modules/JSExportAllDeclaration.ts
@@ -4,32 +4,16 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {JSExportAllDeclaration} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-export default function JSExportAllDeclaration(
-	builder: Builder,
-	node: JSExportAllDeclaration,
-): Token {
-	const tokens: Array<Token> = ["export", space];
-
-	if (node.exportKind === "type") {
-		if (!builder.options.typeAnnotations) {
-			return "";
-		}
-
-		tokens.push("type", space);
-	}
-
-	tokens.push(
-		"*",
-		space,
-		"from",
-		space,
-		builder.tokenize(node.source, node),
-		";",
-	);
-
-	return concat(tokens);
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+export default function JSExportAllDeclaration(builder: Builder, node: JSExportAllDeclaration): Token {
+    const tokens: Array<Token> = ["export", space];
+    if (node.exportKind === "type") {
+        if (!builder.options.typeAnnotations) {
+            return "";
+        }
+        tokens.push("type", space);
+    }
+    tokens.push("*", space, "from", space, builder.tokenize(node.source, node), ";");
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/modules/JSExportDefaultDeclaration.ts b/internal/formatter/builders/js/modules/JSExportDefaultDeclaration.ts
index 352365cfe..3a0350605 100644
--- a/internal/formatter/builders/js/modules/JSExportDefaultDeclaration.ts
+++ b/internal/formatter/builders/js/modules/JSExportDefaultDeclaration.ts
@@ -4,21 +4,15 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {JSExportDefaultDeclaration} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {printExportDeclaration} from "./JSExportLocalDeclaration";
-
-export default function JSExportDefaultDeclaration(
-	builder: Builder,
-	node: JSExportDefaultDeclaration,
-): Token {
-	return concat([
-		"export",
-		space,
-		"default",
-		space,
-		printExportDeclaration(builder, node),
-	]);
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+import { printExportDeclaration } from "./JSExportLocalDeclaration";
+export default function JSExportDefaultDeclaration(builder: Builder, node: JSExportDefaultDeclaration): Token {
+    return concat([
+        "export",
+        space,
+        "default",
+        space,
+        printExportDeclaration(builder, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/modules/JSExportDefaultSpecifier.ts b/internal/formatter/builders/js/modules/JSExportDefaultSpecifier.ts
index 44362da27..12963cd0d 100644
--- a/internal/formatter/builders/js/modules/JSExportDefaultSpecifier.ts
+++ b/internal/formatter/builders/js/modules/JSExportDefaultSpecifier.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSExportDefaultSpecifier} from "@internal/ast";
-
-export default function JSExportDefaultSpecifier(
-	builder: Builder,
-	node: JSExportDefaultSpecifier,
-): Token {
-	return builder.tokenize(node.exported, node);
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSExportDefaultSpecifier(builder: Builder, node: JSExportDefaultSpecifier): Token {
+    return builder.tokenize(node.exported, node);
 }
diff --git a/internal/formatter/builders/js/modules/JSExportExternalDeclaration.ts b/internal/formatter/builders/js/modules/JSExportExternalDeclaration.ts
index e5699b608..15a574f80 100644
--- a/internal/formatter/builders/js/modules/JSExportExternalDeclaration.ts
+++ b/internal/formatter/builders/js/modules/JSExportExternalDeclaration.ts
@@ -4,34 +4,17 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {JSExportExternalDeclaration} from "@internal/ast";
-import {Builder, Token, concat, group, space} from "@internal/formatter";
-
-import {printModuleSpecifiers} from "./JSImportDeclaration";
-
-export default function JSExportExternalDeclaration(
-	builder: Builder,
-	node: JSExportExternalDeclaration,
-): Token {
-	const tokens: Array<Token> = ["export", space];
-
-	if (node.exportKind === "type") {
-		if (!builder.options.typeAnnotations) {
-			return "";
-		}
-
-		tokens.push("type", space);
-	}
-
-	tokens.push(
-		printModuleSpecifiers(builder, node),
-		space,
-		"from",
-		space,
-		builder.tokenize(node.source, node),
-		";",
-	);
-
-	return group(concat(tokens));
+import {} from "@internal/ast";
+import { Builder, Token, concat, group, space } from "@internal/formatter";
+import { printModuleSpecifiers } from "./JSImportDeclaration";
+export default function JSExportExternalDeclaration(builder: Builder, node: JSExportExternalDeclaration): Token {
+    const tokens: Array<Token> = ["export", space];
+    if (node.exportKind === "type") {
+        if (!builder.options.typeAnnotations) {
+            return "";
+        }
+        tokens.push("type", space);
+    }
+    tokens.push(printModuleSpecifiers(builder, node), space, "from", space, builder.tokenize(node.source, node), ";");
+    return group(concat(tokens));
 }
diff --git a/internal/formatter/builders/js/modules/JSExportExternalSpecifier.ts b/internal/formatter/builders/js/modules/JSExportExternalSpecifier.ts
index 0b2181e3a..319ff135f 100644
--- a/internal/formatter/builders/js/modules/JSExportExternalSpecifier.ts
+++ b/internal/formatter/builders/js/modules/JSExportExternalSpecifier.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSExportExternalSpecifier} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
 import JSExportLocalSpecifier from "./JSExportLocalSpecifier";
-
-export default function JSExportExternalSpecifier(
-	builder: Builder,
-	node: JSExportExternalSpecifier,
-): Token {
-	return JSExportLocalSpecifier(builder, node);
+export default function JSExportExternalSpecifier(builder: Builder, node: JSExportExternalSpecifier): Token {
+    return JSExportLocalSpecifier(builder, node);
 }
diff --git a/internal/formatter/builders/js/modules/JSExportLocalDeclaration.ts b/internal/formatter/builders/js/modules/JSExportLocalDeclaration.ts
index 1d777f87d..f5c599e28 100644
--- a/internal/formatter/builders/js/modules/JSExportLocalDeclaration.ts
+++ b/internal/formatter/builders/js/modules/JSExportLocalDeclaration.ts
@@ -4,90 +4,55 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	JSExportDefaultDeclaration,
-	JSExportLocalDeclaration,
-} from "@internal/ast";
-import {isDeclaration} from "@internal/js-ast-utils";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	hardline,
-	ifBreak,
-	indent,
-	softline,
-	space,
-} from "@internal/formatter";
-
-import {hasInnerComments} from "../../comments";
-import {printCommaList} from "../utils";
-
-export default function JSExportLocalDeclaration(
-	builder: Builder,
-	node: JSExportLocalDeclaration,
-): Token {
-	if (node.exportKind === "type" && !builder.options.typeAnnotations) {
-		return "";
-	}
-
-	return concat(["export", space, printExportDeclaration(builder, node)]);
+import { JSExportDefaultDeclaration, } from "@internal/ast";
+import { isDeclaration } from "@internal/js-ast-utils";
+import { Builder, Token, concat, group, hardline, ifBreak, indent, softline, space, } from "@internal/formatter";
+import { hasInnerComments } from "../../comments";
+import { printCommaList } from "../utils";
+export default function JSExportLocalDeclaration(builder: Builder, node: JSExportLocalDeclaration): Token {
+    if (node.exportKind === "type" && !builder.options.typeAnnotations) {
+        return "";
+    }
+    return concat(["export", space, printExportDeclaration(builder, node)]);
 }
-
-export function printExportDeclaration(
-	builder: Builder,
-	node: JSExportDefaultDeclaration | JSExportLocalDeclaration,
-): Token {
-	if (node.declaration) {
-		const tokens = [builder.tokenize(node.declaration, node)];
-		if (!isDeclaration(node.declaration)) {
-			tokens.push(";");
-		}
-		return concat(tokens);
-	} else {
-		if (node.type !== "JSExportLocalDeclaration") {
-			throw new Error("Expected JSExportLocalDeclaration");
-		}
-
-		const {specifiers} = node;
-		if (specifiers === undefined) {
-			throw new Error("Expected specifiers since there was no declaration");
-		}
-
-		const tokens: Array<Token> = [];
-
-		if (node.exportKind === "type") {
-			tokens.push("type", space);
-		}
-
-		if (specifiers.length === 0) {
-			if (hasInnerComments(node)) {
-				tokens.push(
-					concat(["{", builder.tokenizeInnerComments(node, true), hardline, "}"]),
-				);
-			} else {
-				tokens.push("{}");
-			}
-		} else {
-			tokens.push(
-				group(
-					concat([
-						"{",
-						indent(
-							concat([softline, printCommaList(builder, specifiers, node)]),
-						),
-						ifBreak(","),
-						softline,
-						"}",
-					]),
-				),
-			);
-		}
-
-		tokens.push(";");
-
-		return concat(tokens);
-	}
+export function printExportDeclaration(builder: Builder, node: JSExportDefaultDeclaration | JSExportLocalDeclaration): Token {
+    if (node.declaration) {
+        const tokens = [builder.tokenize(node.declaration, node)];
+        if (!isDeclaration(node.declaration)) {
+            tokens.push(";");
+        }
+        return concat(tokens);
+    }
+    else {
+        if (node.type !== "JSExportLocalDeclaration") {
+            throw new Error("Expected JSExportLocalDeclaration");
+        }
+        const { specifiers } = node;
+        if (specifiers === undefined) {
+            throw new Error("Expected specifiers since there was no declaration");
+        }
+        const tokens: Array<Token> = [];
+        if (node.exportKind === "type") {
+            tokens.push("type", space);
+        }
+        if (specifiers.length === 0) {
+            if (hasInnerComments(node)) {
+                tokens.push(concat(["{", builder.tokenizeInnerComments(node, true), hardline, "}"]));
+            }
+            else {
+                tokens.push("{}");
+            }
+        }
+        else {
+            tokens.push(group(concat([
+                "{",
+                indent(concat([softline, printCommaList(builder, specifiers, node)])),
+                ifBreak(","),
+                softline,
+                "}",
+            ])));
+        }
+        tokens.push(";");
+        return concat(tokens);
+    }
 }
diff --git a/internal/formatter/builders/js/modules/JSExportLocalSpecifier.ts b/internal/formatter/builders/js/modules/JSExportLocalSpecifier.ts
index e3d16b466..a368e10ce 100644
--- a/internal/formatter/builders/js/modules/JSExportLocalSpecifier.ts
+++ b/internal/formatter/builders/js/modules/JSExportLocalSpecifier.ts
@@ -4,26 +4,20 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {JSExportExternalSpecifier, JSExportLocalSpecifier} from "@internal/ast";
-
-export default function JSExportLocalSpecifier(
-	builder: Builder,
-	node: JSExportExternalSpecifier | JSExportLocalSpecifier,
-): Token {
-	const tokens = [builder.tokenize(node.local, node)];
-
-	if (node.local.name === node.exported.name) {
-		return concat(tokens);
-	} else {
-		return concat([
-			concat(tokens),
-			space,
-			"as",
-			space,
-			builder.tokenize(node.exported, node),
-		]);
-	}
+import { Builder, Token, concat, space } from "@internal/formatter";
+import { JSExportExternalSpecifier } from "@internal/ast";
+export default function JSExportLocalSpecifier(builder: Builder, node: JSExportExternalSpecifier | JSExportLocalSpecifier): Token {
+    const tokens = [builder.tokenize(node.local, node)];
+    if (node.local.name === node.exported.name) {
+        return concat(tokens);
+    }
+    else {
+        return concat([
+            concat(tokens),
+            space,
+            "as",
+            space,
+            builder.tokenize(node.exported, node),
+        ]);
+    }
 }
diff --git a/internal/formatter/builders/js/modules/JSExportNamespaceSpecifier.ts b/internal/formatter/builders/js/modules/JSExportNamespaceSpecifier.ts
index e51efd8bb..45b3c98ef 100644
--- a/internal/formatter/builders/js/modules/JSExportNamespaceSpecifier.ts
+++ b/internal/formatter/builders/js/modules/JSExportNamespaceSpecifier.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {JSExportNamespaceSpecifier} from "@internal/ast";
-
-export default function JSExportNamespaceSpecifier(
-	builder: Builder,
-	node: JSExportNamespaceSpecifier,
-): Token {
-	return concat(["*", space, "as", space, builder.tokenize(node.exported, node)]);
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSExportNamespaceSpecifier(builder: Builder, node: JSExportNamespaceSpecifier): Token {
+    return concat(["*", space, "as", space, builder.tokenize(node.exported, node)]);
 }
diff --git a/internal/formatter/builders/js/modules/JSImportCall.ts b/internal/formatter/builders/js/modules/JSImportCall.ts
index 0d5e9f11a..b3583bdb3 100644
--- a/internal/formatter/builders/js/modules/JSImportCall.ts
+++ b/internal/formatter/builders/js/modules/JSImportCall.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSImportCall} from "@internal/ast";
-
-export default function JSImportCall(
-	builder: Builder,
-	node: JSImportCall,
-): Token {
-	return concat(["import(", builder.tokenize(node.argument, node), ")"]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSImportCall(builder: Builder, node: JSImportCall): Token {
+    return concat(["import(", builder.tokenize(node.argument, node), ")"]);
 }
diff --git a/internal/formatter/builders/js/modules/JSImportDeclaration.ts b/internal/formatter/builders/js/modules/JSImportDeclaration.ts
index 822588df7..ce77c4aef 100644
--- a/internal/formatter/builders/js/modules/JSImportDeclaration.ts
+++ b/internal/formatter/builders/js/modules/JSImportDeclaration.ts
@@ -4,88 +4,51 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {JSExportExternalDeclaration, JSImportDeclaration} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	ifBreak,
-	indent,
-	join,
-	lineOrSpace,
-	softline,
-	space,
-} from "@internal/formatter";
-
-export default function JSImportDeclaration(
-	builder: Builder,
-	node: JSImportDeclaration,
-): Token {
-	const tokens: Array<Token> = ["import", space];
-
-	if (node.importKind === "type" || node.importKind === "typeof") {
-		tokens.push(node.importKind);
-		tokens.push(space);
-	}
-
-	const {namedSpecifiers, defaultSpecifier, namespaceSpecifier} = node;
-
-	if (
-		namedSpecifiers.length > 0 ||
-		namespaceSpecifier !== undefined ||
-		defaultSpecifier !== undefined
-	) {
-		tokens.push(printModuleSpecifiers(builder, node), space, "from", space);
-	}
-
-	tokens.push(builder.tokenize(node.source, node), ";");
-
-	return group(concat(tokens));
+import { JSExportExternalDeclaration } from "@internal/ast";
+import { Builder, Token, concat, group, ifBreak, indent, join, lineOrSpace, softline, space, } from "@internal/formatter";
+export default function JSImportDeclaration(builder: Builder, node: JSImportDeclaration): Token {
+    const tokens: Array<Token> = ["import", space];
+    if (node.importKind === "type" || node.importKind === "typeof") {
+        tokens.push(node.importKind);
+        tokens.push(space);
+    }
+    const { namedSpecifiers, defaultSpecifier, namespaceSpecifier } = node;
+    if (namedSpecifiers.length > 0 ||
+        namespaceSpecifier !== undefined ||
+        defaultSpecifier !== undefined) {
+        tokens.push(printModuleSpecifiers(builder, node), space, "from", space);
+    }
+    tokens.push(builder.tokenize(node.source, node), ";");
+    return group(concat(tokens));
 }
-
-export function printModuleSpecifiers(
-	builder: Builder,
-	node: JSImportDeclaration | JSExportExternalDeclaration,
-): Token {
-	const {namedSpecifiers, defaultSpecifier, namespaceSpecifier} = node;
-
-	const groups: Array<Token> = [];
-
-	if (defaultSpecifier !== undefined) {
-		groups.push(builder.tokenize(node.defaultSpecifier, node));
-	}
-
-	if (namespaceSpecifier !== undefined) {
-		groups.push(builder.tokenize(node.namespaceSpecifier, node));
-	}
-
-	if (namedSpecifiers.length > 0) {
-		const specifiers: Array<Token> = [];
-
-		for (const specifier of namedSpecifiers) {
-			specifiers.push(builder.tokenize(specifier, node));
-		}
-
-		if (specifiers.length === 1) {
-			// Do not create insert softline tokens when there is a single specifier
-			// in order to keep the braces on the same line.
-			groups.push(concat(["{", specifiers[0], "}"]));
-		} else {
-			groups.push(
-				concat([
-					"{",
-					indent(
-						concat([softline, join(concat([",", lineOrSpace]), specifiers)]),
-					),
-					ifBreak(","),
-					softline,
-					"}",
-				]),
-			);
-		}
-	}
-
-	return join(concat([",", space]), groups);
+export function printModuleSpecifiers(builder: Builder, node: JSImportDeclaration | JSExportExternalDeclaration): Token {
+    const { namedSpecifiers, defaultSpecifier, namespaceSpecifier } = node;
+    const groups: Array<Token> = [];
+    if (defaultSpecifier !== undefined) {
+        groups.push(builder.tokenize(node.defaultSpecifier, node));
+    }
+    if (namespaceSpecifier !== undefined) {
+        groups.push(builder.tokenize(node.namespaceSpecifier, node));
+    }
+    if (namedSpecifiers.length > 0) {
+        const specifiers: Array<Token> = [];
+        for (const specifier of namedSpecifiers) {
+            specifiers.push(builder.tokenize(specifier, node));
+        }
+        if (specifiers.length === 1) {
+            // Do not create insert softline tokens when there is a single specifier
+            // in order to keep the braces on the same line.
+            groups.push(concat(["{", specifiers[0], "}"]));
+        }
+        else {
+            groups.push(concat([
+                "{",
+                indent(concat([softline, join(concat([",", lineOrSpace]), specifiers)])),
+                ifBreak(","),
+                softline,
+                "}",
+            ]));
+        }
+    }
+    return join(concat([",", space]), groups);
 }
diff --git a/internal/formatter/builders/js/modules/JSImportDefaultSpecifier.ts b/internal/formatter/builders/js/modules/JSImportDefaultSpecifier.ts
index 44e65b105..5879805a5 100644
--- a/internal/formatter/builders/js/modules/JSImportDefaultSpecifier.ts
+++ b/internal/formatter/builders/js/modules/JSImportDefaultSpecifier.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSImportDefaultSpecifier} from "@internal/ast";
-
-export default function JSImportDefaultSpecifier(
-	builder: Builder,
-	node: JSImportDefaultSpecifier,
-): Token {
-	return builder.tokenize(node.local.name, node);
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSImportDefaultSpecifier(builder: Builder, node: JSImportDefaultSpecifier): Token {
+    return builder.tokenize(node.local.name, node);
 }
diff --git a/internal/formatter/builders/js/modules/JSImportNamespaceSpecifier.ts b/internal/formatter/builders/js/modules/JSImportNamespaceSpecifier.ts
index d1c2787e6..5e49bd30b 100644
--- a/internal/formatter/builders/js/modules/JSImportNamespaceSpecifier.ts
+++ b/internal/formatter/builders/js/modules/JSImportNamespaceSpecifier.ts
@@ -4,20 +4,14 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {JSImportNamespaceSpecifier} from "@internal/ast";
-
-export default function JSImportNamespaceSpecifier(
-	builder: Builder,
-	node: JSImportNamespaceSpecifier,
-): Token {
-	return concat([
-		"*",
-		space,
-		"as",
-		space,
-		builder.tokenize(node.local.name, node),
-	]);
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSImportNamespaceSpecifier(builder: Builder, node: JSImportNamespaceSpecifier): Token {
+    return concat([
+        "*",
+        space,
+        "as",
+        space,
+        builder.tokenize(node.local.name, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/modules/JSImportSpecifier.ts b/internal/formatter/builders/js/modules/JSImportSpecifier.ts
index 35a67b093..098b3eaa9 100644
--- a/internal/formatter/builders/js/modules/JSImportSpecifier.ts
+++ b/internal/formatter/builders/js/modules/JSImportSpecifier.ts
@@ -4,22 +4,13 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {JSImportSpecifier} from "@internal/ast";
-
-export default function JSImportSpecifier(
-	builder: Builder,
-	node: JSImportSpecifier,
-): Token {
-	const tokens: Array<Token> = [];
-
-	tokens.push(builder.tokenize(node.imported, node));
-
-	if (node.local.name.name !== node.imported.name) {
-		tokens.push(space, "as", space, builder.tokenize(node.local.name, node));
-	}
-
-	return concat(tokens);
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSImportSpecifier(builder: Builder, node: JSImportSpecifier): Token {
+    const tokens: Array<Token> = [];
+    tokens.push(builder.tokenize(node.imported, node));
+    if (node.local.name.name !== node.imported.name) {
+        tokens.push(space, "as", space, builder.tokenize(node.local.name, node));
+    }
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/modules/JSImportSpecifierLocal.ts b/internal/formatter/builders/js/modules/JSImportSpecifierLocal.ts
index 665212f8e..2e1b2a041 100644
--- a/internal/formatter/builders/js/modules/JSImportSpecifierLocal.ts
+++ b/internal/formatter/builders/js/modules/JSImportSpecifierLocal.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSImportSpecifierLocal} from "@internal/ast";
-
-export default function JSImportSpecifierLocal(
-	builder: Builder,
-	node: JSImportSpecifierLocal,
-): Token {
-	throw new Error("unimplemented");
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSImportSpecifierLocal(builder: Builder, node: JSImportSpecifierLocal): Token {
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/js/objects/JSComputedPropertyKey.ts b/internal/formatter/builders/js/objects/JSComputedPropertyKey.ts
index 0d536e7c1..9f05c5f54 100644
--- a/internal/formatter/builders/js/objects/JSComputedPropertyKey.ts
+++ b/internal/formatter/builders/js/objects/JSComputedPropertyKey.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSComputedPropertyKey} from "@internal/ast";
-
-export default function JSComputedPropertyKey(
-	builder: Builder,
-	node: JSComputedPropertyKey,
-): Token {
-	return concat(["[", builder.tokenize(node.value, node), "]"]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSComputedPropertyKey(builder: Builder, node: JSComputedPropertyKey): Token {
+    return concat(["[", builder.tokenize(node.value, node), "]"]);
 }
diff --git a/internal/formatter/builders/js/objects/JSObjectExpression.ts b/internal/formatter/builders/js/objects/JSObjectExpression.ts
index 7f6e7cda4..6ebf37165 100644
--- a/internal/formatter/builders/js/objects/JSObjectExpression.ts
+++ b/internal/formatter/builders/js/objects/JSObjectExpression.ts
@@ -4,81 +4,44 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSAssignmentObjectPattern,
-	JSBindingObjectPattern,
-	JSObjectExpression,
-} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	ifBreak,
-	indent,
-	join,
-	lineOrSpace,
-	softline,
-} from "@internal/formatter";
-import {hasInnerComments} from "../../comments";
-
-export default function JSObjectExpression(
-	builder: Builder,
-	node: JSObjectExpression | JSAssignmentObjectPattern | JSBindingObjectPattern,
-): Token {
-	if (hasInnerComments(node)) {
-		return group(
-			concat(["{", builder.tokenizeInnerComments(node, true), softline, "}"]),
-		);
-	}
-
-	const tokens: Array<Token> = [];
-	const props: Array<AnyNode> = node.properties;
-
-	tokens.push(
-		join(
-			concat([",", lineOrSpace]),
-			props.map((prop, index) => {
-				const printed = builder.tokenize(prop, node);
-				if (index > 0 && builder.getLinesBetween(props[index - 1], prop) > 1) {
-					return concat([softline, printed]);
-				} else {
-					return printed;
-				}
-			}),
-		),
-	);
-
-	if (
-		(node.type === "JSBindingObjectPattern" ||
-		node.type === "JSAssignmentObjectPattern") &&
-		node.rest !== undefined
-	) {
-		if (props.length > 0) {
-			tokens.push(",", lineOrSpace);
-			if (builder.getLinesBetween(props[props.length - 1], node.rest) > 1) {
-				tokens.push(softline);
-			}
-		}
-
-		tokens.push("...", builder.tokenize(node.rest, node));
-	} else if (props.length > 0) {
-		// Add trailing comma
-		tokens.push(ifBreak(","));
-	}
-
-	// If the first property is not one the same line as the opening brace,
-	// the object is printed on multiple lines.
-	const shouldBreak =
-		node.loc !== undefined &&
-		props.length > 0 &&
-		props[0].loc !== undefined &&
-		props[0].loc.start.line !== node.loc.start.line;
-
-	return group(
-		concat(["{", indent(concat([softline, concat(tokens)])), softline, "}"]),
-		shouldBreak,
-	);
+import { AnyNode, JSAssignmentObjectPattern, JSBindingObjectPattern, } from "@internal/ast";
+import { Builder, Token, concat, group, ifBreak, indent, join, lineOrSpace, softline, } from "@internal/formatter";
+import { hasInnerComments } from "../../comments";
+export default function JSObjectExpression(builder: Builder, node: JSObjectExpression | JSAssignmentObjectPattern | JSBindingObjectPattern): Token {
+    if (hasInnerComments(node)) {
+        return group(concat(["{", builder.tokenizeInnerComments(node, true), softline, "}"]));
+    }
+    const tokens: Array<Token> = [];
+    const props: Array<AnyNode> = node.properties;
+    tokens.push(join(concat([",", lineOrSpace]), props.map((prop, index) => {
+        const printed = builder.tokenize(prop, node);
+        if (index > 0 && builder.getLinesBetween(props[index - 1], prop) > 1) {
+            return concat([softline, printed]);
+        }
+        else {
+            return printed;
+        }
+    })));
+    if ((node.type === "JSBindingObjectPattern" ||
+        node.type === "JSAssignmentObjectPattern") &&
+        node.rest !== undefined) {
+        if (props.length > 0) {
+            tokens.push(",", lineOrSpace);
+            if (builder.getLinesBetween(props[props.length - 1], node.rest) > 1) {
+                tokens.push(softline);
+            }
+        }
+        tokens.push("...", builder.tokenize(node.rest, node));
+    }
+    else if (props.length > 0) {
+        // Add trailing comma
+        tokens.push(ifBreak(","));
+    }
+    // If the first property is not one the same line as the opening brace,
+    // the object is printed on multiple lines.
+    const shouldBreak = node.loc !== undefined &&
+        props.length > 0 &&
+        props[0].loc !== undefined &&
+        props[0].loc.start.line !== node.loc.start.line;
+    return group(concat(["{", indent(concat([softline, concat(tokens)])), softline, "}"]), shouldBreak);
 }
diff --git a/internal/formatter/builders/js/objects/JSObjectMethod.ts b/internal/formatter/builders/js/objects/JSObjectMethod.ts
index 846cfc68a..c9bd1424f 100644
--- a/internal/formatter/builders/js/objects/JSObjectMethod.ts
+++ b/internal/formatter/builders/js/objects/JSObjectMethod.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {printMethod} from "../utils";
-import {JSObjectMethod} from "@internal/ast";
-
-export default function JSObjectMethod(
-	builder: Builder,
-	node: JSObjectMethod,
-): Token {
-	return printMethod(builder, node);
+import { Builder, Token } from "@internal/formatter";
+import { printMethod } from "../utils";
+import {} from "@internal/ast";
+export default function JSObjectMethod(builder: Builder, node: JSObjectMethod): Token {
+    return printMethod(builder, node);
 }
diff --git a/internal/formatter/builders/js/objects/JSObjectProperty.ts b/internal/formatter/builders/js/objects/JSObjectProperty.ts
index a03da8ff9..f63a4d1d0 100644
--- a/internal/formatter/builders/js/objects/JSObjectProperty.ts
+++ b/internal/formatter/builders/js/objects/JSObjectProperty.ts
@@ -4,57 +4,38 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {
-	AnyJSObjectPropertyKey,
-	AnyNode,
-	JSAssignmentObjectPatternProperty,
-	JSBindingObjectPatternProperty,
-	JSObjectProperty,
-} from "@internal/ast";
-
+import { Builder, Token, concat, space } from "@internal/formatter";
+import { AnyJSObjectPropertyKey, AnyNode, JSAssignmentObjectPatternProperty, JSBindingObjectPatternProperty, } from "@internal/ast";
 function isShorthand(key: AnyJSObjectPropertyKey, value: AnyNode): boolean {
-	return (
-		key.type === "JSStaticPropertyKey" &&
-		key.value.type === "JSIdentifier" &&
-		(value.type === "JSReferenceIdentifier" ||
-		value.type === "JSBindingIdentifier" ||
-		value.type === "JSAssignmentIdentifier") &&
-		value.name === key.value.name
-	);
+    return (key.type === "JSStaticPropertyKey" &&
+        key.value.type === "JSIdentifier" &&
+        (value.type === "JSReferenceIdentifier" ||
+            value.type === "JSBindingIdentifier" ||
+            value.type === "JSAssignmentIdentifier") &&
+        value.name === key.value.name);
 }
-
-export default function JSObjectProperty(
-	builder: Builder,
-	node:
-		| JSObjectProperty
-		| JSAssignmentObjectPatternProperty
-		| JSBindingObjectPatternProperty,
-): Token {
-	const tokens = [builder.tokenize(node.key, node)];
-
-	if (
-		(node.value.type === "JSBindingAssignmentPattern" ||
-		node.value.type === "JSAssignmentAssignmentPattern") &&
-		isShorthand(node.key, node.value.left)
-	) {
-		return concat([
-			concat(tokens),
-			space,
-			"=",
-			space,
-			builder.tokenize(node.value.right, node.value),
-		]);
-	} else if (isShorthand(node.key, node.value)) {
-		return concat(tokens);
-	} else {
-		return concat([
-			concat(tokens),
-			":",
-			space,
-			builder.tokenize(node.value, node),
-		]);
-	}
+export default function JSObjectProperty(builder: Builder, node: JSObjectProperty | JSAssignmentObjectPatternProperty | JSBindingObjectPatternProperty): Token {
+    const tokens = [builder.tokenize(node.key, node)];
+    if ((node.value.type === "JSBindingAssignmentPattern" ||
+        node.value.type === "JSAssignmentAssignmentPattern") &&
+        isShorthand(node.key, node.value.left)) {
+        return concat([
+            concat(tokens),
+            space,
+            "=",
+            space,
+            builder.tokenize(node.value.right, node.value),
+        ]);
+    }
+    else if (isShorthand(node.key, node.value)) {
+        return concat(tokens);
+    }
+    else {
+        return concat([
+            concat(tokens),
+            ":",
+            space,
+            builder.tokenize(node.value, node),
+        ]);
+    }
 }
diff --git a/internal/formatter/builders/js/objects/JSSpreadProperty.ts b/internal/formatter/builders/js/objects/JSSpreadProperty.ts
index 8ecd74f18..a8ed6662f 100644
--- a/internal/formatter/builders/js/objects/JSSpreadProperty.ts
+++ b/internal/formatter/builders/js/objects/JSSpreadProperty.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSSpreadProperty} from "@internal/ast";
-
-export default function JSSpreadProperty(
-	builder: Builder,
-	node: JSSpreadProperty,
-): Token {
-	return concat(["...", builder.tokenize(node.argument, node)]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSSpreadProperty(builder: Builder, node: JSSpreadProperty): Token {
+    return concat(["...", builder.tokenize(node.argument, node)]);
 }
diff --git a/internal/formatter/builders/js/objects/JSStaticPropertyKey.ts b/internal/formatter/builders/js/objects/JSStaticPropertyKey.ts
index 785fb3b06..1569bcf12 100644
--- a/internal/formatter/builders/js/objects/JSStaticPropertyKey.ts
+++ b/internal/formatter/builders/js/objects/JSStaticPropertyKey.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSStaticPropertyKey} from "@internal/ast";
-
-export default function JSStaticPropertyKey(
-	builder: Builder,
-	node: JSStaticPropertyKey,
-): Token {
-	return builder.tokenize(node.value, node);
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSStaticPropertyKey(builder: Builder, node: JSStaticPropertyKey): Token {
+    return builder.tokenize(node.value, node);
 }
diff --git a/internal/formatter/builders/js/patterns/JSAssignmentArrayPattern.ts b/internal/formatter/builders/js/patterns/JSAssignmentArrayPattern.ts
index 727644a2e..6937e65f6 100644
--- a/internal/formatter/builders/js/patterns/JSAssignmentArrayPattern.ts
+++ b/internal/formatter/builders/js/patterns/JSAssignmentArrayPattern.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSAssignmentArrayPattern} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
 import JSArrayExpression from "../expressions/JSArrayExpression";
-
-export default function JSAssignmentArrayPattern(
-	builder: Builder,
-	node: JSAssignmentArrayPattern,
-): Token {
-	return JSArrayExpression(builder, node);
+export default function JSAssignmentArrayPattern(builder: Builder, node: JSAssignmentArrayPattern): Token {
+    return JSArrayExpression(builder, node);
 }
diff --git a/internal/formatter/builders/js/patterns/JSAssignmentAssignmentPattern.ts b/internal/formatter/builders/js/patterns/JSAssignmentAssignmentPattern.ts
index f4b9093b0..1ed930535 100644
--- a/internal/formatter/builders/js/patterns/JSAssignmentAssignmentPattern.ts
+++ b/internal/formatter/builders/js/patterns/JSAssignmentAssignmentPattern.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {JSAssignmentAssignmentPattern} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
 import JSBindingAssignmentPattern from "./JSBindingAssignmentPattern";
-
-export default function JSAssignmentAssignmentPattern(
-	builder: Builder,
-	node: JSAssignmentAssignmentPattern,
-): Token {
-	return JSBindingAssignmentPattern(builder, node);
+export default function JSAssignmentAssignmentPattern(builder: Builder, node: JSAssignmentAssignmentPattern): Token {
+    return JSBindingAssignmentPattern(builder, node);
 }
diff --git a/internal/formatter/builders/js/patterns/JSAssignmentIdentifier.ts b/internal/formatter/builders/js/patterns/JSAssignmentIdentifier.ts
index e949f8253..cdcb557e9 100644
--- a/internal/formatter/builders/js/patterns/JSAssignmentIdentifier.ts
+++ b/internal/formatter/builders/js/patterns/JSAssignmentIdentifier.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSAssignmentIdentifier} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
 import JSIdentifier from "../auxiliary/JSIdentifier";
-
-export default function JSAssignmentIdentifier(
-	builder: Builder,
-	node: JSAssignmentIdentifier,
-): Token {
-	return JSIdentifier(builder, node);
+export default function JSAssignmentIdentifier(builder: Builder, node: JSAssignmentIdentifier): Token {
+    return JSIdentifier(builder, node);
 }
diff --git a/internal/formatter/builders/js/patterns/JSAssignmentObjectPattern.ts b/internal/formatter/builders/js/patterns/JSAssignmentObjectPattern.ts
index fdcbc6c56..5b49ea716 100644
--- a/internal/formatter/builders/js/patterns/JSAssignmentObjectPattern.ts
+++ b/internal/formatter/builders/js/patterns/JSAssignmentObjectPattern.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSAssignmentObjectPattern} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
 import JSObjectExpression from "../objects/JSObjectExpression";
-
-export default function JSAssignmentObjectPattern(
-	builder: Builder,
-	node: JSAssignmentObjectPattern,
-): Token {
-	return JSObjectExpression(builder, node);
+export default function JSAssignmentObjectPattern(builder: Builder, node: JSAssignmentObjectPattern): Token {
+    return JSObjectExpression(builder, node);
 }
diff --git a/internal/formatter/builders/js/patterns/JSAssignmentObjectPatternProperty.ts b/internal/formatter/builders/js/patterns/JSAssignmentObjectPatternProperty.ts
index 6911ac819..9f8f2250e 100644
--- a/internal/formatter/builders/js/patterns/JSAssignmentObjectPatternProperty.ts
+++ b/internal/formatter/builders/js/patterns/JSAssignmentObjectPatternProperty.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSAssignmentObjectPatternProperty} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
 import JSObjectProperty from "../objects/JSObjectProperty";
-
-export default function JSAssignmentObjectPatternProperty(
-	builder: Builder,
-	node: JSAssignmentObjectPatternProperty,
-): Token {
-	return JSObjectProperty(builder, node);
+export default function JSAssignmentObjectPatternProperty(builder: Builder, node: JSAssignmentObjectPatternProperty): Token {
+    return JSObjectProperty(builder, node);
 }
diff --git a/internal/formatter/builders/js/patterns/JSBindingArrayPattern.ts b/internal/formatter/builders/js/patterns/JSBindingArrayPattern.ts
index 53c0b9cbe..0a2f60496 100644
--- a/internal/formatter/builders/js/patterns/JSBindingArrayPattern.ts
+++ b/internal/formatter/builders/js/patterns/JSBindingArrayPattern.ts
@@ -4,19 +4,13 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSBindingArrayPattern} from "@internal/ast";
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
 import JSArrayExpression from "../expressions/JSArrayExpression";
-import {printPatternMeta} from "../utils";
-
-export default function JSBindingArrayPattern(
-	builder: Builder,
-	node: JSBindingArrayPattern,
-): Token {
-	return concat([
-		JSArrayExpression(builder, node),
-		printPatternMeta(builder, node, node.meta),
-	]);
+import { printPatternMeta } from "../utils";
+export default function JSBindingArrayPattern(builder: Builder, node: JSBindingArrayPattern): Token {
+    return concat([
+        JSArrayExpression(builder, node),
+        printPatternMeta(builder, node, node.meta),
+    ]);
 }
diff --git a/internal/formatter/builders/js/patterns/JSBindingAssignmentPattern.ts b/internal/formatter/builders/js/patterns/JSBindingAssignmentPattern.ts
index 718d74cdc..2196ed039 100644
--- a/internal/formatter/builders/js/patterns/JSBindingAssignmentPattern.ts
+++ b/internal/formatter/builders/js/patterns/JSBindingAssignmentPattern.ts
@@ -4,22 +4,14 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	JSAssignmentAssignmentPattern,
-	JSBindingAssignmentPattern,
-} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-export default function JSBindingAssignmentPattern(
-	builder: Builder,
-	node: JSAssignmentAssignmentPattern | JSBindingAssignmentPattern,
-): Token {
-	return concat([
-		builder.tokenize(node.left, node),
-		space,
-		"=",
-		space,
-		builder.tokenize(node.right, node),
-	]);
+import { JSAssignmentAssignmentPattern, } from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+export default function JSBindingAssignmentPattern(builder: Builder, node: JSAssignmentAssignmentPattern | JSBindingAssignmentPattern): Token {
+    return concat([
+        builder.tokenize(node.left, node),
+        space,
+        "=",
+        space,
+        builder.tokenize(node.right, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/patterns/JSBindingIdentifier.ts b/internal/formatter/builders/js/patterns/JSBindingIdentifier.ts
index 53134b44e..0e81bfe49 100644
--- a/internal/formatter/builders/js/patterns/JSBindingIdentifier.ts
+++ b/internal/formatter/builders/js/patterns/JSBindingIdentifier.ts
@@ -4,24 +4,17 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSBindingIdentifier} from "@internal/ast";
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
 import JSIdentifier from "../auxiliary/JSIdentifier";
-import {printPatternMeta} from "../utils";
-
-export default function JSBindingIdentifier(
-	builder: Builder,
-	node: JSBindingIdentifier,
-): Token {
-	if (node.name[0] === "*") {
-		// Internal name
-		return "";
-	}
-
-	return concat([
-		JSIdentifier(builder, node),
-		printPatternMeta(builder, node, node.meta),
-	]);
+import { printPatternMeta } from "../utils";
+export default function JSBindingIdentifier(builder: Builder, node: JSBindingIdentifier): Token {
+    if (node.name[0] === "*") {
+        // Internal name
+        return "";
+    }
+    return concat([
+        JSIdentifier(builder, node),
+        printPatternMeta(builder, node, node.meta),
+    ]);
 }
diff --git a/internal/formatter/builders/js/patterns/JSBindingObjectPattern.ts b/internal/formatter/builders/js/patterns/JSBindingObjectPattern.ts
index 988fe46ef..16f799c71 100644
--- a/internal/formatter/builders/js/patterns/JSBindingObjectPattern.ts
+++ b/internal/formatter/builders/js/patterns/JSBindingObjectPattern.ts
@@ -4,19 +4,13 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSBindingObjectPattern} from "@internal/ast";
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
 import JSObjectExpression from "../objects/JSObjectExpression";
-import {printPatternMeta} from "../utils";
-
-export default function JSBindingObjectPattern(
-	builder: Builder,
-	node: JSBindingObjectPattern,
-): Token {
-	return concat([
-		JSObjectExpression(builder, node),
-		printPatternMeta(builder, node, node.meta),
-	]);
+import { printPatternMeta } from "../utils";
+export default function JSBindingObjectPattern(builder: Builder, node: JSBindingObjectPattern): Token {
+    return concat([
+        JSObjectExpression(builder, node),
+        printPatternMeta(builder, node, node.meta),
+    ]);
 }
diff --git a/internal/formatter/builders/js/patterns/JSBindingObjectPatternProperty.ts b/internal/formatter/builders/js/patterns/JSBindingObjectPatternProperty.ts
index 9d97720c8..4c066370e 100644
--- a/internal/formatter/builders/js/patterns/JSBindingObjectPatternProperty.ts
+++ b/internal/formatter/builders/js/patterns/JSBindingObjectPatternProperty.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSBindingObjectPatternProperty} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
 import JSObjectProperty from "../objects/JSObjectProperty";
-
-export default function JSBindingObjectPatternProperty(
-	builder: Builder,
-	node: JSBindingObjectPatternProperty,
-): Token {
-	return JSObjectProperty(builder, node);
+export default function JSBindingObjectPatternProperty(builder: Builder, node: JSBindingObjectPatternProperty): Token {
+    return JSObjectProperty(builder, node);
 }
diff --git a/internal/formatter/builders/js/regex/JSRegExpAlternation.ts b/internal/formatter/builders/js/regex/JSRegExpAlternation.ts
index 0c3ac0a01..d43a94c4a 100644
--- a/internal/formatter/builders/js/regex/JSRegExpAlternation.ts
+++ b/internal/formatter/builders/js/regex/JSRegExpAlternation.ts
@@ -4,18 +4,12 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSRegExpAlternation} from "@internal/ast";
-
-export default function JSRegExpAlternation(
-	builder: Builder,
-	node: JSRegExpAlternation,
-): Token {
-	return concat([
-		builder.tokenize(node.left, node),
-		"|",
-		builder.tokenize(node.right, node),
-	]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSRegExpAlternation(builder: Builder, node: JSRegExpAlternation): Token {
+    return concat([
+        builder.tokenize(node.left, node),
+        "|",
+        builder.tokenize(node.right, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/regex/JSRegExpCharSet.ts b/internal/formatter/builders/js/regex/JSRegExpCharSet.ts
index 84464c5a1..065faf371 100644
--- a/internal/formatter/builders/js/regex/JSRegExpCharSet.ts
+++ b/internal/formatter/builders/js/regex/JSRegExpCharSet.ts
@@ -4,24 +4,16 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSRegExpCharSet} from "@internal/ast";
-
-export default function JSRegExpCharSet(
-	builder: Builder,
-	node: JSRegExpCharSet,
-): Token {
-	const tokens: Array<Token> = ["["];
-
-	if (node.invert) {
-		tokens.push("^");
-	}
-
-	return concat([
-		concat(tokens),
-		concat(node.body.map((item) => builder.tokenize(item, node))),
-		"]",
-	]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSRegExpCharSet(builder: Builder, node: JSRegExpCharSet): Token {
+    const tokens: Array<Token> = ["["];
+    if (node.invert) {
+        tokens.push("^");
+    }
+    return concat([
+        concat(tokens),
+        concat(node.body.map((item) => builder.tokenize(item, node))),
+        "]",
+    ]);
 }
diff --git a/internal/formatter/builders/js/regex/JSRegExpCharSetRange.ts b/internal/formatter/builders/js/regex/JSRegExpCharSetRange.ts
index b32a4402e..288e7338d 100644
--- a/internal/formatter/builders/js/regex/JSRegExpCharSetRange.ts
+++ b/internal/formatter/builders/js/regex/JSRegExpCharSetRange.ts
@@ -4,18 +4,12 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSRegExpCharSetRange} from "@internal/ast";
-
-export default function JSRegExpCharSetRange(
-	builder: Builder,
-	node: JSRegExpCharSetRange,
-): Token {
-	return concat([
-		builder.tokenize(node.start, node),
-		"-",
-		builder.tokenize(node.end, node),
-	]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSRegExpCharSetRange(builder: Builder, node: JSRegExpCharSetRange): Token {
+    return concat([
+        builder.tokenize(node.start, node),
+        "-",
+        builder.tokenize(node.end, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/regex/JSRegExpCharacter.ts b/internal/formatter/builders/js/regex/JSRegExpCharacter.ts
index 6b9bfa3f4..9d2d639a7 100644
--- a/internal/formatter/builders/js/regex/JSRegExpCharacter.ts
+++ b/internal/formatter/builders/js/regex/JSRegExpCharacter.ts
@@ -4,76 +4,60 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {AnyNode, JSRegExpCharacter} from "@internal/ast";
-import {escapeJSString} from "@internal/string-escape";
-
-export default function JSRegExpCharacter(
-	builder: Builder,
-	node: JSRegExpCharacter,
-	parent: AnyNode,
-): Token {
-	const isInCharSet = parent.type === "JSRegExpCharSet";
-	if (isInCharSet) {
-		switch (node.value) {
-			case "$":
-			case "^":
-			case ".":
-			case "?":
-			case "{":
-			case "}":
-			case "+":
-			case "*":
-			case "[":
-			case "(":
-			case ")":
-			case "|":
-				return node.value;
-
-			case "-":
-				return "\\-";
-		}
-	}
-
-	switch (node.value) {
-		case "\t":
-			return "\\t";
-
-		case "\n":
-			return "\\n";
-
-		case "\r":
-			return "\\r";
-
-		case "\x0b":
-			return "\\v";
-
-		case "\f":
-			return "\\f";
-
-		case "\b":
-			return "\\b";
-
-		case "/":
-		case "\\":
-		case "$":
-		case "^":
-		case ".":
-		case "?":
-		case "{":
-		case "}":
-		case "+":
-		case "*":
-		case "[":
-		case "]":
-		case "(":
-		case ")":
-		case "|":
-			return `\\${node.value}`;
-
-		default:
-			return escapeJSString(node.value, {json: true, unicodeOnly: true});
-	}
+import { Builder, Token } from "@internal/formatter";
+import { AnyNode } from "@internal/ast";
+import { escapeJSString } from "@internal/string-escape";
+export default function JSRegExpCharacter(builder: Builder, node: JSRegExpCharacter, parent: AnyNode): Token {
+    const isInCharSet = parent.type === "JSRegExpCharSet";
+    if (isInCharSet) {
+        switch (node.value) {
+            case "$":
+            case "^":
+            case ".":
+            case "?":
+            case "{":
+            case "}":
+            case "+":
+            case "*":
+            case "[":
+            case "(":
+            case ")":
+            case "|":
+                return node.value;
+            case "-":
+                return "\\-";
+        }
+    }
+    switch (node.value) {
+        case "\t":
+            return "\\t";
+        case "\n":
+            return "\\n";
+        case "\r":
+            return "\\r";
+        case "\x0b":
+            return "\\v";
+        case "\f":
+            return "\\f";
+        case "\b":
+            return "\\b";
+        case "/":
+        case "\\":
+        case "$":
+        case "^":
+        case ".":
+        case "?":
+        case "{":
+        case "}":
+        case "+":
+        case "*":
+        case "[":
+        case "]":
+        case "(":
+        case ")":
+        case "|":
+            return `\\${node.value}`;
+        default:
+            return escapeJSString(node.value, { json: true, unicodeOnly: true });
+    }
 }
diff --git a/internal/formatter/builders/js/regex/JSRegExpEndCharacter.ts b/internal/formatter/builders/js/regex/JSRegExpEndCharacter.ts
index 6a0e0ccb5..8033b1275 100644
--- a/internal/formatter/builders/js/regex/JSRegExpEndCharacter.ts
+++ b/internal/formatter/builders/js/regex/JSRegExpEndCharacter.ts
@@ -4,10 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Token} from "@internal/formatter";
-import {JSRegExpEndCharacter} from "@internal/ast";
-
+import { Token } from "@internal/formatter";
+import {} from "@internal/ast";
 export default function JSRegExpEndCharacter(): Token {
-	return "$";
+    return "$";
 }
diff --git a/internal/formatter/builders/js/regex/JSRegExpGroupCapture.ts b/internal/formatter/builders/js/regex/JSRegExpGroupCapture.ts
index 31c7b9c26..d809277be 100644
--- a/internal/formatter/builders/js/regex/JSRegExpGroupCapture.ts
+++ b/internal/formatter/builders/js/regex/JSRegExpGroupCapture.ts
@@ -4,22 +4,14 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSRegExpGroupCapture} from "@internal/ast";
-
-export default function JSRegExpGroupCapture(
-	builder: Builder,
-	node: JSRegExpGroupCapture,
-): Token {
-	const tokens: Array<Token> = ["("];
-
-	if (node.name !== undefined) {
-		tokens.push("?<");
-		tokens.push(node.name);
-		tokens.push(">");
-	}
-
-	return concat([concat(tokens), builder.tokenize(node.expression, node), ")"]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSRegExpGroupCapture(builder: Builder, node: JSRegExpGroupCapture): Token {
+    const tokens: Array<Token> = ["("];
+    if (node.name !== undefined) {
+        tokens.push("?<");
+        tokens.push(node.name);
+        tokens.push(">");
+    }
+    return concat([concat(tokens), builder.tokenize(node.expression, node), ")"]);
 }
diff --git a/internal/formatter/builders/js/regex/JSRegExpGroupNonCapture.ts b/internal/formatter/builders/js/regex/JSRegExpGroupNonCapture.ts
index be4938500..9066ec085 100644
--- a/internal/formatter/builders/js/regex/JSRegExpGroupNonCapture.ts
+++ b/internal/formatter/builders/js/regex/JSRegExpGroupNonCapture.ts
@@ -4,46 +4,33 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSRegExpGroupNonCapture} from "@internal/ast";
-
-export default function JSRegExpGroupNonCapture(
-	builder: Builder,
-	node: JSRegExpGroupNonCapture,
-): Token {
-	const tokens: Array<Token> = ["(?"];
-
-	switch (node.kind) {
-		case "positive-lookahead": {
-			tokens.push("=");
-			break;
-		}
-
-		case "negative-lookahead": {
-			tokens.push("!");
-			break;
-		}
-
-		case "positive-lookbehind": {
-			tokens.push("<!");
-			break;
-		}
-
-		case "negative-lookbehind": {
-			tokens.push("<=");
-			break;
-		}
-
-		default: {
-			tokens.push(":");
-			break;
-		}
-	}
-
-	tokens.push(builder.tokenize(node.expression, node));
-	tokens.push(")");
-
-	return concat(tokens);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSRegExpGroupNonCapture(builder: Builder, node: JSRegExpGroupNonCapture): Token {
+    const tokens: Array<Token> = ["(?"];
+    switch (node.kind) {
+        case "positive-lookahead": {
+            tokens.push("=");
+            break;
+        }
+        case "negative-lookahead": {
+            tokens.push("!");
+            break;
+        }
+        case "positive-lookbehind": {
+            tokens.push("<!");
+            break;
+        }
+        case "negative-lookbehind": {
+            tokens.push("<=");
+            break;
+        }
+        default: {
+            tokens.push(":");
+            break;
+        }
+    }
+    tokens.push(builder.tokenize(node.expression, node));
+    tokens.push(")");
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/regex/JSRegExpNamedBackReference.ts b/internal/formatter/builders/js/regex/JSRegExpNamedBackReference.ts
index 1269cbad0..09708d362 100644
--- a/internal/formatter/builders/js/regex/JSRegExpNamedBackReference.ts
+++ b/internal/formatter/builders/js/regex/JSRegExpNamedBackReference.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSRegExpNamedBackReference} from "@internal/ast";
-
-export default function JSRegExpNamedBackReference(
-	builder: Builder,
-	node: JSRegExpNamedBackReference,
-): Token {
-	return concat(["\\k", "<", node.name, ">"]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSRegExpNamedBackReference(builder: Builder, node: JSRegExpNamedBackReference): Token {
+    return concat(["\\k", "<", node.name, ">"]);
 }
diff --git a/internal/formatter/builders/js/regex/JSRegExpNumericBackReference.ts b/internal/formatter/builders/js/regex/JSRegExpNumericBackReference.ts
index e10ba3832..277179976 100644
--- a/internal/formatter/builders/js/regex/JSRegExpNumericBackReference.ts
+++ b/internal/formatter/builders/js/regex/JSRegExpNumericBackReference.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSRegExpNumericBackReference} from "@internal/ast";
-
-export default function JSRegExpNumericBackReference(
-	builder: Builder,
-	node: JSRegExpNumericBackReference,
-): Token {
-	return `\\${node.value}`;
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSRegExpNumericBackReference(builder: Builder, node: JSRegExpNumericBackReference): Token {
+    return `\\${node.value}`;
 }
diff --git a/internal/formatter/builders/js/regex/JSRegExpQuantified.ts b/internal/formatter/builders/js/regex/JSRegExpQuantified.ts
index 6dbca1a58..02c019d99 100644
--- a/internal/formatter/builders/js/regex/JSRegExpQuantified.ts
+++ b/internal/formatter/builders/js/regex/JSRegExpQuantified.ts
@@ -4,41 +4,32 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSRegExpQuantified} from "@internal/ast";
-
-export default function JSRegExpQuantified(
-	builder: Builder,
-	node: JSRegExpQuantified,
-): Token {
-	const tokens: Array<Token> = [builder.tokenize(node.target, node)];
-
-	if (node.min === 0 && node.max === 1) {
-		tokens.push("?");
-	} else if (node.min === 0 && node.max === undefined) {
-		tokens.push("*");
-	} else if (node.min === 1 && node.max === undefined) {
-		tokens.push("+");
-	} else {
-		tokens.push("{");
-
-		tokens.push(String(node.min));
-
-		if (node.min !== node.max) {
-			tokens.push(",");
-			if (node.max !== undefined) {
-				tokens.push(String(node.max));
-			}
-		}
-
-		tokens.push("}");
-	}
-
-	if (node.lazy) {
-		tokens.push("?");
-	}
-
-	return concat(tokens);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSRegExpQuantified(builder: Builder, node: JSRegExpQuantified): Token {
+    const tokens: Array<Token> = [builder.tokenize(node.target, node)];
+    if (node.min === 0 && node.max === 1) {
+        tokens.push("?");
+    }
+    else if (node.min === 0 && node.max === undefined) {
+        tokens.push("*");
+    }
+    else if (node.min === 1 && node.max === undefined) {
+        tokens.push("+");
+    }
+    else {
+        tokens.push("{");
+        tokens.push(String(node.min));
+        if (node.min !== node.max) {
+            tokens.push(",");
+            if (node.max !== undefined) {
+                tokens.push(String(node.max));
+            }
+        }
+        tokens.push("}");
+    }
+    if (node.lazy) {
+        tokens.push("?");
+    }
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/regex/JSRegExpSubExpression.ts b/internal/formatter/builders/js/regex/JSRegExpSubExpression.ts
index f38124fbf..2a14d3035 100644
--- a/internal/formatter/builders/js/regex/JSRegExpSubExpression.ts
+++ b/internal/formatter/builders/js/regex/JSRegExpSubExpression.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSRegExpSubExpression} from "@internal/ast";
-
-export default function JSRegExpSubExpression(
-	builder: Builder,
-	node: JSRegExpSubExpression,
-): Token {
-	return concat(node.body.map((item) => builder.tokenize(item, node)));
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSRegExpSubExpression(builder: Builder, node: JSRegExpSubExpression): Token {
+    return concat(node.body.map((item) => builder.tokenize(item, node)));
 }
diff --git a/internal/formatter/builders/js/statements/JSBlockStatement.ts b/internal/formatter/builders/js/statements/JSBlockStatement.ts
index c70f9d7f9..591291dbd 100644
--- a/internal/formatter/builders/js/statements/JSBlockStatement.ts
+++ b/internal/formatter/builders/js/statements/JSBlockStatement.ts
@@ -4,59 +4,41 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, hardline, indent} from "@internal/formatter";
-
-import {AnyNode, JSBlockStatement} from "@internal/ast";
-
-export default function JSBlockStatement(
-	builder: Builder,
-	node: JSBlockStatement,
-	parent: AnyNode,
-): Token {
-	const hasComments =
-		node.innerComments !== undefined && node.innerComments.length > 0;
-	const hasContents = node.body !== undefined && node.body.length > 0;
-	const hasDirectives =
-		node.directives !== undefined && node.directives.length > 0;
-
-	if (
-		!hasComments &&
-		!hasContents &&
-		!hasDirectives &&
-		(parent.type === "JSArrowFunctionExpression" ||
-		parent.type === "JSClassMethod" ||
-		parent.type === "JSClassPrivateMethod" ||
-		parent.type === "JSDoWhileStatement" ||
-		parent.type === "JSForInStatement" ||
-		parent.type === "JSForOfStatement" ||
-		parent.type === "JSForStatement" ||
-		parent.type === "JSFunctionDeclaration" ||
-		parent.type === "JSFunctionExpression" ||
-		parent.type === "JSObjectMethod" ||
-		parent.type === "JSSwitchStatement" ||
-		parent.type === "JSWhileStatement")
-	) {
-		return "{}";
-	}
-
-	const tokens: Array<Token> = ["{"];
-
-	if (hasDirectives) {
-		for (const directive of node.directives!) {
-			tokens.push(indent(builder.tokenize(directive, node), true));
-		}
-	}
-
-	if (hasContents) {
-		tokens.push(indent(builder.tokenizeStatementList(node.body, node), true));
-	}
-
-	if (hasComments) {
-		tokens.push(builder.tokenizeInnerComments(node, true));
-	}
-
-	tokens.push(hardline, "}");
-
-	return concat(tokens);
+import { Builder, Token, concat, hardline, indent } from "@internal/formatter";
+import { AnyNode } from "@internal/ast";
+export default function JSBlockStatement(builder: Builder, node: JSBlockStatement, parent: AnyNode): Token {
+    const hasComments = node.innerComments !== undefined && node.innerComments.length > 0;
+    const hasContents = node.body !== undefined && node.body.length > 0;
+    const hasDirectives = node.directives !== undefined && node.directives.length > 0;
+    if (!hasComments &&
+        !hasContents &&
+        !hasDirectives &&
+        (parent.type === "JSArrowFunctionExpression" ||
+            parent.type === "JSClassMethod" ||
+            parent.type === "JSClassPrivateMethod" ||
+            parent.type === "JSDoWhileStatement" ||
+            parent.type === "JSForInStatement" ||
+            parent.type === "JSForOfStatement" ||
+            parent.type === "JSForStatement" ||
+            parent.type === "JSFunctionDeclaration" ||
+            parent.type === "JSFunctionExpression" ||
+            parent.type === "JSObjectMethod" ||
+            parent.type === "JSSwitchStatement" ||
+            parent.type === "JSWhileStatement")) {
+        return "{}";
+    }
+    const tokens: Array<Token> = ["{"];
+    if (hasDirectives) {
+        for (const directive of node.directives!) {
+            tokens.push(indent(builder.tokenize(directive, node), true));
+        }
+    }
+    if (hasContents) {
+        tokens.push(indent(builder.tokenizeStatementList(node.body, node), true));
+    }
+    if (hasComments) {
+        tokens.push(builder.tokenizeInnerComments(node, true));
+    }
+    tokens.push(hardline, "}");
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/statements/JSDoWhileStatement.ts b/internal/formatter/builders/js/statements/JSDoWhileStatement.ts
index 3e010f0c0..14dfc8bb7 100644
--- a/internal/formatter/builders/js/statements/JSDoWhileStatement.ts
+++ b/internal/formatter/builders/js/statements/JSDoWhileStatement.ts
@@ -4,38 +4,21 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {JSDoWhileStatement} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	hardline,
-	indent,
-	softline,
-	space,
-} from "@internal/formatter";
-
-import {printClause} from "../utils";
-
-export default function JSDoWhileStatement(
-	builder: Builder,
-	node: JSDoWhileStatement,
-): Token {
-	return concat([
-		group(concat(["do", printClause(builder, node.body, node)])),
-		node.body.type === "JSBlockStatement" ? space : hardline,
-		"while",
-		space,
-		"(",
-		group(
-			concat([
-				indent(concat([softline, builder.tokenize(node.test, node)])),
-				softline,
-			]),
-		),
-		")",
-		";",
-	]);
+import {} from "@internal/ast";
+import { Builder, Token, concat, group, hardline, indent, softline, space, } from "@internal/formatter";
+import { printClause } from "../utils";
+export default function JSDoWhileStatement(builder: Builder, node: JSDoWhileStatement): Token {
+    return concat([
+        group(concat(["do", printClause(builder, node.body, node)])),
+        node.body.type === "JSBlockStatement" ? space : hardline,
+        "while",
+        space,
+        "(",
+        group(concat([
+            indent(concat([softline, builder.tokenize(node.test, node)])),
+            softline,
+        ])),
+        ")",
+        ";",
+    ]);
 }
diff --git a/internal/formatter/builders/js/statements/JSExpressionStatement.ts b/internal/formatter/builders/js/statements/JSExpressionStatement.ts
index 20c575be1..b799ad45c 100644
--- a/internal/formatter/builders/js/statements/JSExpressionStatement.ts
+++ b/internal/formatter/builders/js/statements/JSExpressionStatement.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {JSExpressionStatement} from "@internal/ast";
-
-export default function JSExpressionStatement(
-	builder: Builder,
-	node: JSExpressionStatement,
-): Token {
-	return concat([builder.tokenize(node.expression, node), ";"]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSExpressionStatement(builder: Builder, node: JSExpressionStatement): Token {
+    return concat([builder.tokenize(node.expression, node), ";"]);
 }
diff --git a/internal/formatter/builders/js/statements/JSForInStatement.ts b/internal/formatter/builders/js/statements/JSForInStatement.ts
index f048b1d4c..2f891ba34 100644
--- a/internal/formatter/builders/js/statements/JSForInStatement.ts
+++ b/internal/formatter/builders/js/statements/JSForInStatement.ts
@@ -4,28 +4,20 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, group, space} from "@internal/formatter";
-import {JSForInStatement} from "@internal/ast";
-
-import {printClause} from "../utils";
-
-export default function JSForInStatement(
-	builder: Builder,
-	node: JSForInStatement,
-): Token {
-	return group(
-		concat([
-			"for",
-			space,
-			"(",
-			builder.tokenize(node.left, node),
-			space,
-			"in",
-			space,
-			builder.tokenize(node.right, node),
-			")",
-			printClause(builder, node.body, node),
-		]),
-	);
+import { Builder, Token, concat, group, space } from "@internal/formatter";
+import {} from "@internal/ast";
+import { printClause } from "../utils";
+export default function JSForInStatement(builder: Builder, node: JSForInStatement): Token {
+    return group(concat([
+        "for",
+        space,
+        "(",
+        builder.tokenize(node.left, node),
+        space,
+        "in",
+        space,
+        builder.tokenize(node.right, node),
+        ")",
+        printClause(builder, node.body, node),
+    ]));
 }
diff --git a/internal/formatter/builders/js/statements/JSForOfStatement.ts b/internal/formatter/builders/js/statements/JSForOfStatement.ts
index 3765a214c..21e4a974c 100644
--- a/internal/formatter/builders/js/statements/JSForOfStatement.ts
+++ b/internal/formatter/builders/js/statements/JSForOfStatement.ts
@@ -4,29 +4,21 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, group, space} from "@internal/formatter";
-import {JSForOfStatement} from "@internal/ast";
-
-import {printClause} from "../utils";
-
-export default function JSForOfStatement(
-	builder: Builder,
-	node: JSForOfStatement,
-): Token {
-	return group(
-		concat([
-			"for",
-			node.await ? concat([space, "await"]) : "",
-			space,
-			"(",
-			builder.tokenize(node.left, node),
-			space,
-			"of",
-			space,
-			builder.tokenize(node.right, node),
-			")",
-			printClause(builder, node.body, node),
-		]),
-	);
+import { Builder, Token, concat, group, space } from "@internal/formatter";
+import {} from "@internal/ast";
+import { printClause } from "../utils";
+export default function JSForOfStatement(builder: Builder, node: JSForOfStatement): Token {
+    return group(concat([
+        "for",
+        node.await ? concat([space, "await"]) : "",
+        space,
+        "(",
+        builder.tokenize(node.left, node),
+        space,
+        "of",
+        space,
+        builder.tokenize(node.right, node),
+        ")",
+        printClause(builder, node.body, node),
+    ]));
 }
diff --git a/internal/formatter/builders/js/statements/JSForStatement.ts b/internal/formatter/builders/js/statements/JSForStatement.ts
index d28b805b6..fa35feaeb 100644
--- a/internal/formatter/builders/js/statements/JSForStatement.ts
+++ b/internal/formatter/builders/js/statements/JSForStatement.ts
@@ -4,55 +4,32 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {JSForStatement} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	indent,
-	lineOrSpace,
-	softline,
-	space,
-} from "@internal/formatter";
-
-import {printClause} from "../utils";
-
-export default function JSForStatement(
-	builder: Builder,
-	node: JSForStatement,
-): Token {
-	const body = printClause(builder, node.body, node);
-
-	if (!node.init && !node.test && !node.update) {
-		return group(concat(["for", space, "(;;)", body]));
-	}
-
-	return group(
-		concat([
-			"for",
-			space,
-			"(",
-			group(
-				concat([
-					indent(
-						concat([
-							softline,
-							builder.tokenize(node.init, node),
-							";",
-							lineOrSpace,
-							builder.tokenize(node.test, node),
-							";",
-							lineOrSpace,
-							builder.tokenize(node.update, node),
-						]),
-					),
-					softline,
-				]),
-			),
-			")",
-			body,
-		]),
-	);
+import {} from "@internal/ast";
+import { Builder, Token, concat, group, indent, lineOrSpace, softline, space, } from "@internal/formatter";
+import { printClause } from "../utils";
+export default function JSForStatement(builder: Builder, node: JSForStatement): Token {
+    const body = printClause(builder, node.body, node);
+    if (!node.init && !node.test && !node.update) {
+        return group(concat(["for", space, "(;;)", body]));
+    }
+    return group(concat([
+        "for",
+        space,
+        "(",
+        group(concat([
+            indent(concat([
+                softline,
+                builder.tokenize(node.init, node),
+                ";",
+                lineOrSpace,
+                builder.tokenize(node.test, node),
+                ";",
+                lineOrSpace,
+                builder.tokenize(node.update, node),
+            ])),
+            softline,
+        ])),
+        ")",
+        body,
+    ]));
 }
diff --git a/internal/formatter/builders/js/statements/JSFunctionDeclaration.ts b/internal/formatter/builders/js/statements/JSFunctionDeclaration.ts
index 26803782a..40ee08f80 100644
--- a/internal/formatter/builders/js/statements/JSFunctionDeclaration.ts
+++ b/internal/formatter/builders/js/statements/JSFunctionDeclaration.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {JSFunctionDeclaration} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
 import JSFunctionExpression from "../expressions/JSFunctionExpression";
-
-export default function JSFunctionDeclaration(
-	builder: Builder,
-	node: JSFunctionDeclaration,
-): Token {
-	return JSFunctionExpression(builder, node);
+export default function JSFunctionDeclaration(builder: Builder, node: JSFunctionDeclaration): Token {
+    return JSFunctionExpression(builder, node);
 }
diff --git a/internal/formatter/builders/js/statements/JSIfStatement.ts b/internal/formatter/builders/js/statements/JSIfStatement.ts
index f63b7eaa0..581665fa1 100644
--- a/internal/formatter/builders/js/statements/JSIfStatement.ts
+++ b/internal/formatter/builders/js/statements/JSIfStatement.ts
@@ -4,79 +4,50 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	hardline,
-	indent,
-	softline,
-	space,
-} from "@internal/formatter";
-
-import {AnyNode, JSIfStatement} from "@internal/ast";
-import {isStatement} from "@internal/js-ast-utils";
-
-export default function JSIfStatement(
-	builder: Builder,
-	node: JSIfStatement,
-): Token {
-	const tokens: Array<Token> = [
-		group(
-			concat([
-				"if",
-				space,
-				"(",
-				group(
-					concat([
-						indent(concat([softline, builder.tokenize(node.test, node)])),
-						softline,
-					]),
-				),
-				")",
-			]),
-		),
-		space,
-	];
-
-	let needsBlock = false;
-	if (node.alternate) {
-		needsBlock = getLastStatement(node.consequent).type === "JSIfStatement";
-	}
-
-	if (needsBlock) {
-		tokens.push(
-			"{",
-			indent(builder.tokenize(node.consequent, node), true),
-			hardline,
-			"}",
-		);
-	} else {
-		tokens.push(builder.tokenize(node.consequent, node));
-	}
-
-	if (node.alternate) {
-		tokens.push(space, "else", space, builder.tokenize(node.alternate, node));
-	}
-
-	return concat(tokens);
+import { Builder, Token, concat, group, hardline, indent, softline, space, } from "@internal/formatter";
+import { AnyNode } from "@internal/ast";
+import { isStatement } from "@internal/js-ast-utils";
+export default function JSIfStatement(builder: Builder, node: JSIfStatement): Token {
+    const tokens: Array<Token> = [
+        group(concat([
+            "if",
+            space,
+            "(",
+            group(concat([
+                indent(concat([softline, builder.tokenize(node.test, node)])),
+                softline,
+            ])),
+            ")",
+        ])),
+        space,
+    ];
+    let needsBlock = false;
+    if (node.alternate) {
+        needsBlock = getLastStatement(node.consequent).type === "JSIfStatement";
+    }
+    if (needsBlock) {
+        tokens.push("{", indent(builder.tokenize(node.consequent, node), true), hardline, "}");
+    }
+    else {
+        tokens.push(builder.tokenize(node.consequent, node));
+    }
+    if (node.alternate) {
+        tokens.push(space, "else", space, builder.tokenize(node.alternate, node));
+    }
+    return concat(tokens);
 }
-
 // Recursively get the last statement.
 function getLastStatement(statement: AnyNode): AnyNode {
-	if (
-		(statement.type === "JSWithStatement" ||
-		statement.type === "JSWhileStatement" ||
-		statement.type === "JSDoWhileStatement" ||
-		statement.type === "JSForOfStatement" ||
-		statement.type === "JSForInStatement" ||
-		statement.type === "JSForStatement") &&
-		isStatement(statement.body)
-	) {
-		return getLastStatement(statement.body);
-	} else {
-		return statement;
-	}
+    if ((statement.type === "JSWithStatement" ||
+        statement.type === "JSWhileStatement" ||
+        statement.type === "JSDoWhileStatement" ||
+        statement.type === "JSForOfStatement" ||
+        statement.type === "JSForInStatement" ||
+        statement.type === "JSForStatement") &&
+        isStatement(statement.body)) {
+        return getLastStatement(statement.body);
+    }
+    else {
+        return statement;
+    }
 }
diff --git a/internal/formatter/builders/js/statements/JSLabeledStatement.ts b/internal/formatter/builders/js/statements/JSLabeledStatement.ts
index be527c60d..1eb48a44e 100644
--- a/internal/formatter/builders/js/statements/JSLabeledStatement.ts
+++ b/internal/formatter/builders/js/statements/JSLabeledStatement.ts
@@ -4,20 +4,14 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {JSLabeledStatement} from "@internal/ast";
-
-export default function JSLabeledStatement(
-	builder: Builder,
-	node: JSLabeledStatement,
-): Token {
-	return concat([
-		builder.tokenize(node.label, node),
-		":",
-		node.body.type === "JSEmptyStatement"
-			? ";"
-			: concat([space, builder.tokenize(node.body, node)]),
-	]);
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSLabeledStatement(builder: Builder, node: JSLabeledStatement): Token {
+    return concat([
+        builder.tokenize(node.label, node),
+        ":",
+        node.body.type === "JSEmptyStatement"
+            ? ";"
+            : concat([space, builder.tokenize(node.body, node)]),
+    ]);
 }
diff --git a/internal/formatter/builders/js/statements/JSSwitchStatement.ts b/internal/formatter/builders/js/statements/JSSwitchStatement.ts
index 088f46e67..6e60eb38f 100644
--- a/internal/formatter/builders/js/statements/JSSwitchStatement.ts
+++ b/internal/formatter/builders/js/statements/JSSwitchStatement.ts
@@ -4,49 +4,26 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	hardline,
-	indent,
-	softline,
-	space,
-} from "@internal/formatter";
-
-import {JSSwitchStatement} from "@internal/ast";
-
-export default function JSSwitchStatement(
-	builder: Builder,
-	node: JSSwitchStatement,
-): Token {
-	return concat([
-		group(
-			concat([
-				"switch",
-				space,
-				"(",
-				group(
-					concat([
-						indent(
-							concat([softline, builder.tokenize(node.discriminant, node)]),
-						),
-						softline,
-					]),
-				),
-				")",
-			]),
-		),
-		space,
-		"{",
-		node.cases.length > 0
-			? indent(
-					concat([hardline, builder.tokenizeStatementList(node.cases, node)]),
-				)
-			: "",
-		hardline,
-		"}",
-	]);
+import { Builder, Token, concat, group, hardline, indent, softline, space, } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSSwitchStatement(builder: Builder, node: JSSwitchStatement): Token {
+    return concat([
+        group(concat([
+            "switch",
+            space,
+            "(",
+            group(concat([
+                indent(concat([softline, builder.tokenize(node.discriminant, node)])),
+                softline,
+            ])),
+            ")",
+        ])),
+        space,
+        "{",
+        node.cases.length > 0
+            ? indent(concat([hardline, builder.tokenizeStatementList(node.cases, node)]))
+            : "",
+        hardline,
+        "}",
+    ]);
 }
diff --git a/internal/formatter/builders/js/statements/JSTryStatement.ts b/internal/formatter/builders/js/statements/JSTryStatement.ts
index 70bb4e4ee..cea3a4f6e 100644
--- a/internal/formatter/builders/js/statements/JSTryStatement.ts
+++ b/internal/formatter/builders/js/statements/JSTryStatement.ts
@@ -4,28 +4,19 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {JSTryStatement} from "@internal/ast";
-
-export default function JSTryStatement(
-	builder: Builder,
-	node: JSTryStatement,
-): Token {
-	const tokens: Array<Token> = [
-		"try",
-		space,
-		builder.tokenize(node.block, node),
-	];
-
-	if (node.handler) {
-		tokens.push(space, builder.tokenize(node.handler, node));
-	}
-
-	if (node.finalizer) {
-		tokens.push(space, "finally", space, builder.tokenize(node.finalizer, node));
-	}
-
-	return concat(tokens);
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSTryStatement(builder: Builder, node: JSTryStatement): Token {
+    const tokens: Array<Token> = [
+        "try",
+        space,
+        builder.tokenize(node.block, node),
+    ];
+    if (node.handler) {
+        tokens.push(space, builder.tokenize(node.handler, node));
+    }
+    if (node.finalizer) {
+        tokens.push(space, "finally", space, builder.tokenize(node.finalizer, node));
+    }
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/statements/JSVariableDeclarationStatement.ts b/internal/formatter/builders/js/statements/JSVariableDeclarationStatement.ts
index fe3d3a30a..e1a1e8b93 100644
--- a/internal/formatter/builders/js/statements/JSVariableDeclarationStatement.ts
+++ b/internal/formatter/builders/js/statements/JSVariableDeclarationStatement.ts
@@ -4,23 +4,15 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-import {JSVariableDeclarationStatement} from "@internal/ast";
-
-export default function JSVariableDeclarationStatement(
-	builder: Builder,
-	node: JSVariableDeclarationStatement,
-): Token {
-	if (node.declare === true && !builder.options.typeAnnotations) {
-		return "";
-	}
-
-	const tokens: Array<Token> = [];
-
-	if (node.declare) {
-		tokens.push("declare", space);
-	}
-
-	return concat([concat(tokens), builder.tokenize(node.declaration, node), ";"]);
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function JSVariableDeclarationStatement(builder: Builder, node: JSVariableDeclarationStatement): Token {
+    if (node.declare === true && !builder.options.typeAnnotations) {
+        return "";
+    }
+    const tokens: Array<Token> = [];
+    if (node.declare) {
+        tokens.push("declare", space);
+    }
+    return concat([concat(tokens), builder.tokenize(node.declaration, node), ";"]);
 }
diff --git a/internal/formatter/builders/js/statements/JSWhileStatement.ts b/internal/formatter/builders/js/statements/JSWhileStatement.ts
index f5a829f4e..04e87fb8f 100644
--- a/internal/formatter/builders/js/statements/JSWhileStatement.ts
+++ b/internal/formatter/builders/js/statements/JSWhileStatement.ts
@@ -4,37 +4,19 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {JSWhileStatement} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	indent,
-	softline,
-	space,
-} from "@internal/formatter";
-
-import {printClause} from "../utils";
-
-export default function JSWhileStatement(
-	builder: Builder,
-	node: JSWhileStatement,
-): Token {
-	return group(
-		concat([
-			"while",
-			space,
-			"(",
-			group(
-				concat([
-					indent(concat([softline, builder.tokenize(node.test, node)])),
-					softline,
-				]),
-			),
-			")",
-			printClause(builder, node.body, node),
-		]),
-	);
+import {} from "@internal/ast";
+import { Builder, Token, concat, group, indent, softline, space, } from "@internal/formatter";
+import { printClause } from "../utils";
+export default function JSWhileStatement(builder: Builder, node: JSWhileStatement): Token {
+    return group(concat([
+        "while",
+        space,
+        "(",
+        group(concat([
+            indent(concat([softline, builder.tokenize(node.test, node)])),
+            softline,
+        ])),
+        ")",
+        printClause(builder, node.body, node),
+    ]));
 }
diff --git a/internal/formatter/builders/js/statements/JSWithStatement.ts b/internal/formatter/builders/js/statements/JSWithStatement.ts
index c8a218c3a..c61e9043d 100644
--- a/internal/formatter/builders/js/statements/JSWithStatement.ts
+++ b/internal/formatter/builders/js/statements/JSWithStatement.ts
@@ -4,22 +4,16 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {JSWithStatement} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {printClause} from "../utils";
-
-export default function JSWithStatement(
-	builder: Builder,
-	node: JSWithStatement,
-): Token {
-	return concat([
-		"with",
-		space,
-		"(",
-		builder.tokenize(node.object, node),
-		")",
-		printClause(builder, node.body, node),
-	]);
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+import { printClause } from "../utils";
+export default function JSWithStatement(builder: Builder, node: JSWithStatement): Token {
+    return concat([
+        "with",
+        space,
+        "(",
+        builder.tokenize(node.object, node),
+        ")",
+        printClause(builder, node.body, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSArrayType.ts b/internal/formatter/builders/js/typescript/TSArrayType.ts
index 4117faa8e..8940ab650 100644
--- a/internal/formatter/builders/js/typescript/TSArrayType.ts
+++ b/internal/formatter/builders/js/typescript/TSArrayType.ts
@@ -4,10 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSArrayType} from "@internal/ast";
-import {Builder, Token, concat} from "@internal/formatter";
-
+import {} from "@internal/ast";
+import { Builder, Token, concat } from "@internal/formatter";
 export default function TSArrayType(builder: Builder, node: TSArrayType): Token {
-	return concat([builder.tokenize(node.elementType, node), "[]"]);
+    return concat([builder.tokenize(node.elementType, node), "[]"]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSAsExpression.ts b/internal/formatter/builders/js/typescript/TSAsExpression.ts
index 5b9f452dd..d378dff0b 100644
--- a/internal/formatter/builders/js/typescript/TSAsExpression.ts
+++ b/internal/formatter/builders/js/typescript/TSAsExpression.ts
@@ -4,23 +4,19 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSAsExpression} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-export default function TSAsExpression(
-	builder: Builder,
-	node: TSAsExpression,
-): Token {
-	if (builder.options.typeAnnotations) {
-		return concat([
-			builder.tokenize(node.expression, node),
-			space,
-			"as",
-			space,
-			builder.tokenize(node.typeAnnotation, node),
-		]);
-	} else {
-		return builder.tokenize(node.expression, node);
-	}
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+export default function TSAsExpression(builder: Builder, node: TSAsExpression): Token {
+    if (builder.options.typeAnnotations) {
+        return concat([
+            builder.tokenize(node.expression, node),
+            space,
+            "as",
+            space,
+            builder.tokenize(node.typeAnnotation, node),
+        ]);
+    }
+    else {
+        return builder.tokenize(node.expression, node);
+    }
 }
diff --git a/internal/formatter/builders/js/typescript/TSAssignmentAsExpression.ts b/internal/formatter/builders/js/typescript/TSAssignmentAsExpression.ts
index 952a591cc..918a1b578 100644
--- a/internal/formatter/builders/js/typescript/TSAssignmentAsExpression.ts
+++ b/internal/formatter/builders/js/typescript/TSAssignmentAsExpression.ts
@@ -4,23 +4,19 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSAssignmentAsExpression} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-export default function TSAssignmentAsExpression(
-	builder: Builder,
-	node: TSAssignmentAsExpression,
-): Token {
-	if (builder.options.typeAnnotations) {
-		return concat([
-			builder.tokenize(node.expression, node),
-			space,
-			"as",
-			space,
-			builder.tokenize(node.typeAnnotation, node),
-		]);
-	} else {
-		return builder.tokenize(node.expression, node);
-	}
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+export default function TSAssignmentAsExpression(builder: Builder, node: TSAssignmentAsExpression): Token {
+    if (builder.options.typeAnnotations) {
+        return concat([
+            builder.tokenize(node.expression, node),
+            space,
+            "as",
+            space,
+            builder.tokenize(node.typeAnnotation, node),
+        ]);
+    }
+    else {
+        return builder.tokenize(node.expression, node);
+    }
 }
diff --git a/internal/formatter/builders/js/typescript/TSAssignmentNonNullExpression.ts b/internal/formatter/builders/js/typescript/TSAssignmentNonNullExpression.ts
index 0f7868b0d..37708d4f7 100644
--- a/internal/formatter/builders/js/typescript/TSAssignmentNonNullExpression.ts
+++ b/internal/formatter/builders/js/typescript/TSAssignmentNonNullExpression.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {TSAssignmentNonNullExpression} from "@internal/ast";
-
-export default function TSAssignmentNonNullExpression(
-	builder: Builder,
-	node: TSAssignmentNonNullExpression,
-): Token {
-	return concat([builder.tokenize(node.expression, node), "!"]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function TSAssignmentNonNullExpression(builder: Builder, node: TSAssignmentNonNullExpression): Token {
+    return concat([builder.tokenize(node.expression, node), "!"]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSAssignmentTypeAssertion.ts b/internal/formatter/builders/js/typescript/TSAssignmentTypeAssertion.ts
index 847b8ea42..0cf315f7d 100644
--- a/internal/formatter/builders/js/typescript/TSAssignmentTypeAssertion.ts
+++ b/internal/formatter/builders/js/typescript/TSAssignmentTypeAssertion.ts
@@ -4,20 +4,14 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {TSAssignmentTypeAssertion} from "@internal/ast";
-
-export default function TSAssignmentTypeAssertion(
-	builder: Builder,
-	node: TSAssignmentTypeAssertion,
-): Token {
-	return concat([
-		"<",
-		builder.tokenize(node.typeAnnotation, node),
-		">",
-		space,
-		builder.tokenize(node.expression, node),
-	]);
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function TSAssignmentTypeAssertion(builder: Builder, node: TSAssignmentTypeAssertion): Token {
+    return concat([
+        "<",
+        builder.tokenize(node.typeAnnotation, node),
+        ">",
+        space,
+        builder.tokenize(node.expression, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSBigIntLiteralTypeAnnotation.ts b/internal/formatter/builders/js/typescript/TSBigIntLiteralTypeAnnotation.ts
index 4cf5870d3..301792cb4 100644
--- a/internal/formatter/builders/js/typescript/TSBigIntLiteralTypeAnnotation.ts
+++ b/internal/formatter/builders/js/typescript/TSBigIntLiteralTypeAnnotation.ts
@@ -1,9 +1,5 @@
-import {TSBigIntLiteralTypeAnnotation} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function TSBigIntLiteralTypeAnnotation(
-	builder: Builder,
-	node: TSBigIntLiteralTypeAnnotation,
-): Token {
-	return `${node.value}n`;
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function TSBigIntLiteralTypeAnnotation(builder: Builder, node: TSBigIntLiteralTypeAnnotation): Token {
+    return `${node.value}n`;
 }
diff --git a/internal/formatter/builders/js/typescript/TSBooleanLiteralTypeAnnotation.ts b/internal/formatter/builders/js/typescript/TSBooleanLiteralTypeAnnotation.ts
index bf2ff031e..e7556f753 100644
--- a/internal/formatter/builders/js/typescript/TSBooleanLiteralTypeAnnotation.ts
+++ b/internal/formatter/builders/js/typescript/TSBooleanLiteralTypeAnnotation.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {TSBooleanLiteralTypeAnnotation} from "@internal/ast";
-
-export default function TSBooleanLiteralTypeAnnotation(
-	builder: Builder,
-	node: TSBooleanLiteralTypeAnnotation,
-): Token {
-	return node.value ? "true" : "false";
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function TSBooleanLiteralTypeAnnotation(builder: Builder, node: TSBooleanLiteralTypeAnnotation): Token {
+    return node.value ? "true" : "false";
 }
diff --git a/internal/formatter/builders/js/typescript/TSCallSignatureDeclaration.ts b/internal/formatter/builders/js/typescript/TSCallSignatureDeclaration.ts
index 32aee825a..616e8f722 100644
--- a/internal/formatter/builders/js/typescript/TSCallSignatureDeclaration.ts
+++ b/internal/formatter/builders/js/typescript/TSCallSignatureDeclaration.ts
@@ -4,21 +4,13 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSCallSignatureDeclaration} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-export default function TSCallSignatureDeclaration(
-	builder: Builder,
-	node: TSCallSignatureDeclaration,
-): Token {
-	const tokens: Array<Token> = [builder.tokenize(node.meta, node)];
-
-	if (node.typeAnnotation) {
-		tokens.push(":", space, builder.tokenize(node.typeAnnotation, node));
-	}
-
-	tokens.push(";");
-
-	return concat(tokens);
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+export default function TSCallSignatureDeclaration(builder: Builder, node: TSCallSignatureDeclaration): Token {
+    const tokens: Array<Token> = [builder.tokenize(node.meta, node)];
+    if (node.typeAnnotation) {
+        tokens.push(":", space, builder.tokenize(node.typeAnnotation, node));
+    }
+    tokens.push(";");
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/typescript/TSConditionalType.ts b/internal/formatter/builders/js/typescript/TSConditionalType.ts
index 4ddf3dac4..34ae0ddce 100644
--- a/internal/formatter/builders/js/typescript/TSConditionalType.ts
+++ b/internal/formatter/builders/js/typescript/TSConditionalType.ts
@@ -3,28 +3,15 @@
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
- */ import {AnyNode, TSConditionalType} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {printConditionalExpression} from "../expressions/JSConditionalExpression";
-
-export default function TSConditionalType(
-	builder: Builder,
-	node: TSConditionalType,
-	parent: AnyNode,
-): Token {
-	return printConditionalExpression(
-		concat([
-			builder.tokenize(node.checkType, node),
-			space,
-			"extends",
-			space,
-			builder.tokenize(node.extendsType, node),
-		]),
-		builder.tokenize(node.trueType, node),
-		builder.tokenize(node.falseType, node),
-		parent,
-		node.trueType,
-		node.falseType,
-	);
+ */ import { AnyNode } from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+import { printConditionalExpression } from "../expressions/JSConditionalExpression";
+export default function TSConditionalType(builder: Builder, node: TSConditionalType, parent: AnyNode): Token {
+    return printConditionalExpression(concat([
+        builder.tokenize(node.checkType, node),
+        space,
+        "extends",
+        space,
+        builder.tokenize(node.extendsType, node),
+    ]), builder.tokenize(node.trueType, node), builder.tokenize(node.falseType, node), parent, node.trueType, node.falseType);
 }
diff --git a/internal/formatter/builders/js/typescript/TSConstKeyword.ts b/internal/formatter/builders/js/typescript/TSConstKeyword.ts
index 73b674280..0ebaa826c 100644
--- a/internal/formatter/builders/js/typescript/TSConstKeyword.ts
+++ b/internal/formatter/builders/js/typescript/TSConstKeyword.ts
@@ -1,6 +1,5 @@
-import {TSConstKeyword} from "@internal/ast";
-import {Token} from "@internal/formatter";
-
+import {} from "@internal/ast";
+import { Token } from "@internal/formatter";
 export default function TSConstKeyword(): Token {
-	return "const";
+    return "const";
 }
diff --git a/internal/formatter/builders/js/typescript/TSConstructSignatureDeclaration.ts b/internal/formatter/builders/js/typescript/TSConstructSignatureDeclaration.ts
index 449b36e79..ff2a10f98 100644
--- a/internal/formatter/builders/js/typescript/TSConstructSignatureDeclaration.ts
+++ b/internal/formatter/builders/js/typescript/TSConstructSignatureDeclaration.ts
@@ -4,21 +4,13 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSConstructSignatureDeclaration} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-export default function TSConstructSignatureDeclaration(
-	builder: Builder,
-	node: TSConstructSignatureDeclaration,
-): Token {
-	const tokens: Array<Token> = ["new", space, builder.tokenize(node.meta, node)];
-
-	if (node.typeAnnotation) {
-		tokens.push(":", space, builder.tokenize(node.typeAnnotation, node));
-	}
-
-	tokens.push(";");
-
-	return concat(tokens);
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+export default function TSConstructSignatureDeclaration(builder: Builder, node: TSConstructSignatureDeclaration): Token {
+    const tokens: Array<Token> = ["new", space, builder.tokenize(node.meta, node)];
+    if (node.typeAnnotation) {
+        tokens.push(":", space, builder.tokenize(node.typeAnnotation, node));
+    }
+    tokens.push(";");
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/typescript/TSConstructorType.ts b/internal/formatter/builders/js/typescript/TSConstructorType.ts
index 6c70c3ff8..444b5c00a 100644
--- a/internal/formatter/builders/js/typescript/TSConstructorType.ts
+++ b/internal/formatter/builders/js/typescript/TSConstructorType.ts
@@ -4,20 +4,12 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {TSConstructorType} from "@internal/ast";
-
-export default function TSConstructorType(
-	builder: Builder,
-	node: TSConstructorType,
-): Token {
-	const tokens: Array<Token> = ["new", space, builder.tokenize(node.meta, node)];
-
-	if (node.typeAnnotation) {
-		tokens.push(space, "=>", space, builder.tokenize(node.typeAnnotation, node));
-	}
-
-	return concat(tokens);
+import { Builder, Token, concat, space } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function TSConstructorType(builder: Builder, node: TSConstructorType): Token {
+    const tokens: Array<Token> = ["new", space, builder.tokenize(node.meta, node)];
+    if (node.typeAnnotation) {
+        tokens.push(space, "=>", space, builder.tokenize(node.typeAnnotation, node));
+    }
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/typescript/TSDeclareFunction.ts b/internal/formatter/builders/js/typescript/TSDeclareFunction.ts
index b71da0d75..06b7b65cd 100644
--- a/internal/formatter/builders/js/typescript/TSDeclareFunction.ts
+++ b/internal/formatter/builders/js/typescript/TSDeclareFunction.ts
@@ -4,26 +4,19 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSDeclareFunction} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-export default function TSDeclareFunction(
-	builder: Builder,
-	node: TSDeclareFunction,
-): Token {
-	let tokens: Array<Token> = [];
-
-	if (node.declare) {
-		tokens.push("declare", space);
-	}
-
-	return concat([
-		concat(tokens),
-		"function",
-		space,
-		builder.tokenize(node.id, node),
-		builder.tokenize(node.head, node),
-		";",
-	]);
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+export default function TSDeclareFunction(builder: Builder, node: TSDeclareFunction): Token {
+    let tokens: Array<Token> = [];
+    if (node.declare) {
+        tokens.push("declare", space);
+    }
+    return concat([
+        concat(tokens),
+        "function",
+        space,
+        builder.tokenize(node.id, node),
+        builder.tokenize(node.head, node),
+        ";",
+    ]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSDeclareMethod.ts b/internal/formatter/builders/js/typescript/TSDeclareMethod.ts
index 11e64b00f..2386b9c0a 100644
--- a/internal/formatter/builders/js/typescript/TSDeclareMethod.ts
+++ b/internal/formatter/builders/js/typescript/TSDeclareMethod.ts
@@ -4,19 +4,13 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSDeclareMethod} from "@internal/ast";
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {printMethod} from "../utils";
-
-export default function TSDeclareMethod(
-	builder: Builder,
-	node: TSDeclareMethod,
-): Token {
-	return concat([
-		builder.tokenize(node.meta, node),
-		builder.tokenize(node.key, node),
-		printMethod(builder, node),
-	]);
+import {} from "@internal/ast";
+import { Builder, Token, concat } from "@internal/formatter";
+import { printMethod } from "../utils";
+export default function TSDeclareMethod(builder: Builder, node: TSDeclareMethod): Token {
+    return concat([
+        builder.tokenize(node.meta, node),
+        builder.tokenize(node.key, node),
+        printMethod(builder, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSEnumDeclaration.ts b/internal/formatter/builders/js/typescript/TSEnumDeclaration.ts
index f87448def..a93589651 100644
--- a/internal/formatter/builders/js/typescript/TSEnumDeclaration.ts
+++ b/internal/formatter/builders/js/typescript/TSEnumDeclaration.ts
@@ -4,33 +4,17 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSEnumDeclaration} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {printTSBraced} from "../utils";
-
-export default function TSEnumDeclaration(
-	builder: Builder,
-	node: TSEnumDeclaration,
-): Token {
-	const tokens: Array<Token> = [];
-
-	if (node.declare) {
-		tokens.push("declare", space);
-	}
-
-	if (node.const) {
-		tokens.push("const", space);
-	}
-
-	tokens.push(
-		"enum",
-		space,
-		builder.tokenize(node.id, node),
-		space,
-		printTSBraced(builder, node, node.members),
-	);
-
-	return concat(tokens);
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+import { printTSBraced } from "../utils";
+export default function TSEnumDeclaration(builder: Builder, node: TSEnumDeclaration): Token {
+    const tokens: Array<Token> = [];
+    if (node.declare) {
+        tokens.push("declare", space);
+    }
+    if (node.const) {
+        tokens.push("const", space);
+    }
+    tokens.push("enum", space, builder.tokenize(node.id, node), space, printTSBraced(builder, node, node.members));
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/typescript/TSEnumMember.ts b/internal/formatter/builders/js/typescript/TSEnumMember.ts
index 7b7b0b1ec..569642026 100644
--- a/internal/formatter/builders/js/typescript/TSEnumMember.ts
+++ b/internal/formatter/builders/js/typescript/TSEnumMember.ts
@@ -4,21 +4,13 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSEnumMember} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-export default function TSEnumMember(
-	builder: Builder,
-	node: TSEnumMember,
-): Token {
-	const tokens: Array<Token> = [builder.tokenize(node.id, node)];
-
-	if (node.initializer) {
-		tokens.push(space, "=", space, builder.tokenize(node.initializer, node));
-	}
-
-	tokens.push(",");
-
-	return concat(tokens);
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+export default function TSEnumMember(builder: Builder, node: TSEnumMember): Token {
+    const tokens: Array<Token> = [builder.tokenize(node.id, node)];
+    if (node.initializer) {
+        tokens.push(space, "=", space, builder.tokenize(node.initializer, node));
+    }
+    tokens.push(",");
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/typescript/TSExportAssignment.ts b/internal/formatter/builders/js/typescript/TSExportAssignment.ts
index 365da9a1d..568a8b72c 100644
--- a/internal/formatter/builders/js/typescript/TSExportAssignment.ts
+++ b/internal/formatter/builders/js/typescript/TSExportAssignment.ts
@@ -4,20 +4,15 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSExportAssignment} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-export default function TSExportAssignment(
-	builder: Builder,
-	node: TSExportAssignment,
-): Token {
-	return concat([
-		"export",
-		space,
-		"=",
-		space,
-		builder.tokenize(node.expression, node),
-		";",
-	]);
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+export default function TSExportAssignment(builder: Builder, node: TSExportAssignment): Token {
+    return concat([
+        "export",
+        space,
+        "=",
+        space,
+        builder.tokenize(node.expression, node),
+        ";",
+    ]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSExpressionWithTypeArguments.ts b/internal/formatter/builders/js/typescript/TSExpressionWithTypeArguments.ts
index d85992063..8fc76f95e 100644
--- a/internal/formatter/builders/js/typescript/TSExpressionWithTypeArguments.ts
+++ b/internal/formatter/builders/js/typescript/TSExpressionWithTypeArguments.ts
@@ -4,16 +4,11 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSExpressionWithTypeArguments} from "@internal/ast";
-import {Builder, Token, concat} from "@internal/formatter";
-
-export default function TSExpressionWithTypeArguments(
-	builder: Builder,
-	node: TSExpressionWithTypeArguments,
-): Token {
-	return concat([
-		builder.tokenize(node.expression, node),
-		builder.tokenize(node.typeParameters, node),
-	]);
+import {} from "@internal/ast";
+import { Builder, Token, concat } from "@internal/formatter";
+export default function TSExpressionWithTypeArguments(builder: Builder, node: TSExpressionWithTypeArguments): Token {
+    return concat([
+        builder.tokenize(node.expression, node),
+        builder.tokenize(node.typeParameters, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSExternalModuleReference.ts b/internal/formatter/builders/js/typescript/TSExternalModuleReference.ts
index da657eac5..39df8777c 100644
--- a/internal/formatter/builders/js/typescript/TSExternalModuleReference.ts
+++ b/internal/formatter/builders/js/typescript/TSExternalModuleReference.ts
@@ -4,13 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSExternalModuleReference} from "@internal/ast";
-import {Builder, Token, concat} from "@internal/formatter";
-
-export default function TSExternalModuleReference(
-	builder: Builder,
-	node: TSExternalModuleReference,
-): Token {
-	return concat(["require(", builder.tokenize(node.expression, node), ")"]);
+import {} from "@internal/ast";
+import { Builder, Token, concat } from "@internal/formatter";
+export default function TSExternalModuleReference(builder: Builder, node: TSExternalModuleReference): Token {
+    return concat(["require(", builder.tokenize(node.expression, node), ")"]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSFunctionType.ts b/internal/formatter/builders/js/typescript/TSFunctionType.ts
index 6081038b1..d3ab4722f 100644
--- a/internal/formatter/builders/js/typescript/TSFunctionType.ts
+++ b/internal/formatter/builders/js/typescript/TSFunctionType.ts
@@ -4,21 +4,14 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSFunctionType} from "@internal/ast";
-import {Builder, Token, concat, group, space} from "@internal/formatter";
-
-export default function TSFunctionType(
-	builder: Builder,
-	node: TSFunctionType,
-): Token {
-	return group(
-		concat([
-			builder.tokenize(node.meta, node),
-			space,
-			"=>",
-			space,
-			builder.tokenize(node.typeAnnotation, node),
-		]),
-	);
+import {} from "@internal/ast";
+import { Builder, Token, concat, group, space } from "@internal/formatter";
+export default function TSFunctionType(builder: Builder, node: TSFunctionType): Token {
+    return group(concat([
+        builder.tokenize(node.meta, node),
+        space,
+        "=>",
+        space,
+        builder.tokenize(node.typeAnnotation, node),
+    ]));
 }
diff --git a/internal/formatter/builders/js/typescript/TSImportEqualsDeclaration.ts b/internal/formatter/builders/js/typescript/TSImportEqualsDeclaration.ts
index a77b5f960..dad0d8321 100644
--- a/internal/formatter/builders/js/typescript/TSImportEqualsDeclaration.ts
+++ b/internal/formatter/builders/js/typescript/TSImportEqualsDeclaration.ts
@@ -4,30 +4,14 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSImportEqualsDeclaration} from "@internal/ast";
-import {Builder, Token, concat, group, space} from "@internal/formatter";
-
-export default function TSImportEqualsDeclaration(
-	builder: Builder,
-	node: TSImportEqualsDeclaration,
-): Token {
-	const tokens: Array<Token> = [];
-	if (node.isExport) {
-		tokens.push("export");
-		tokens.push(space);
-	}
-
-	tokens.push(
-		"import",
-		space,
-		builder.tokenize(node.id, node),
-		space,
-		"=",
-		space,
-		builder.tokenize(node.moduleReference, node),
-		";",
-	);
-
-	return group(concat(tokens));
+import {} from "@internal/ast";
+import { Builder, Token, concat, group, space } from "@internal/formatter";
+export default function TSImportEqualsDeclaration(builder: Builder, node: TSImportEqualsDeclaration): Token {
+    const tokens: Array<Token> = [];
+    if (node.isExport) {
+        tokens.push("export");
+        tokens.push(space);
+    }
+    tokens.push("import", space, builder.tokenize(node.id, node), space, "=", space, builder.tokenize(node.moduleReference, node), ";");
+    return group(concat(tokens));
 }
diff --git a/internal/formatter/builders/js/typescript/TSImportType.ts b/internal/formatter/builders/js/typescript/TSImportType.ts
index 11bc1fd2e..d17a86e81 100644
--- a/internal/formatter/builders/js/typescript/TSImportType.ts
+++ b/internal/formatter/builders/js/typescript/TSImportType.ts
@@ -4,27 +4,19 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSImportType} from "@internal/ast";
-import {Builder, Token, concat} from "@internal/formatter";
-
-export default function TSImportType(
-	builder: Builder,
-	node: TSImportType,
-): Token {
-	const tokens: Array<Token> = [
-		"import(",
-		builder.tokenize(node.argument, node),
-		")",
-	];
-
-	if (node.qualifier) {
-		tokens.push(".", builder.tokenize(node.qualifier, node));
-	}
-
-	if (node.typeParameters) {
-		tokens.push(builder.tokenize(node.typeParameters, node));
-	}
-
-	return concat(tokens);
+import {} from "@internal/ast";
+import { Builder, Token, concat } from "@internal/formatter";
+export default function TSImportType(builder: Builder, node: TSImportType): Token {
+    const tokens: Array<Token> = [
+        "import(",
+        builder.tokenize(node.argument, node),
+        ")",
+    ];
+    if (node.qualifier) {
+        tokens.push(".", builder.tokenize(node.qualifier, node));
+    }
+    if (node.typeParameters) {
+        tokens.push(builder.tokenize(node.typeParameters, node));
+    }
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/typescript/TSIndexSignature.ts b/internal/formatter/builders/js/typescript/TSIndexSignature.ts
index 7f257aa3b..932d9e8be 100644
--- a/internal/formatter/builders/js/typescript/TSIndexSignature.ts
+++ b/internal/formatter/builders/js/typescript/TSIndexSignature.ts
@@ -4,29 +4,22 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSIndexSignature} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-export default function TSIndexSignature(
-	builder: Builder,
-	node: TSIndexSignature,
-): Token {
-	const tokens: Array<Token> = [];
-
-	if (node.readonly) {
-		tokens.push("readonly");
-		tokens.push(space);
-	}
-
-	return concat([
-		concat(tokens),
-		"[",
-		builder.tokenize(node.key, node),
-		"]",
-		":",
-		space,
-		builder.tokenize(node.typeAnnotation, node),
-		";",
-	]);
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+export default function TSIndexSignature(builder: Builder, node: TSIndexSignature): Token {
+    const tokens: Array<Token> = [];
+    if (node.readonly) {
+        tokens.push("readonly");
+        tokens.push(space);
+    }
+    return concat([
+        concat(tokens),
+        "[",
+        builder.tokenize(node.key, node),
+        "]",
+        ":",
+        space,
+        builder.tokenize(node.typeAnnotation, node),
+        ";",
+    ]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSIndexedAccessType.ts b/internal/formatter/builders/js/typescript/TSIndexedAccessType.ts
index f8b2a2a0c..281d8c0b5 100644
--- a/internal/formatter/builders/js/typescript/TSIndexedAccessType.ts
+++ b/internal/formatter/builders/js/typescript/TSIndexedAccessType.ts
@@ -4,18 +4,13 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSIndexedAccessType} from "@internal/ast";
-import {Builder, Token, concat} from "@internal/formatter";
-
-export default function TSIndexedAccessType(
-	builder: Builder,
-	node: TSIndexedAccessType,
-): Token {
-	return concat([
-		builder.tokenize(node.objectType, node),
-		"[",
-		builder.tokenize(node.indexType, node),
-		"]",
-	]);
+import {} from "@internal/ast";
+import { Builder, Token, concat } from "@internal/formatter";
+export default function TSIndexedAccessType(builder: Builder, node: TSIndexedAccessType): Token {
+    return concat([
+        builder.tokenize(node.objectType, node),
+        "[",
+        builder.tokenize(node.indexType, node),
+        "]",
+    ]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSInferType.ts b/internal/formatter/builders/js/typescript/TSInferType.ts
index b3792cd63..7973f0886 100644
--- a/internal/formatter/builders/js/typescript/TSInferType.ts
+++ b/internal/formatter/builders/js/typescript/TSInferType.ts
@@ -4,10 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSInferType} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
 export default function TSInferType(builder: Builder, node: TSInferType): Token {
-	return concat(["infer", space, builder.tokenize(node.typeParameter, node)]);
+    return concat(["infer", space, builder.tokenize(node.typeParameter, node)]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSInterfaceBody.ts b/internal/formatter/builders/js/typescript/TSInterfaceBody.ts
index 048745d7a..e0218e587 100644
--- a/internal/formatter/builders/js/typescript/TSInterfaceBody.ts
+++ b/internal/formatter/builders/js/typescript/TSInterfaceBody.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSInterfaceBody} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-import {printTSBraced} from "../utils";
-
-export default function TSInterfaceBody(
-	builder: Builder,
-	node: TSInterfaceBody,
-): Token {
-	return printTSBraced(builder, node, node.body);
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+import { printTSBraced } from "../utils";
+export default function TSInterfaceBody(builder: Builder, node: TSInterfaceBody): Token {
+    return printTSBraced(builder, node, node.body);
 }
diff --git a/internal/formatter/builders/js/typescript/TSInterfaceDeclaration.ts b/internal/formatter/builders/js/typescript/TSInterfaceDeclaration.ts
index a21b74798..24ee73e29 100644
--- a/internal/formatter/builders/js/typescript/TSInterfaceDeclaration.ts
+++ b/internal/formatter/builders/js/typescript/TSInterfaceDeclaration.ts
@@ -4,37 +4,17 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSInterfaceDeclaration} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-import {printCommaList} from "../utils";
-
-export default function TSInterfaceDeclaration(
-	builder: Builder,
-	node: TSInterfaceDeclaration,
-): Token {
-	const tokens: Array<Token> = [];
-
-	if (node.declare) {
-		tokens.push("declare", space);
-	}
-
-	tokens.push(
-		"interface",
-		space,
-		builder.tokenize(node.id, node),
-		builder.tokenize(node.typeParameters, node),
-	);
-
-	if (node.extends !== undefined && node.extends.length > 0) {
-		tokens.push(
-			space,
-			"extends",
-			space,
-			printCommaList(builder, node.extends, node),
-		);
-	}
-
-	return concat([concat(tokens), space, builder.tokenize(node.body, node)]);
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+import { printCommaList } from "../utils";
+export default function TSInterfaceDeclaration(builder: Builder, node: TSInterfaceDeclaration): Token {
+    const tokens: Array<Token> = [];
+    if (node.declare) {
+        tokens.push("declare", space);
+    }
+    tokens.push("interface", space, builder.tokenize(node.id, node), builder.tokenize(node.typeParameters, node));
+    if (node.extends !== undefined && node.extends.length > 0) {
+        tokens.push(space, "extends", space, printCommaList(builder, node.extends, node));
+    }
+    return concat([concat(tokens), space, builder.tokenize(node.body, node)]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSIntersectionTypeAnnotation.ts b/internal/formatter/builders/js/typescript/TSIntersectionTypeAnnotation.ts
index 1de67b06b..b15deef8f 100644
--- a/internal/formatter/builders/js/typescript/TSIntersectionTypeAnnotation.ts
+++ b/internal/formatter/builders/js/typescript/TSIntersectionTypeAnnotation.ts
@@ -4,68 +4,52 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {AnyNode, TSIntersectionTypeAnnotation} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	indent,
-	lineOrSpace,
-	space,
-} from "@internal/formatter";
-
-export default function TSIntersectionTypeAnnotation(
-	builder: Builder,
-	node: TSIntersectionTypeAnnotation,
-): Token {
-	const parts = [];
-	let shouldIndent = false;
-	let previous: undefined | AnyNode;
-
-	for (let i = 0; i < node.types.length; i++) {
-		const type = node.types[i];
-		const printed = builder.tokenize(type, node);
-
-		if (previous === undefined) {
-			parts.push(printed);
-		} else if (isObjectType(previous) && isObjectType(type)) {
-			//   let foo: {
-			//     a: string;
-			//     b: string;
-			//   } & {
-			//     c: string;
-			//     d: string;
-			//   };
-			parts.push(space, "&", space, shouldIndent ? indent(printed) : printed);
-		} else if (!isObjectType(previous) && !isObjectType(type)) {
-			//   let foo: XXXX &
-			//     YYYY &&
-			//     ZZZZ;
-			parts.push(indent(concat([space, "&", lineOrSpace, printed])));
-		} else {
-			//   let z: AAA & {
-			//     a: string;
-			//     b: string;
-			//   } & BBB &
-			//     CCC & {
-			//       c: string;
-			//       d: string;
-			//     };
-			if (i > 1) {
-				shouldIndent = true;
-			}
-
-			parts.push(space, "&", space, shouldIndent ? indent(printed) : printed);
-		}
-
-		previous = type;
-	}
-
-	return group(concat(parts));
+import { AnyNode } from "@internal/ast";
+import { Builder, Token, concat, group, indent, lineOrSpace, space, } from "@internal/formatter";
+export default function TSIntersectionTypeAnnotation(builder: Builder, node: TSIntersectionTypeAnnotation): Token {
+    const parts = [];
+    let shouldIndent = false;
+    let previous: undefined | AnyNode;
+    for (let i = 0; i < node.types.length; i++) {
+        const type = node.types[i];
+        const printed = builder.tokenize(type, node);
+        if (previous === undefined) {
+            parts.push(printed);
+        }
+        else if (isObjectType(previous) && isObjectType(type)) {
+            //   let foo: {
+            //     a: string;
+            //     b: string;
+            //   } & {
+            //     c: string;
+            //     d: string;
+            //   };
+            parts.push(space, "&", space, shouldIndent ? indent(printed) : printed);
+        }
+        else if (!isObjectType(previous) && !isObjectType(type)) {
+            //   let foo: XXXX &
+            //     YYYY &&
+            //     ZZZZ;
+            parts.push(indent(concat([space, "&", lineOrSpace, printed])));
+        }
+        else {
+            //   let z: AAA & {
+            //     a: string;
+            //     b: string;
+            //   } & BBB &
+            //     CCC & {
+            //       c: string;
+            //       d: string;
+            //     };
+            if (i > 1) {
+                shouldIndent = true;
+            }
+            parts.push(space, "&", space, shouldIndent ? indent(printed) : printed);
+        }
+        previous = type;
+    }
+    return group(concat(parts));
 }
-
 function isObjectType(node: AnyNode): boolean {
-	return node.type === "TSMappedType" || node.type === "TSObjectTypeAnnotation";
+    return node.type === "TSMappedType" || node.type === "TSObjectTypeAnnotation";
 }
diff --git a/internal/formatter/builders/js/typescript/TSMappedType.ts b/internal/formatter/builders/js/typescript/TSMappedType.ts
index 649da3aa8..df839ab07 100644
--- a/internal/formatter/builders/js/typescript/TSMappedType.ts
+++ b/internal/formatter/builders/js/typescript/TSMappedType.ts
@@ -4,59 +4,29 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSMappedType} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	indent,
-	softline,
-	space,
-} from "@internal/formatter";
-
-export default function TSMappedType(
-	builder: Builder,
-	node: TSMappedType,
-): Token {
-	const tokens: Array<Token> = [];
-
-	if (node.readonly) {
-		tokens.push(tokenIfPlusMinus(builder, node.readonly), "readonly", space);
-	}
-
-	const {typeParameter} = node;
-	tokens.push(
-		"[",
-		typeParameter.name,
-		space,
-		"in",
-		space,
-		builder.tokenize(typeParameter.constraint, typeParameter),
-		"]",
-	);
-
-	if (node.optional) {
-		tokens.push(tokenIfPlusMinus(builder, node.optional), "?");
-	}
-
-	if (node.typeAnnotation) {
-		tokens.push(":", space, builder.tokenize(node.typeAnnotation, node));
-	}
-
-	return group(
-		concat(["{", indent(concat([softline, concat(tokens)])), softline, "}"]),
-	);
+import {} from "@internal/ast";
+import { Builder, Token, concat, group, indent, softline, space, } from "@internal/formatter";
+export default function TSMappedType(builder: Builder, node: TSMappedType): Token {
+    const tokens: Array<Token> = [];
+    if (node.readonly) {
+        tokens.push(tokenIfPlusMinus(builder, node.readonly), "readonly", space);
+    }
+    const { typeParameter } = node;
+    tokens.push("[", typeParameter.name, space, "in", space, builder.tokenize(typeParameter.constraint, typeParameter), "]");
+    if (node.optional) {
+        tokens.push(tokenIfPlusMinus(builder, node.optional), "?");
+    }
+    if (node.typeAnnotation) {
+        tokens.push(":", space, builder.tokenize(node.typeAnnotation, node));
+    }
+    return group(concat(["{", indent(concat([softline, concat(tokens)])), softline, "}"]));
 }
-
 function tokenIfPlusMinus(builder: Builder, token: string | true): Token {
-	switch (token) {
-		case "+":
-		case "-":
-			return token;
-
-		default:
-			return "";
-	}
+    switch (token) {
+        case "+":
+        case "-":
+            return token;
+        default:
+            return "";
+    }
 }
diff --git a/internal/formatter/builders/js/typescript/TSMethodSignature.ts b/internal/formatter/builders/js/typescript/TSMethodSignature.ts
index d89c9bfd7..4f35c01e6 100644
--- a/internal/formatter/builders/js/typescript/TSMethodSignature.ts
+++ b/internal/formatter/builders/js/typescript/TSMethodSignature.ts
@@ -4,26 +4,18 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSMethodSignature} from "@internal/ast";
-import {Builder, Token, concat, group, space} from "@internal/formatter";
-
-export default function TSMethodSignature(
-	builder: Builder,
-	node: TSMethodSignature,
-): Token {
-	const tokens: Array<Token> = [
-		builder.tokenize(node.key, node),
-		builder.tokenize(node.meta, node),
-	];
-
-	if (node.returnType) {
-		tokens.push(":");
-		tokens.push(space);
-		tokens.push(builder.tokenize(node.returnType, node));
-	}
-
-	tokens.push(";");
-
-	return group(concat(tokens));
+import {} from "@internal/ast";
+import { Builder, Token, concat, group, space } from "@internal/formatter";
+export default function TSMethodSignature(builder: Builder, node: TSMethodSignature): Token {
+    const tokens: Array<Token> = [
+        builder.tokenize(node.key, node),
+        builder.tokenize(node.meta, node),
+    ];
+    if (node.returnType) {
+        tokens.push(":");
+        tokens.push(space);
+        tokens.push(builder.tokenize(node.returnType, node));
+    }
+    tokens.push(";");
+    return group(concat(tokens));
 }
diff --git a/internal/formatter/builders/js/typescript/TSModuleBlock.ts b/internal/formatter/builders/js/typescript/TSModuleBlock.ts
index 077ef5aaf..a9b009083 100644
--- a/internal/formatter/builders/js/typescript/TSModuleBlock.ts
+++ b/internal/formatter/builders/js/typescript/TSModuleBlock.ts
@@ -4,18 +4,13 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSModuleBlock} from "@internal/ast";
-import {Builder, Token, concat, hardline, indent} from "@internal/formatter";
-
-export default function TSModuleBlock(
-	builder: Builder,
-	node: TSModuleBlock,
-): Token {
-	return concat([
-		"{",
-		indent(builder.tokenizeStatementList(node.body, node), true),
-		hardline,
-		"}",
-	]);
+import {} from "@internal/ast";
+import { Builder, Token, concat, hardline, indent } from "@internal/formatter";
+export default function TSModuleBlock(builder: Builder, node: TSModuleBlock): Token {
+    return concat([
+        "{",
+        indent(builder.tokenizeStatementList(node.body, node), true),
+        hardline,
+        "}",
+    ]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSModuleDeclaration.ts b/internal/formatter/builders/js/typescript/TSModuleDeclaration.ts
index 01f4d0349..d0f47d1df 100644
--- a/internal/formatter/builders/js/typescript/TSModuleDeclaration.ts
+++ b/internal/formatter/builders/js/typescript/TSModuleDeclaration.ts
@@ -4,38 +4,27 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSModuleBlock, TSModuleDeclaration} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-export default function TSModuleDeclaration(
-	builder: Builder,
-	node: TSModuleDeclaration,
-): Token {
-	const tokens: Array<Token> = [];
-
-	if (node.declare) {
-		tokens.push("declare");
-		tokens.push(space);
-	}
-
-	if (!node.global) {
-		tokens.push(node.id.type === "JSBindingIdentifier" ? "namespace" : "module");
-		tokens.push(space);
-	}
-
-	tokens.push(builder.tokenize(node.id, node));
-
-	if (!node.body) {
-		tokens.push(";");
-		return concat(tokens);
-	}
-
-	let body: undefined | TSModuleBlock | TSModuleDeclaration = node.body;
-	while (body !== undefined && body.type === "TSModuleDeclaration") {
-		tokens.push(".", builder.tokenize(body.id, body));
-		body = body.body;
-	}
-
-	return concat([concat(tokens), space, builder.tokenize(body, node)]);
+import { TSModuleBlock } from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+export default function TSModuleDeclaration(builder: Builder, node: TSModuleDeclaration): Token {
+    const tokens: Array<Token> = [];
+    if (node.declare) {
+        tokens.push("declare");
+        tokens.push(space);
+    }
+    if (!node.global) {
+        tokens.push(node.id.type === "JSBindingIdentifier" ? "namespace" : "module");
+        tokens.push(space);
+    }
+    tokens.push(builder.tokenize(node.id, node));
+    if (!node.body) {
+        tokens.push(";");
+        return concat(tokens);
+    }
+    let body: undefined | TSModuleBlock | TSModuleDeclaration = node.body;
+    while (body !== undefined && body.type === "TSModuleDeclaration") {
+        tokens.push(".", builder.tokenize(body.id, body));
+        body = body.body;
+    }
+    return concat([concat(tokens), space, builder.tokenize(body, node)]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSNamespaceExportDeclaration.ts b/internal/formatter/builders/js/typescript/TSNamespaceExportDeclaration.ts
index 539ec0c3d..0afc73143 100644
--- a/internal/formatter/builders/js/typescript/TSNamespaceExportDeclaration.ts
+++ b/internal/formatter/builders/js/typescript/TSNamespaceExportDeclaration.ts
@@ -4,22 +4,17 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSNamespaceExportDeclaration} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-export default function TSNamespaceExportDeclaration(
-	builder: Builder,
-	node: TSNamespaceExportDeclaration,
-): Token {
-	return concat([
-		"export",
-		space,
-		"as",
-		space,
-		"namespace",
-		space,
-		builder.tokenize(node.id, node),
-		";",
-	]);
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+export default function TSNamespaceExportDeclaration(builder: Builder, node: TSNamespaceExportDeclaration): Token {
+    return concat([
+        "export",
+        space,
+        "as",
+        space,
+        "namespace",
+        space,
+        builder.tokenize(node.id, node),
+        ";",
+    ]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSNonNullExpression.ts b/internal/formatter/builders/js/typescript/TSNonNullExpression.ts
index fea9cb836..974bc12d2 100644
--- a/internal/formatter/builders/js/typescript/TSNonNullExpression.ts
+++ b/internal/formatter/builders/js/typescript/TSNonNullExpression.ts
@@ -4,19 +4,14 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSNonNullExpression} from "@internal/ast";
-import {Builder, Token, concat} from "@internal/formatter";
-
-export default function TSNonNullExpression(
-	builder: Builder,
-	node: TSNonNullExpression,
-): Token {
-	const expr = builder.tokenize(node.expression, node);
-
-	if (builder.options.typeAnnotations) {
-		return concat([expr, "!"]);
-	} else {
-		return expr;
-	}
+import {} from "@internal/ast";
+import { Builder, Token, concat } from "@internal/formatter";
+export default function TSNonNullExpression(builder: Builder, node: TSNonNullExpression): Token {
+    const expr = builder.tokenize(node.expression, node);
+    if (builder.options.typeAnnotations) {
+        return concat([expr, "!"]);
+    }
+    else {
+        return expr;
+    }
 }
diff --git a/internal/formatter/builders/js/typescript/TSNumericLiteralTypeAnnotation.ts b/internal/formatter/builders/js/typescript/TSNumericLiteralTypeAnnotation.ts
index b07ed3bc5..c2dc56359 100644
--- a/internal/formatter/builders/js/typescript/TSNumericLiteralTypeAnnotation.ts
+++ b/internal/formatter/builders/js/typescript/TSNumericLiteralTypeAnnotation.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {TSNumericLiteralTypeAnnotation} from "@internal/ast";
-
-export default function TSNumericLiteralTypeAnnotation(
-	builder: Builder,
-	node: TSNumericLiteralTypeAnnotation,
-): Token {
-	return String(node.value);
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
+export default function TSNumericLiteralTypeAnnotation(builder: Builder, node: TSNumericLiteralTypeAnnotation): Token {
+    return String(node.value);
 }
diff --git a/internal/formatter/builders/js/typescript/TSObjectTypeAnnotation.ts b/internal/formatter/builders/js/typescript/TSObjectTypeAnnotation.ts
index 3aabdce69..d414a24c6 100644
--- a/internal/formatter/builders/js/typescript/TSObjectTypeAnnotation.ts
+++ b/internal/formatter/builders/js/typescript/TSObjectTypeAnnotation.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSObjectTypeAnnotation} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-import {printTSBraced} from "../utils";
-
-export default function TSObjectTypeAnnotation(
-	builder: Builder,
-	node: TSObjectTypeAnnotation,
-): Token {
-	return printTSBraced(builder, node, node.members);
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+import { printTSBraced } from "../utils";
+export default function TSObjectTypeAnnotation(builder: Builder, node: TSObjectTypeAnnotation): Token {
+    return printTSBraced(builder, node, node.members);
 }
diff --git a/internal/formatter/builders/js/typescript/TSParenthesizedType.ts b/internal/formatter/builders/js/typescript/TSParenthesizedType.ts
index b92349f15..6384d9543 100644
--- a/internal/formatter/builders/js/typescript/TSParenthesizedType.ts
+++ b/internal/formatter/builders/js/typescript/TSParenthesizedType.ts
@@ -4,13 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSParenthesizedType} from "@internal/ast";
-import {Builder, Token, concat} from "@internal/formatter";
-
-export default function TSParenthesizedType(
-	builder: Builder,
-	node: TSParenthesizedType,
-): Token {
-	return concat(["(", builder.tokenize(node.typeAnnotation, node), ")"]);
+import {} from "@internal/ast";
+import { Builder, Token, concat } from "@internal/formatter";
+export default function TSParenthesizedType(builder: Builder, node: TSParenthesizedType): Token {
+    return concat(["(", builder.tokenize(node.typeAnnotation, node), ")"]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSPropertySignature.ts b/internal/formatter/builders/js/typescript/TSPropertySignature.ts
index 3fa8886a6..f209a7a01 100644
--- a/internal/formatter/builders/js/typescript/TSPropertySignature.ts
+++ b/internal/formatter/builders/js/typescript/TSPropertySignature.ts
@@ -4,31 +4,20 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSPropertySignature} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-export default function TSPropertySignature(
-	builder: Builder,
-	node: TSPropertySignature,
-): Token {
-	const tokens: Array<Token> = [];
-
-	if (node.readonly) {
-		tokens.push("readonly", space);
-	}
-
-	tokens.push(builder.tokenize(node.key, node));
-
-	if (node.optional) {
-		tokens.push("?");
-	}
-
-	if (node.typeAnnotation) {
-		tokens.push(":", space, builder.tokenize(node.typeAnnotation, node));
-	}
-
-	tokens.push(";");
-
-	return concat(tokens);
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+export default function TSPropertySignature(builder: Builder, node: TSPropertySignature): Token {
+    const tokens: Array<Token> = [];
+    if (node.readonly) {
+        tokens.push("readonly", space);
+    }
+    tokens.push(builder.tokenize(node.key, node));
+    if (node.optional) {
+        tokens.push("?");
+    }
+    if (node.typeAnnotation) {
+        tokens.push(":", space, builder.tokenize(node.typeAnnotation, node));
+    }
+    tokens.push(";");
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/typescript/TSQualifiedName.ts b/internal/formatter/builders/js/typescript/TSQualifiedName.ts
index 14c2381fc..990e0648e 100644
--- a/internal/formatter/builders/js/typescript/TSQualifiedName.ts
+++ b/internal/formatter/builders/js/typescript/TSQualifiedName.ts
@@ -4,17 +4,12 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSQualifiedName} from "@internal/ast";
-import {Builder, Token, concat} from "@internal/formatter";
-
-export default function TSQualifiedName(
-	builder: Builder,
-	node: TSQualifiedName,
-): Token {
-	return concat([
-		builder.tokenize(node.left, node),
-		".",
-		builder.tokenize(node.right, node),
-	]);
+import {} from "@internal/ast";
+import { Builder, Token, concat } from "@internal/formatter";
+export default function TSQualifiedName(builder: Builder, node: TSQualifiedName): Token {
+    return concat([
+        builder.tokenize(node.left, node),
+        ".",
+        builder.tokenize(node.right, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSSignatureDeclarationMeta.ts b/internal/formatter/builders/js/typescript/TSSignatureDeclarationMeta.ts
index 9701211d8..b8a96bd88 100644
--- a/internal/formatter/builders/js/typescript/TSSignatureDeclarationMeta.ts
+++ b/internal/formatter/builders/js/typescript/TSSignatureDeclarationMeta.ts
@@ -4,18 +4,12 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat} from "@internal/formatter";
-
-import {TSSignatureDeclarationMeta} from "@internal/ast";
-import {printBindingPatternParams} from "../utils";
-
-export default function TSSignatureDeclarationMeta(
-	builder: Builder,
-	node: TSSignatureDeclarationMeta,
-): Token {
-	return concat([
-		builder.tokenize(node.typeParameters, node),
-		printBindingPatternParams(builder, node, node.parameters, node.rest),
-	]);
+import { Builder, Token, concat } from "@internal/formatter";
+import {} from "@internal/ast";
+import { printBindingPatternParams } from "../utils";
+export default function TSSignatureDeclarationMeta(builder: Builder, node: TSSignatureDeclarationMeta): Token {
+    return concat([
+        builder.tokenize(node.typeParameters, node),
+        printBindingPatternParams(builder, node, node.parameters, node.rest),
+    ]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSStringLiteralTypeAnnotation.ts b/internal/formatter/builders/js/typescript/TSStringLiteralTypeAnnotation.ts
index a5c7792c8..3794a4d09 100644
--- a/internal/formatter/builders/js/typescript/TSStringLiteralTypeAnnotation.ts
+++ b/internal/formatter/builders/js/typescript/TSStringLiteralTypeAnnotation.ts
@@ -4,16 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {AnyNode, TSStringLiteralTypeAnnotation} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+import { AnyNode } from "@internal/ast";
 import JSStringLiteral from "../literals/JSStringLiteral";
-
-export default function TSStringLiteralTypeAnnotation(
-	builder: Builder,
-	node: TSStringLiteralTypeAnnotation,
-	parent: AnyNode,
-): Token {
-	return JSStringLiteral(builder, node, parent);
+export default function TSStringLiteralTypeAnnotation(builder: Builder, node: TSStringLiteralTypeAnnotation, parent: AnyNode): Token {
+    return JSStringLiteral(builder, node, parent);
 }
diff --git a/internal/formatter/builders/js/typescript/TSTemplateLiteralTypeAnnotation.ts b/internal/formatter/builders/js/typescript/TSTemplateLiteralTypeAnnotation.ts
index 3165dab67..25892b856 100644
--- a/internal/formatter/builders/js/typescript/TSTemplateLiteralTypeAnnotation.ts
+++ b/internal/formatter/builders/js/typescript/TSTemplateLiteralTypeAnnotation.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token} from "@internal/formatter";
-
-import {TSTemplateLiteralTypeAnnotation} from "@internal/ast";
-import {escapeJSString} from "@internal/string-escape";
-
-export default function TSTemplateLiteralTypeAnnotation(
-	builder: Builder,
-	node: TSTemplateLiteralTypeAnnotation,
-): Token {
-	return escapeJSString(node.value, {quote: "`"});
+import { Builder, Token } from "@internal/formatter";
+import {} from "@internal/ast";
+import { escapeJSString } from "@internal/string-escape";
+export default function TSTemplateLiteralTypeAnnotation(builder: Builder, node: TSTemplateLiteralTypeAnnotation): Token {
+    return escapeJSString(node.value, { quote: "`" });
 }
diff --git a/internal/formatter/builders/js/typescript/TSTupleElement.ts b/internal/formatter/builders/js/typescript/TSTupleElement.ts
index 01299d38f..2f431f575 100644
--- a/internal/formatter/builders/js/typescript/TSTupleElement.ts
+++ b/internal/formatter/builders/js/typescript/TSTupleElement.ts
@@ -1,26 +1,17 @@
-import {TSTupleElement} from "@internal/ast";
-import {Builder, Token, Tokens, concat, space} from "@internal/formatter";
-
-export default function TSTupleElement(
-	builder: Builder,
-	node: TSTupleElement,
-): Token {
-	let tokens: Tokens = [];
-
-	if (node.name) {
-		tokens.push(builder.tokenize(node.name, node));
-	}
-
-	if (node.optional) {
-		tokens.push("?");
-	}
-
-	if (node.name) {
-		tokens.push(":");
-		tokens.push(space);
-	}
-
-	tokens.push(builder.tokenize(node.typeAnnotation, node));
-
-	return concat(tokens);
+import {} from "@internal/ast";
+import { Builder, Token, Tokens, concat, space } from "@internal/formatter";
+export default function TSTupleElement(builder: Builder, node: TSTupleElement): Token {
+    let tokens: Tokens = [];
+    if (node.name) {
+        tokens.push(builder.tokenize(node.name, node));
+    }
+    if (node.optional) {
+        tokens.push("?");
+    }
+    if (node.name) {
+        tokens.push(":");
+        tokens.push(space);
+    }
+    tokens.push(builder.tokenize(node.typeAnnotation, node));
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/typescript/TSTupleType.ts b/internal/formatter/builders/js/typescript/TSTupleType.ts
index bccf3f33b..96a7ce73d 100644
--- a/internal/formatter/builders/js/typescript/TSTupleType.ts
+++ b/internal/formatter/builders/js/typescript/TSTupleType.ts
@@ -4,57 +4,37 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSTupleType} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	hardline,
-	ifBreak,
-	indent,
-	join,
-	lineOrSpace,
-	softline,
-} from "@internal/formatter";
-
-import {hasInnerComments} from "../../comments";
-
+import {} from "@internal/ast";
+import { Builder, Token, concat, group, hardline, ifBreak, indent, join, lineOrSpace, softline, } from "@internal/formatter";
+import { hasInnerComments } from "../../comments";
 export default function TSTupleType(builder: Builder, node: TSTupleType): Token {
-	if (node.elementTypes.length === 0 && node.rest === undefined) {
-		if (hasInnerComments(node)) {
-			return concat([
-				"[",
-				builder.tokenizeInnerComments(node, true),
-				hardline,
-				"]",
-			]);
-		} else {
-			return "[]";
-		}
-	}
-
-	const parts: Array<Token> = [];
-
-	for (const elementType of node.elementTypes) {
-		parts.push(builder.tokenize(elementType, node));
-	}
-
-	if (node.rest !== undefined) {
-		parts.push(concat(["...", builder.tokenize(node.rest, node)]));
-	}
-
-	const tokens: Array<Token> = [
-		"[",
-		indent(concat([softline, join(concat([",", lineOrSpace]), parts)])),
-	];
-
-	if (node.rest === undefined) {
-		tokens.push(ifBreak(","));
-	}
-
-	tokens.push(softline, "]");
-
-	return group(concat(tokens));
+    if (node.elementTypes.length === 0 && node.rest === undefined) {
+        if (hasInnerComments(node)) {
+            return concat([
+                "[",
+                builder.tokenizeInnerComments(node, true),
+                hardline,
+                "]",
+            ]);
+        }
+        else {
+            return "[]";
+        }
+    }
+    const parts: Array<Token> = [];
+    for (const elementType of node.elementTypes) {
+        parts.push(builder.tokenize(elementType, node));
+    }
+    if (node.rest !== undefined) {
+        parts.push(concat(["...", builder.tokenize(node.rest, node)]));
+    }
+    const tokens: Array<Token> = [
+        "[",
+        indent(concat([softline, join(concat([",", lineOrSpace]), parts)])),
+    ];
+    if (node.rest === undefined) {
+        tokens.push(ifBreak(","));
+    }
+    tokens.push(softline, "]");
+    return group(concat(tokens));
 }
diff --git a/internal/formatter/builders/js/typescript/TSTypeAlias.ts b/internal/formatter/builders/js/typescript/TSTypeAlias.ts
index ad6e31b89..c50efd284 100644
--- a/internal/formatter/builders/js/typescript/TSTypeAlias.ts
+++ b/internal/formatter/builders/js/typescript/TSTypeAlias.ts
@@ -4,22 +4,18 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Builder, Token, concat, group, space} from "@internal/formatter";
-import {TSTypeAlias} from "@internal/ast";
-
+import { Builder, Token, concat, group, space } from "@internal/formatter";
+import {} from "@internal/ast";
 export default function TSTypeAlias(builder: Builder, node: TSTypeAlias): Token {
-	return group(
-		concat([
-			"type",
-			space,
-			builder.tokenize(node.id, node),
-			builder.tokenize(node.typeParameters, node),
-			space,
-			"=",
-			space,
-			builder.tokenize(node.right, node),
-			";",
-		]),
-	);
+    return group(concat([
+        "type",
+        space,
+        builder.tokenize(node.id, node),
+        builder.tokenize(node.typeParameters, node),
+        space,
+        "=",
+        space,
+        builder.tokenize(node.right, node),
+        ";",
+    ]));
 }
diff --git a/internal/formatter/builders/js/typescript/TSTypeAssertion.ts b/internal/formatter/builders/js/typescript/TSTypeAssertion.ts
index 07b6dbe74..6b9f9d2f5 100644
--- a/internal/formatter/builders/js/typescript/TSTypeAssertion.ts
+++ b/internal/formatter/builders/js/typescript/TSTypeAssertion.ts
@@ -4,38 +4,21 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSTypeAssertion} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	indent,
-	softline,
-} from "@internal/formatter";
-
-export default function TSTypeAssertion(
-	builder: Builder,
-	node: TSTypeAssertion,
-): Token {
-	if (builder.options.typeAnnotations) {
-		return group(
-			concat([
-				group(
-					concat([
-						"<",
-						indent(
-							concat([softline, builder.tokenize(node.typeAnnotation, node)]),
-						),
-						softline,
-						">",
-					]),
-				),
-				builder.tokenize(node.expression, node),
-			]),
-		);
-	} else {
-		return builder.tokenize(node.expression, node);
-	}
+import {} from "@internal/ast";
+import { Builder, Token, concat, group, indent, softline, } from "@internal/formatter";
+export default function TSTypeAssertion(builder: Builder, node: TSTypeAssertion): Token {
+    if (builder.options.typeAnnotations) {
+        return group(concat([
+            group(concat([
+                "<",
+                indent(concat([softline, builder.tokenize(node.typeAnnotation, node)])),
+                softline,
+                ">",
+            ])),
+            builder.tokenize(node.expression, node),
+        ]));
+    }
+    else {
+        return builder.tokenize(node.expression, node);
+    }
 }
diff --git a/internal/formatter/builders/js/typescript/TSTypeOperator.ts b/internal/formatter/builders/js/typescript/TSTypeOperator.ts
index a77a0eb59..5662889b6 100644
--- a/internal/formatter/builders/js/typescript/TSTypeOperator.ts
+++ b/internal/formatter/builders/js/typescript/TSTypeOperator.ts
@@ -4,17 +4,12 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSTypeOperator} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-export default function TSTypeOperator(
-	builder: Builder,
-	node: TSTypeOperator,
-): Token {
-	return concat([
-		node.operator,
-		space,
-		builder.tokenize(node.typeAnnotation, node),
-	]);
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+export default function TSTypeOperator(builder: Builder, node: TSTypeOperator): Token {
+    return concat([
+        node.operator,
+        space,
+        builder.tokenize(node.typeAnnotation, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSTypeParameter.ts b/internal/formatter/builders/js/typescript/TSTypeParameter.ts
index de831c9bf..a2e83098f 100644
--- a/internal/formatter/builders/js/typescript/TSTypeParameter.ts
+++ b/internal/formatter/builders/js/typescript/TSTypeParameter.ts
@@ -4,28 +4,15 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSTypeParameter} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-export default function TSTypeParameter(
-	builder: Builder,
-	node: TSTypeParameter,
-): Token {
-	const tokens: Array<Token> = [node.name];
-
-	if (node.constraint) {
-		tokens.push(
-			space,
-			"extends",
-			space,
-			builder.tokenize(node.constraint, node),
-		);
-	}
-
-	if (node.default) {
-		tokens.push(space, "=", space, builder.tokenize(node.default, node));
-	}
-
-	return concat(tokens);
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+export default function TSTypeParameter(builder: Builder, node: TSTypeParameter): Token {
+    const tokens: Array<Token> = [node.name];
+    if (node.constraint) {
+        tokens.push(space, "extends", space, builder.tokenize(node.constraint, node));
+    }
+    if (node.default) {
+        tokens.push(space, "=", space, builder.tokenize(node.default, node));
+    }
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/typescript/TSTypeParameterDeclaration.ts b/internal/formatter/builders/js/typescript/TSTypeParameterDeclaration.ts
index ef8972239..c25ec4369 100644
--- a/internal/formatter/builders/js/typescript/TSTypeParameterDeclaration.ts
+++ b/internal/formatter/builders/js/typescript/TSTypeParameterDeclaration.ts
@@ -4,44 +4,25 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	TSTypeParameterDeclaration,
-	TSTypeParameterInstantiation,
-} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	indent,
-	softline,
-} from "@internal/formatter";
-
-import {printCommaList} from "../utils";
-
-export default function TSTypeParameterDeclaration(
-	builder: Builder,
-	node: TSTypeParameterDeclaration | TSTypeParameterInstantiation,
-): Token {
-	const params = node.params;
-	const shouldInline =
-		params.length === 1 &&
-		params[0].type !== "TSIntersectionTypeAnnotation" &&
-		params[0].type !== "TSUnionTypeAnnotation" &&
-		params[0].type !== "TSIndexedAccessType" &&
-		params[0].type !== "TSMappedType";
-
-	if (shouldInline) {
-		return concat(["<", builder.tokenize(params[0], node), ">"]);
-	} else {
-		return group(
-			concat([
-				"<",
-				indent(concat([softline, printCommaList(builder, params, node)])),
-				softline,
-				">",
-			]),
-		);
-	}
+import { TSTypeParameterInstantiation, } from "@internal/ast";
+import { Builder, Token, concat, group, indent, softline, } from "@internal/formatter";
+import { printCommaList } from "../utils";
+export default function TSTypeParameterDeclaration(builder: Builder, node: TSTypeParameterDeclaration | TSTypeParameterInstantiation): Token {
+    const params = node.params;
+    const shouldInline = params.length === 1 &&
+        params[0].type !== "TSIntersectionTypeAnnotation" &&
+        params[0].type !== "TSUnionTypeAnnotation" &&
+        params[0].type !== "TSIndexedAccessType" &&
+        params[0].type !== "TSMappedType";
+    if (shouldInline) {
+        return concat(["<", builder.tokenize(params[0], node), ">"]);
+    }
+    else {
+        return group(concat([
+            "<",
+            indent(concat([softline, printCommaList(builder, params, node)])),
+            softline,
+            ">",
+        ]));
+    }
 }
diff --git a/internal/formatter/builders/js/typescript/TSTypeParameterInstantiation.ts b/internal/formatter/builders/js/typescript/TSTypeParameterInstantiation.ts
index d780d08ca..07eadb4f4 100644
--- a/internal/formatter/builders/js/typescript/TSTypeParameterInstantiation.ts
+++ b/internal/formatter/builders/js/typescript/TSTypeParameterInstantiation.ts
@@ -4,15 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSTypeParameterInstantiation} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
 import TSTypeParameterDeclaration from "./TSTypeParameterDeclaration";
-
-export default function TSTypeParameterInstantiation(
-	builder: Builder,
-	node: TSTypeParameterInstantiation,
-): Token {
-	return TSTypeParameterDeclaration(builder, node);
+export default function TSTypeParameterInstantiation(builder: Builder, node: TSTypeParameterInstantiation): Token {
+    return TSTypeParameterDeclaration(builder, node);
 }
diff --git a/internal/formatter/builders/js/typescript/TSTypePredicate.ts b/internal/formatter/builders/js/typescript/TSTypePredicate.ts
index 788991aa5..3ea3f6aa3 100644
--- a/internal/formatter/builders/js/typescript/TSTypePredicate.ts
+++ b/internal/formatter/builders/js/typescript/TSTypePredicate.ts
@@ -4,25 +4,16 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSTypePredicate} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
-export default function TSTypePredicate(
-	builder: Builder,
-	node: TSTypePredicate,
-): Token {
-	const tokens: Array<Token> = [];
-
-	if (node.asserts) {
-		tokens.push("asserts", space);
-	}
-
-	tokens.push(builder.tokenize(node.parameterName, node));
-
-	if (node.typeAnnotation) {
-		tokens.push(space, "is", space, builder.tokenize(node.typeAnnotation, node));
-	}
-
-	return concat(tokens);
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
+export default function TSTypePredicate(builder: Builder, node: TSTypePredicate): Token {
+    const tokens: Array<Token> = [];
+    if (node.asserts) {
+        tokens.push("asserts", space);
+    }
+    tokens.push(builder.tokenize(node.parameterName, node));
+    if (node.typeAnnotation) {
+        tokens.push(space, "is", space, builder.tokenize(node.typeAnnotation, node));
+    }
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/js/typescript/TSTypeQuery.ts b/internal/formatter/builders/js/typescript/TSTypeQuery.ts
index b1175d506..bd14eab61 100644
--- a/internal/formatter/builders/js/typescript/TSTypeQuery.ts
+++ b/internal/formatter/builders/js/typescript/TSTypeQuery.ts
@@ -4,10 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSTypeQuery} from "@internal/ast";
-import {Builder, Token, concat, space} from "@internal/formatter";
-
+import {} from "@internal/ast";
+import { Builder, Token, concat, space } from "@internal/formatter";
 export default function TSTypeQuery(builder: Builder, node: TSTypeQuery): Token {
-	return concat(["typeof", space, builder.tokenize(node.exprName, node)]);
+    return concat(["typeof", space, builder.tokenize(node.exprName, node)]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSTypeReference.ts b/internal/formatter/builders/js/typescript/TSTypeReference.ts
index 22e5da29c..a684ddb13 100644
--- a/internal/formatter/builders/js/typescript/TSTypeReference.ts
+++ b/internal/formatter/builders/js/typescript/TSTypeReference.ts
@@ -4,16 +4,11 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {TSTypeReference} from "@internal/ast";
-import {Builder, Token, concat} from "@internal/formatter";
-
-export default function TSTypeReference(
-	builder: Builder,
-	node: TSTypeReference,
-): Token {
-	return concat([
-		builder.tokenize(node.typeName, node),
-		builder.tokenize(node.typeParameters, node),
-	]);
+import {} from "@internal/ast";
+import { Builder, Token, concat } from "@internal/formatter";
+export default function TSTypeReference(builder: Builder, node: TSTypeReference): Token {
+    return concat([
+        builder.tokenize(node.typeName, node),
+        builder.tokenize(node.typeParameters, node),
+    ]);
 }
diff --git a/internal/formatter/builders/js/typescript/TSUnionTypeAnnotation.ts b/internal/formatter/builders/js/typescript/TSUnionTypeAnnotation.ts
index 93d09ac87..a7bdac3f2 100644
--- a/internal/formatter/builders/js/typescript/TSUnionTypeAnnotation.ts
+++ b/internal/formatter/builders/js/typescript/TSUnionTypeAnnotation.ts
@@ -4,40 +4,16 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	Builder,
-	Token,
-	concat,
-	group,
-	hardline,
-	ifBreak,
-	indent,
-	join,
-	lineOrSpace,
-	space,
-} from "@internal/formatter";
-
-import {AnyNode, TSUnionTypeAnnotation} from "@internal/ast";
-
-export default function TSUnionTypeAnnotation(
-	builder: Builder,
-	node: TSUnionTypeAnnotation,
-	parent: AnyNode,
-): Token {
-	// Indentation may be handled by the parent node
-	const shouldIndent =
-		parent.type !== "TSTypeAssertion" &&
-		parent.type !== "TSTypeParameterDeclaration" &&
-		parent.type !== "TSTypeParameterInstantiation";
-
-	const printed = concat([
-		ifBreak(concat([shouldIndent ? hardline : "", "|", space])),
-		join(
-			concat([lineOrSpace, "|", space]),
-			node.types.map((type) => indent(builder.tokenize(type, node))),
-		),
-	]);
-
-	return group(shouldIndent ? indent(printed) : printed);
+import { Builder, Token, concat, group, hardline, ifBreak, indent, join, lineOrSpace, space, } from "@internal/formatter";
+import { AnyNode } from "@internal/ast";
+export default function TSUnionTypeAnnotation(builder: Builder, node: TSUnionTypeAnnotation, parent: AnyNode): Token {
+    // Indentation may be handled by the parent node
+    const shouldIndent = parent.type !== "TSTypeAssertion" &&
+        parent.type !== "TSTypeParameterDeclaration" &&
+        parent.type !== "TSTypeParameterInstantiation";
+    const printed = concat([
+        ifBreak(concat([shouldIndent ? hardline : "", "|", space])),
+        join(concat([lineOrSpace, "|", space]), node.types.map((type) => indent(builder.tokenize(type, node)))),
+    ]);
+    return group(shouldIndent ? indent(printed) : printed);
 }
diff --git a/internal/formatter/builders/markdown/blocks/MarkdownCodeBlock.ts b/internal/formatter/builders/markdown/blocks/MarkdownCodeBlock.ts
index eb8667391..db153fd9d 100644
--- a/internal/formatter/builders/markdown/blocks/MarkdownCodeBlock.ts
+++ b/internal/formatter/builders/markdown/blocks/MarkdownCodeBlock.ts
@@ -1,9 +1,5 @@
-import {MarkdownCodeBlock} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function MarkdownCodeBlock(
-	builder: Builder,
-	node: MarkdownCodeBlock,
-): Token {
-	throw new Error("unimplemented");
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function MarkdownCodeBlock(builder: Builder, node: MarkdownCodeBlock): Token {
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/markdown/blocks/MarkdownDividerBlock.ts b/internal/formatter/builders/markdown/blocks/MarkdownDividerBlock.ts
index b2ec3b4ce..8083cea00 100644
--- a/internal/formatter/builders/markdown/blocks/MarkdownDividerBlock.ts
+++ b/internal/formatter/builders/markdown/blocks/MarkdownDividerBlock.ts
@@ -1,9 +1,5 @@
-import {MarkdownDividerBlock} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function MarkdownDividerBlock(
-	builder: Builder,
-	node: MarkdownDividerBlock,
-): Token {
-	return node.value;
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function MarkdownDividerBlock(builder: Builder, node: MarkdownDividerBlock): Token {
+    return node.value;
 }
diff --git a/internal/formatter/builders/markdown/blocks/MarkdownHeadingBlock.ts b/internal/formatter/builders/markdown/blocks/MarkdownHeadingBlock.ts
index c3bc39567..43d757227 100644
--- a/internal/formatter/builders/markdown/blocks/MarkdownHeadingBlock.ts
+++ b/internal/formatter/builders/markdown/blocks/MarkdownHeadingBlock.ts
@@ -1,9 +1,5 @@
-import {MarkdownHeadingBlock} from "@internal/ast";
-import {Builder, Token, concat, hardline, space} from "@internal/formatter";
-
-export default function MarkdownHeadingBlock(
-	builder: Builder,
-	node: MarkdownHeadingBlock,
-): Token {
-	return concat(["#".repeat(node.level), space, node.value, hardline]);
+import {} from "@internal/ast";
+import { Builder, Token, concat, hardline, space } from "@internal/formatter";
+export default function MarkdownHeadingBlock(builder: Builder, node: MarkdownHeadingBlock): Token {
+    return concat(["#".repeat(node.level), space, node.value, hardline]);
 }
diff --git a/internal/formatter/builders/markdown/blocks/MarkdownListBlock.ts b/internal/formatter/builders/markdown/blocks/MarkdownListBlock.ts
index bb17c034d..4987a02f8 100644
--- a/internal/formatter/builders/markdown/blocks/MarkdownListBlock.ts
+++ b/internal/formatter/builders/markdown/blocks/MarkdownListBlock.ts
@@ -1,36 +1,22 @@
-import {MarkdownListBlock} from "@internal/ast";
-import {
-	Builder,
-	Token,
-	Tokens,
-	concat,
-	hardline,
-	space,
-} from "@internal/formatter";
-
-export default function MarkdownListBlock(
-	builder: Builder,
-	node: MarkdownListBlock,
-): Token {
-	const tokens: Tokens = node.children.reduce(
-		(tokens, child, index) => {
-			if (node.ordered) {
-				tokens.push(`${index + 1}.`);
-				tokens.push(space);
-			} else {
-				if (child.value) {
-					tokens.push(`${child.value}`);
-					tokens.push(space);
-				}
-			}
-			tokens.push(builder.tokenize(child, node));
-			if (index + 1 < node.children.length) {
-				tokens.push(hardline);
-			}
-
-			return tokens;
-		},
-		([] as Tokens),
-	);
-	return concat(tokens);
+import {} from "@internal/ast";
+import { Builder, Token, Tokens, concat, hardline, space, } from "@internal/formatter";
+export default function MarkdownListBlock(builder: Builder, node: MarkdownListBlock): Token {
+    const tokens: Tokens = node.children.reduce((tokens, child, index) => {
+        if (node.ordered) {
+            tokens.push(`${index + 1}.`);
+            tokens.push(space);
+        }
+        else {
+            if (child.value) {
+                tokens.push(`${child.value}`);
+                tokens.push(space);
+            }
+        }
+        tokens.push(builder.tokenize(child, node));
+        if (index + 1 < node.children.length) {
+            tokens.push(hardline);
+        }
+        return tokens;
+    }, ([] as Tokens));
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/markdown/blocks/MarkdownQuoteBlock.ts b/internal/formatter/builders/markdown/blocks/MarkdownQuoteBlock.ts
index f6b517017..866a0e7e3 100644
--- a/internal/formatter/builders/markdown/blocks/MarkdownQuoteBlock.ts
+++ b/internal/formatter/builders/markdown/blocks/MarkdownQuoteBlock.ts
@@ -1,9 +1,5 @@
-import {MarkdownQuoteBlock} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function MarkdownQuoteBlock(
-	builder: Builder,
-	node: MarkdownQuoteBlock,
-): Token {
-	throw new Error("unimplemented");
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function MarkdownQuoteBlock(builder: Builder, node: MarkdownQuoteBlock): Token {
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/markdown/core/MarkdownListItem.ts b/internal/formatter/builders/markdown/core/MarkdownListItem.ts
index 854f38377..756ac72b7 100644
--- a/internal/formatter/builders/markdown/core/MarkdownListItem.ts
+++ b/internal/formatter/builders/markdown/core/MarkdownListItem.ts
@@ -1,16 +1,10 @@
-import {MarkdownListItem} from "@internal/ast";
-import {Builder, Token, Tokens, concat} from "@internal/formatter";
-
-export default function MarkdownListItem(
-	builder: Builder,
-	node: MarkdownListItem,
-): Token {
-	const tokens: Tokens = [];
-	if (node.checked !== undefined) {
-		tokens.push(`[${node.checked ? "x" : " "}]`);
-	}
-
-	tokens.push(builder.tokenizeStatementList(node.children, node));
-
-	return concat(tokens);
+import {} from "@internal/ast";
+import { Builder, Token, Tokens, concat } from "@internal/formatter";
+export default function MarkdownListItem(builder: Builder, node: MarkdownListItem): Token {
+    const tokens: Tokens = [];
+    if (node.checked !== undefined) {
+        tokens.push(`[${node.checked ? "x" : " "}]`);
+    }
+    tokens.push(builder.tokenizeStatementList(node.children, node));
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/markdown/core/MarkdownParagraph.ts b/internal/formatter/builders/markdown/core/MarkdownParagraph.ts
index 65b9ca0bd..dbc45e7a8 100644
--- a/internal/formatter/builders/markdown/core/MarkdownParagraph.ts
+++ b/internal/formatter/builders/markdown/core/MarkdownParagraph.ts
@@ -1,12 +1,8 @@
-import {MarkdownParagraph} from "@internal/ast";
-import {Builder, Token, Tokens, concat} from "@internal/formatter";
-
-export default function MarkdownParagraph(
-	builder: Builder,
-	node: MarkdownParagraph,
-): Token {
-	const tokens: Tokens = node.children.map((child) => {
-		return builder.tokenize(child, node);
-	});
-	return concat(tokens);
+import {} from "@internal/ast";
+import { Builder, Token, Tokens, concat } from "@internal/formatter";
+export default function MarkdownParagraph(builder: Builder, node: MarkdownParagraph): Token {
+    const tokens: Tokens = node.children.map((child) => {
+        return builder.tokenize(child, node);
+    });
+    return concat(tokens);
 }
diff --git a/internal/formatter/builders/markdown/core/MarkdownRoot.ts b/internal/formatter/builders/markdown/core/MarkdownRoot.ts
index fdac3bc6a..2cbfb23be 100644
--- a/internal/formatter/builders/markdown/core/MarkdownRoot.ts
+++ b/internal/formatter/builders/markdown/core/MarkdownRoot.ts
@@ -1,9 +1,5 @@
-import {MarkdownRoot} from "@internal/ast";
-import {Builder, Token, concat, hardline} from "@internal/formatter";
-
-export default function MarkdownRoot(
-	builder: Builder,
-	node: MarkdownRoot,
-): Token {
-	return concat([builder.tokenizeStatementList(node.body, node), hardline]);
+import {} from "@internal/ast";
+import { Builder, Token, concat, hardline } from "@internal/formatter";
+export default function MarkdownRoot(builder: Builder, node: MarkdownRoot): Token {
+    return concat([builder.tokenizeStatementList(node.body, node), hardline]);
 }
diff --git a/internal/formatter/builders/markdown/core/MarkdownText.ts b/internal/formatter/builders/markdown/core/MarkdownText.ts
index 4b5c15b84..0febb92a6 100644
--- a/internal/formatter/builders/markdown/core/MarkdownText.ts
+++ b/internal/formatter/builders/markdown/core/MarkdownText.ts
@@ -1,9 +1,5 @@
-import {MarkdownText} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function MarkdownText(
-	builder: Builder,
-	node: MarkdownText,
-): Token {
-	return node.value;
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function MarkdownText(builder: Builder, node: MarkdownText): Token {
+    return node.value;
 }
diff --git a/internal/formatter/builders/markdown/inline/MarkdownAutomaticLinkInline.ts b/internal/formatter/builders/markdown/inline/MarkdownAutomaticLinkInline.ts
index 979566e21..2f58c3885 100644
--- a/internal/formatter/builders/markdown/inline/MarkdownAutomaticLinkInline.ts
+++ b/internal/formatter/builders/markdown/inline/MarkdownAutomaticLinkInline.ts
@@ -1,9 +1,5 @@
-import {MarkdownAutomaticLinkInline} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function MarkdownAutomaticLinkInline(
-	builder: Builder,
-	node: MarkdownAutomaticLinkInline,
-): Token {
-	throw new Error("unimplemented");
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function MarkdownAutomaticLinkInline(builder: Builder, node: MarkdownAutomaticLinkInline): Token {
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/markdown/inline/MarkdownBoldInline.ts b/internal/formatter/builders/markdown/inline/MarkdownBoldInline.ts
index 67cd97fa5..4d81ebd44 100644
--- a/internal/formatter/builders/markdown/inline/MarkdownBoldInline.ts
+++ b/internal/formatter/builders/markdown/inline/MarkdownBoldInline.ts
@@ -1,9 +1,5 @@
-import {MarkdownBoldInline} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function MarkdownBoldInline(
-	builder: Builder,
-	node: MarkdownBoldInline,
-): Token {
-	throw new Error("unimplemented");
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function MarkdownBoldInline(builder: Builder, node: MarkdownBoldInline): Token {
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/markdown/inline/MarkdownCodeInline.ts b/internal/formatter/builders/markdown/inline/MarkdownCodeInline.ts
index 9f8428704..881c35fbb 100644
--- a/internal/formatter/builders/markdown/inline/MarkdownCodeInline.ts
+++ b/internal/formatter/builders/markdown/inline/MarkdownCodeInline.ts
@@ -1,9 +1,5 @@
-import {MarkdownCodeInline} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function MarkdownCodeInline(
-	builder: Builder,
-	node: MarkdownCodeInline,
-): Token {
-	throw new Error("unimplemented");
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function MarkdownCodeInline(builder: Builder, node: MarkdownCodeInline): Token {
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/markdown/inline/MarkdownDefinitionInline.ts b/internal/formatter/builders/markdown/inline/MarkdownDefinitionInline.ts
index db7247433..e82073115 100644
--- a/internal/formatter/builders/markdown/inline/MarkdownDefinitionInline.ts
+++ b/internal/formatter/builders/markdown/inline/MarkdownDefinitionInline.ts
@@ -1,9 +1,5 @@
-import {MarkdownDefinitionInline} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function MarkdownDefinitionInline(
-	builder: Builder,
-	node: MarkdownDefinitionInline,
-): Token {
-	throw new Error("unimplemented");
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function MarkdownDefinitionInline(builder: Builder, node: MarkdownDefinitionInline): Token {
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/markdown/inline/MarkdownEmphasisInline.ts b/internal/formatter/builders/markdown/inline/MarkdownEmphasisInline.ts
index a1630d73a..32be827d7 100644
--- a/internal/formatter/builders/markdown/inline/MarkdownEmphasisInline.ts
+++ b/internal/formatter/builders/markdown/inline/MarkdownEmphasisInline.ts
@@ -1,9 +1,5 @@
-import {MarkdownEmphasisInline} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function MarkdownEmphasisInline(
-	builder: Builder,
-	node: MarkdownEmphasisInline,
-): Token {
-	throw new Error("unimplemented");
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function MarkdownEmphasisInline(builder: Builder, node: MarkdownEmphasisInline): Token {
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/markdown/inline/MarkdownImageInline.ts b/internal/formatter/builders/markdown/inline/MarkdownImageInline.ts
index 6ef463eb1..4dd02047c 100644
--- a/internal/formatter/builders/markdown/inline/MarkdownImageInline.ts
+++ b/internal/formatter/builders/markdown/inline/MarkdownImageInline.ts
@@ -1,9 +1,5 @@
-import {MarkdownImageInline} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function MarkdownImageInline(
-	builder: Builder,
-	node: MarkdownImageInline,
-): Token {
-	throw new Error("unimplemented");
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function MarkdownImageInline(builder: Builder, node: MarkdownImageInline): Token {
+    throw new Error("unimplemented");
 }
diff --git a/internal/formatter/builders/markdown/inline/MarkdownLinkInline.ts b/internal/formatter/builders/markdown/inline/MarkdownLinkInline.ts
index ed267df6e..319785ccf 100644
--- a/internal/formatter/builders/markdown/inline/MarkdownLinkInline.ts
+++ b/internal/formatter/builders/markdown/inline/MarkdownLinkInline.ts
@@ -1,9 +1,5 @@
-import {MarkdownLinkInline} from "@internal/ast";
-import {Builder, Token} from "@internal/formatter";
-
-export default function MarkdownLinkInline(
-	builder: Builder,
-	node: MarkdownLinkInline,
-): Token {
-	throw new Error("unimplemented");
+import {} from "@internal/ast";
+import { Builder, Token } from "@internal/formatter";
+export default function MarkdownLinkInline(builder: Builder, node: MarkdownLinkInline): Token {
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/auxiliary/JSArrayHole.ts b/internal/js-analysis/evaluators/auxiliary/JSArrayHole.ts
index 574b55c0c..512f3a061 100644
--- a/internal/js-analysis/evaluators/auxiliary/JSArrayHole.ts
+++ b/internal/js-analysis/evaluators/auxiliary/JSArrayHole.ts
@@ -4,10 +4,8 @@
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
-
-import {AnyNode, JSArrayHole, jsArrayHole} from "@internal/ast";
-
+import { AnyNode, jsArrayHole } from "@internal/ast";
 export default function JSArrayHole(node: AnyNode) {
-	node = jsArrayHole.assert(node);
-	throw new Error("unimplemented");
+    node = jsArrayHole.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/auxiliary/JSCatchClause.ts b/internal/js-analysis/evaluators/auxiliary/JSCatchClause.ts
index a9b8da766..7d1edc5c5 100644
--- a/internal/js-analysis/evaluators/auxiliary/JSCatchClause.ts
+++ b/internal/js-analysis/evaluators/auxiliary/JSCatchClause.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSCatchClause, jsCatchClause} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsCatchClause } from "@internal/ast";
 export default function JSCatchClause(node: AnyNode, scope: Scope) {
-	node = jsCatchClause.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsCatchClause.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/auxiliary/JSComputedMemberProperty.ts b/internal/js-analysis/evaluators/auxiliary/JSComputedMemberProperty.ts
index faf02e043..3232a4400 100644
--- a/internal/js-analysis/evaluators/auxiliary/JSComputedMemberProperty.ts
+++ b/internal/js-analysis/evaluators/auxiliary/JSComputedMemberProperty.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSComputedMemberProperty,
-	jsComputedMemberProperty,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsComputedMemberProperty, } from "@internal/ast";
 export default function JSComputedMemberProperty(node: AnyNode, scope: Scope) {
-	node = jsComputedMemberProperty.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsComputedMemberProperty.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/auxiliary/JSFunctionHead.ts b/internal/js-analysis/evaluators/auxiliary/JSFunctionHead.ts
index 0435a4f17..df0ef7062 100644
--- a/internal/js-analysis/evaluators/auxiliary/JSFunctionHead.ts
+++ b/internal/js-analysis/evaluators/auxiliary/JSFunctionHead.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSFunctionHead, jsFunctionHead} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsFunctionHead } from "@internal/ast";
 export default function JSFunctionHead(node: AnyNode, scope: Scope) {
-	node = jsFunctionHead.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsFunctionHead.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/auxiliary/JSIdentifier.ts b/internal/js-analysis/evaluators/auxiliary/JSIdentifier.ts
index 6d33e8501..b3e679e11 100644
--- a/internal/js-analysis/evaluators/auxiliary/JSIdentifier.ts
+++ b/internal/js-analysis/evaluators/auxiliary/JSIdentifier.ts
@@ -4,51 +4,48 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSIdentifier, jsIdentifier} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsIdentifier } from "@internal/ast";
 import UndeclaredVarE from "../../types/errors/UndeclaredVarE";
 import OpenT from "../../types/OpenT";
 import AnyT from "../../types/AnyT";
-
 export default function JSIdentifier(node: AnyNode, scope: Scope) {
-	node = jsIdentifier.assert(node);
-
-	const binding = scope.getBinding(node.name);
-	if (binding) {
-		const type = new OpenT(scope, node);
-		type.shouldMatch(binding);
-		return type;
-	} else {
-		switch (node.name) {
-			case "React$PropType$Primitive":
-			case "React$PropType$ArrayOf":
-			case "React$PropType$InstanceOf":
-			case "React$PropType$ObjectOf":
-			case "React$PropType$OneOf":
-			case "React$PropType$OneOfType":
-			case "React$PropTypePartial":
-			case "React$ElementProps":
-			case "React$ElementRef":
-			case "$Exact":
-			case "Partial":
-			case "$Keys":
-			case "Object$Assign":
-			case "Object$GetPrototypeOf":
-			case "Object$SetPrototypeOf":
-			case "$CharSet":
-			case "Class":
-			case "$Compose":
-			case "$ComposeReverse":
-			case "$Subtype":
-			case "Function$Prototype$Apply":
-			case "Function$Prototype$Bind":
-			case "Function$Prototype$Call":
-			case "$Exports":
-				return new AnyT(scope, node);
-
-			default:
-				return new UndeclaredVarE(scope, node, node.name);
-		}
-	}
+    node = jsIdentifier.assert(node);
+    const binding = scope.getBinding(node.name);
+    if (binding) {
+        const type = new OpenT(scope, node);
+        type.shouldMatch(binding);
+        return type;
+    }
+    else {
+        switch (node.name) {
+            case "React$PropType$Primitive":
+            case "React$PropType$ArrayOf":
+            case "React$PropType$InstanceOf":
+            case "React$PropType$ObjectOf":
+            case "React$PropType$OneOf":
+            case "React$PropType$OneOfType":
+            case "React$PropTypePartial":
+            case "React$ElementProps":
+            case "React$ElementRef":
+            case "$Exact":
+            case "Partial":
+            case "$Keys":
+            case "Object$Assign":
+            case "Object$GetPrototypeOf":
+            case "Object$SetPrototypeOf":
+            case "$CharSet":
+            case "Class":
+            case "$Compose":
+            case "$ComposeReverse":
+            case "$Subtype":
+            case "Function$Prototype$Apply":
+            case "Function$Prototype$Bind":
+            case "Function$Prototype$Call":
+            case "$Exports":
+                return new AnyT(scope, node);
+            default:
+                return new UndeclaredVarE(scope, node, node.name);
+        }
+    }
 }
diff --git a/internal/js-analysis/evaluators/auxiliary/JSSpreadElement.ts b/internal/js-analysis/evaluators/auxiliary/JSSpreadElement.ts
index 8d97d25fd..71a73a1ec 100644
--- a/internal/js-analysis/evaluators/auxiliary/JSSpreadElement.ts
+++ b/internal/js-analysis/evaluators/auxiliary/JSSpreadElement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSSpreadElement, jsSpreadElement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsSpreadElement } from "@internal/ast";
 export default function JSSpreadElement(node: AnyNode, scope: Scope) {
-	node = jsSpreadElement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsSpreadElement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/auxiliary/JSStaticMemberProperty.ts b/internal/js-analysis/evaluators/auxiliary/JSStaticMemberProperty.ts
index 3f90a1db1..ce11ea7b6 100644
--- a/internal/js-analysis/evaluators/auxiliary/JSStaticMemberProperty.ts
+++ b/internal/js-analysis/evaluators/auxiliary/JSStaticMemberProperty.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSStaticMemberProperty,
-	jsStaticMemberProperty,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsStaticMemberProperty, } from "@internal/ast";
 export default function JSStaticMemberProperty(node: AnyNode, scope: Scope) {
-	node = jsStaticMemberProperty.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsStaticMemberProperty.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/auxiliary/JSSwitchCase.ts b/internal/js-analysis/evaluators/auxiliary/JSSwitchCase.ts
index 02ec15837..fb24b1fe3 100644
--- a/internal/js-analysis/evaluators/auxiliary/JSSwitchCase.ts
+++ b/internal/js-analysis/evaluators/auxiliary/JSSwitchCase.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSSwitchCase, jsSwitchCase} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsSwitchCase } from "@internal/ast";
 export default function JSSwitchCase(node: AnyNode, scope: Scope) {
-	node = jsSwitchCase.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsSwitchCase.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/auxiliary/JSTemplateElement.ts b/internal/js-analysis/evaluators/auxiliary/JSTemplateElement.ts
index 36896058f..5c6201f1c 100644
--- a/internal/js-analysis/evaluators/auxiliary/JSTemplateElement.ts
+++ b/internal/js-analysis/evaluators/auxiliary/JSTemplateElement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSTemplateElement, jsTemplateElement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsTemplateElement } from "@internal/ast";
 export default function JSTemplateElement(node: AnyNode, scope: Scope) {
-	node = jsTemplateElement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsTemplateElement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/auxiliary/JSVariableDeclaration.ts b/internal/js-analysis/evaluators/auxiliary/JSVariableDeclaration.ts
index 3787e7abb..ef03ed5b1 100644
--- a/internal/js-analysis/evaluators/auxiliary/JSVariableDeclaration.ts
+++ b/internal/js-analysis/evaluators/auxiliary/JSVariableDeclaration.ts
@@ -4,39 +4,29 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSVariableDeclaration,
-	jsVariableDeclaration,
-} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsVariableDeclaration, } from "@internal/ast";
 import OpenT from "../../types/OpenT";
 import VoidT from "../../types/VoidT";
 import executeAtom from "../../utils/executeAtom";
-
 export default function JSVariableDeclaration(node: AnyNode, scope: Scope) {
-	node = jsVariableDeclaration.assert(node);
-
-	for (const declarator of node.declarations) {
-		const {id, init} = declarator;
-		let inferredType;
-
-		if (init === undefined) {
-			inferredType = new OpenT(scope, declarator);
-			inferredType.shouldMatch(new VoidT(scope, declarator));
-		} else {
-			inferredType = scope.evaluate(init);
-		}
-
-		let actualType = inferredType;
-
-		if (id.meta !== undefined && id.meta.typeAnnotation !== undefined) {
-			const annotatedType = scope.evaluate(id.meta.typeAnnotation);
-			inferredType.shouldMatch(annotatedType);
-			actualType = annotatedType;
-		}
-
-		executeAtom(id, actualType, scope);
-	}
+    node = jsVariableDeclaration.assert(node);
+    for (const declarator of node.declarations) {
+        const { id, init } = declarator;
+        let inferredType;
+        if (init === undefined) {
+            inferredType = new OpenT(scope, declarator);
+            inferredType.shouldMatch(new VoidT(scope, declarator));
+        }
+        else {
+            inferredType = scope.evaluate(init);
+        }
+        let actualType = inferredType;
+        if (id.meta !== undefined && id.meta.typeAnnotation !== undefined) {
+            const annotatedType = scope.evaluate(id.meta.typeAnnotation);
+            inferredType.shouldMatch(annotatedType);
+            actualType = annotatedType;
+        }
+        executeAtom(id, actualType, scope);
+    }
 }
diff --git a/internal/js-analysis/evaluators/auxiliary/JSVariableDeclarator.ts b/internal/js-analysis/evaluators/auxiliary/JSVariableDeclarator.ts
index 6c2cee4ee..2d45a8f74 100644
--- a/internal/js-analysis/evaluators/auxiliary/JSVariableDeclarator.ts
+++ b/internal/js-analysis/evaluators/auxiliary/JSVariableDeclarator.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSVariableDeclarator,
-	jsVariableDeclarator,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsVariableDeclarator, } from "@internal/ast";
 export default function JSVariableDeclarator(node: AnyNode, scope: Scope) {
-	node = jsVariableDeclarator.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsVariableDeclarator.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/classes/JSClassDeclaration.ts b/internal/js-analysis/evaluators/classes/JSClassDeclaration.ts
index 6f0178583..4be362ae3 100644
--- a/internal/js-analysis/evaluators/classes/JSClassDeclaration.ts
+++ b/internal/js-analysis/evaluators/classes/JSClassDeclaration.ts
@@ -4,16 +4,14 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSClassDeclaration, jsClassDeclaration} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsClassDeclaration } from "@internal/ast";
 import JSClassExpression from "./JSClassExpression";
-
 export default function JSClassDeclaration(node: AnyNode, scope: Scope) {
-	node = jsClassDeclaration.assert(node);
-	const type = JSClassExpression(node, scope);
-	if (node.id) {
-		scope.addBinding(node.id.name, type);
-	}
-	return type;
+    node = jsClassDeclaration.assert(node);
+    const type = JSClassExpression(node, scope);
+    if (node.id) {
+        scope.addBinding(node.id.name, type);
+    }
+    return type;
 }
diff --git a/internal/js-analysis/evaluators/classes/JSClassExpression.ts b/internal/js-analysis/evaluators/classes/JSClassExpression.ts
index af2f6609a..241c0dc8e 100644
--- a/internal/js-analysis/evaluators/classes/JSClassExpression.ts
+++ b/internal/js-analysis/evaluators/classes/JSClassExpression.ts
@@ -4,83 +4,64 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {ClassScope, Scope} from "../../scopes";
-import {AnyNode, JSClassExpression, jsClassExpression} from "@internal/ast";
+import { ClassScope, Scope } from "../../scopes";
+import { AnyNode, jsClassExpression } from "@internal/ast";
 import InstanceT from "../../types/InstanceT";
 import ClassT from "../../types/ClassT";
 import T from "../../types/T";
 import OpenT from "../../types/OpenT";
-import {markup} from "@internal/markup";
-
+import { markup } from "@internal/markup";
 export default function JSClassExpression(node: AnyNode, scope: Scope) {
-	node =
-		node.type === "JSClassDeclaration" ? node : jsClassExpression.assert(node);
-
-	const instances = [];
-	const statics = [];
-
-	//
-	const classInstance = new OpenT(scope, node);
-	const classId = new OpenT(scope, node);
-
-	//
-	const bodyScope = new ClassScope(
-		{parentScope: scope},
-		{
-			instance: classInstance,
-			static: classId,
-		},
-	);
-
-	if (node.id !== undefined) {
-		bodyScope.addBinding(node.id.name, classId);
-	}
-
-	if (node.meta.typeParameters !== undefined) {
-		bodyScope.evaluate(node.meta.typeParameters);
-	}
-
-	let _constructor: undefined | T = undefined;
-
-	for (const bodyNode of node.meta.body) {
-		const type = bodyScope.evaluate(bodyNode);
-
-		if (bodyNode.type === "JSClassMethod" && bodyNode.kind === "constructor") {
-			_constructor = type;
-		} else {
-			if (bodyNode.type !== "TSIndexSignature" && bodyNode.meta.static === true) {
-				statics.push(type);
-			} else {
-				instances.push(type);
-			}
-		}
-	}
-
-	//
-	const classOrigin = node.id ? node.id : node;
-	let type = new ClassT(
-		scope,
-		classOrigin,
-		{
-			_constructor,
-			instances,
-			statics,
-			extends: node.meta.superClass
-				? scope.evaluate(node.meta.superClass)
-				: undefined,
-		},
-	);
-	if (node.id) {
-		type.setHuman(markup`${node.id.name}`);
-	}
-
-	//
-	classId.shouldMatch(type);
-
-	//
-	const instance = new InstanceT(scope, classOrigin, type, []);
-	classInstance.shouldMatch(instance);
-
-	return type;
+    node =
+        node.type === "JSClassDeclaration" ? node : jsClassExpression.assert(node);
+    const instances = [];
+    const statics = [];
+    //
+    const classInstance = new OpenT(scope, node);
+    const classId = new OpenT(scope, node);
+    //
+    const bodyScope = new ClassScope({ parentScope: scope }, {
+        instance: classInstance,
+        static: classId
+    });
+    if (node.id !== undefined) {
+        bodyScope.addBinding(node.id.name, classId);
+    }
+    if (node.meta.typeParameters !== undefined) {
+        bodyScope.evaluate(node.meta.typeParameters);
+    }
+    let _constructor: undefined | T = undefined;
+    for (const bodyNode of node.meta.body) {
+        const type = bodyScope.evaluate(bodyNode);
+        if (bodyNode.type === "JSClassMethod" && bodyNode.kind === "constructor") {
+            _constructor = type;
+        }
+        else {
+            if (bodyNode.type !== "TSIndexSignature" && bodyNode.meta.static === true) {
+                statics.push(type);
+            }
+            else {
+                instances.push(type);
+            }
+        }
+    }
+    //
+    const classOrigin = node.id ? node.id : node;
+    let type = new ClassT(scope, classOrigin, {
+        _constructor,
+        instances,
+        statics,
+        extends: node.meta.superClass
+            ? scope.evaluate(node.meta.superClass)
+            : undefined
+    });
+    if (node.id) {
+        type.setHuman(markup `${node.id.name}`);
+    }
+    //
+    classId.shouldMatch(type);
+    //
+    const instance = new InstanceT(scope, classOrigin, type, []);
+    classInstance.shouldMatch(instance);
+    return type;
 }
diff --git a/internal/js-analysis/evaluators/classes/JSClassHead.ts b/internal/js-analysis/evaluators/classes/JSClassHead.ts
index deef1b7fb..04b4a5aed 100644
--- a/internal/js-analysis/evaluators/classes/JSClassHead.ts
+++ b/internal/js-analysis/evaluators/classes/JSClassHead.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSClassHead, jsClassHead} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsClassHead } from "@internal/ast";
 export default function JSClassHead(node: AnyNode, scope: Scope) {
-	node = jsClassHead.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsClassHead.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/classes/JSClassMethod.ts b/internal/js-analysis/evaluators/classes/JSClassMethod.ts
index a17c5f8e5..f2f91c619 100644
--- a/internal/js-analysis/evaluators/classes/JSClassMethod.ts
+++ b/internal/js-analysis/evaluators/classes/JSClassMethod.ts
@@ -4,28 +4,23 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {ClassScope, Scope} from "../../scopes";
-import {AnyNode, JSClassMethod, jsClassMethod} from "@internal/ast";
+import { ClassScope, Scope } from "../../scopes";
+import { AnyNode, jsClassMethod } from "@internal/ast";
 import ObjPropT from "../../types/ObjPropT";
 import executeFunction from "../../utils/executeFunction";
-
 export default function JSClassMethod(node: AnyNode, scope: Scope) {
-	node = jsClassMethod.assert(node);
-	if (node.key.type === "JSComputedPropertyKey") {
-		// TODO
-		return undefined;
-	}
-
-	const classScope = scope.find(ClassScope);
-	const thisContext =
-		node.meta.static === true
-			? classScope.meta.static
-			: classScope.meta.instance;
-	const func = executeFunction(node, scope, false, thisContext);
-
-	if (node.key.value.type !== "JSIdentifier") {
-		throw new Error("Expected only an jsIdentifier key");
-	}
-	return new ObjPropT(scope, node, node.key.value.name, func);
+    node = jsClassMethod.assert(node);
+    if (node.key.type === "JSComputedPropertyKey") {
+        // TODO
+        return undefined;
+    }
+    const classScope = scope.find(ClassScope);
+    const thisContext = node.meta.static === true
+        ? classScope.meta.static
+        : classScope.meta.instance;
+    const func = executeFunction(node, scope, false, thisContext);
+    if (node.key.value.type !== "JSIdentifier") {
+        throw new Error("Expected only an jsIdentifier key");
+    }
+    return new ObjPropT(scope, node, node.key.value.name, func);
 }
diff --git a/internal/js-analysis/evaluators/classes/JSClassPrivateMethod.ts b/internal/js-analysis/evaluators/classes/JSClassPrivateMethod.ts
index d096c61e9..84030c824 100644
--- a/internal/js-analysis/evaluators/classes/JSClassPrivateMethod.ts
+++ b/internal/js-analysis/evaluators/classes/JSClassPrivateMethod.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSClassPrivateMethod,
-	jsClassPrivateMethod,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsClassPrivateMethod, } from "@internal/ast";
 export default function JSClassPrivateMethod(node: AnyNode, scope: Scope) {
-	node = jsClassPrivateMethod.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsClassPrivateMethod.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/classes/JSClassPrivateProperty.ts b/internal/js-analysis/evaluators/classes/JSClassPrivateProperty.ts
index dc7303ef7..002ca6183 100644
--- a/internal/js-analysis/evaluators/classes/JSClassPrivateProperty.ts
+++ b/internal/js-analysis/evaluators/classes/JSClassPrivateProperty.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSClassPrivateProperty,
-	jsClassPrivateProperty,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsClassPrivateProperty, } from "@internal/ast";
 export default function JSClassPrivateProperty(node: AnyNode, scope: Scope) {
-	node = jsClassPrivateProperty.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsClassPrivateProperty.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/classes/JSClassProperty.ts b/internal/js-analysis/evaluators/classes/JSClassProperty.ts
index 67c5c0ad8..8449b4557 100644
--- a/internal/js-analysis/evaluators/classes/JSClassProperty.ts
+++ b/internal/js-analysis/evaluators/classes/JSClassProperty.ts
@@ -4,54 +4,39 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {ClassScope, Scope, ThisScope} from "../../scopes";
-import {AnyNode, JSClassProperty, jsClassProperty} from "@internal/ast";
+import { ClassScope, Scope, ThisScope } from "../../scopes";
+import { AnyNode, jsClassProperty } from "@internal/ast";
 import AnyT from "../../types/AnyT";
 import ObjPropT from "../../types/ObjPropT";
-
 export default function JSClassProperty(node: AnyNode, scope: Scope) {
-	node = jsClassProperty.assert(node);
-
-	if (node.key.type === "JSComputedPropertyKey") {
-		// TODO
-		return undefined;
-	}
-
-	const classScope = scope.find(ClassScope);
-	const funcScope = new ThisScope(
-		{parentScope: scope},
-		classScope.meta.instance,
-	);
-
-	let annotatedType;
-	let inferredType;
-
-	if (node.typeAnnotation) {
-		annotatedType = funcScope.evaluate(node.typeAnnotation);
-	}
-
-	if (node.value) {
-		inferredType = funcScope.evaluate(node.value);
-
-		if (annotatedType !== undefined) {
-			inferredType.shouldMatch(annotatedType);
-		}
-	}
-
-	if (annotatedType === undefined && inferredType === undefined) {
-		// TODO what do we do here?
-		inferredType = new AnyT(scope, node);
-	}
-
-	const actualValue = annotatedType === undefined ? inferredType : annotatedType;
-	if (actualValue === undefined) {
-		throw new Error("Expected actual value");
-	}
-
-	if (node.key.value.type !== "JSIdentifier") {
-		throw new Error("Expected only an jsIdentifier key");
-	}
-
-	return new ObjPropT(scope, node, node.key.value.name, actualValue);
+    node = jsClassProperty.assert(node);
+    if (node.key.type === "JSComputedPropertyKey") {
+        // TODO
+        return undefined;
+    }
+    const classScope = scope.find(ClassScope);
+    const funcScope = new ThisScope({ parentScope: scope }, classScope.meta.instance);
+    let annotatedType;
+    let inferredType;
+    if (node.typeAnnotation) {
+        annotatedType = funcScope.evaluate(node.typeAnnotation);
+    }
+    if (node.value) {
+        inferredType = funcScope.evaluate(node.value);
+        if (annotatedType !== undefined) {
+            inferredType.shouldMatch(annotatedType);
+        }
+    }
+    if (annotatedType === undefined && inferredType === undefined) {
+        // TODO what do we do here?
+        inferredType = new AnyT(scope, node);
+    }
+    const actualValue = annotatedType === undefined ? inferredType : annotatedType;
+    if (actualValue === undefined) {
+        throw new Error("Expected actual value");
+    }
+    if (node.key.value.type !== "JSIdentifier") {
+        throw new Error("Expected only an jsIdentifier key");
+    }
+    return new ObjPropT(scope, node, node.key.value.name, actualValue);
 }
diff --git a/internal/js-analysis/evaluators/classes/JSClassPropertyMeta.ts b/internal/js-analysis/evaluators/classes/JSClassPropertyMeta.ts
index 9721796e9..392a83424 100644
--- a/internal/js-analysis/evaluators/classes/JSClassPropertyMeta.ts
+++ b/internal/js-analysis/evaluators/classes/JSClassPropertyMeta.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSClassPropertyMeta, jsClassPropertyMeta} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsClassPropertyMeta } from "@internal/ast";
 export default function JSClassPropertyMeta(node: AnyNode, scope: Scope) {
-	node = jsClassPropertyMeta.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsClassPropertyMeta.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/classes/JSPrivateName.ts b/internal/js-analysis/evaluators/classes/JSPrivateName.ts
index 21a4f1222..1c682e98d 100644
--- a/internal/js-analysis/evaluators/classes/JSPrivateName.ts
+++ b/internal/js-analysis/evaluators/classes/JSPrivateName.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSPrivateName, jsPrivateName} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsPrivateName } from "@internal/ast";
 export default function JSPrivateName(node: AnyNode, scope: Scope) {
-	node = jsPrivateName.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsPrivateName.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/core/JSDirective.ts b/internal/js-analysis/evaluators/core/JSDirective.ts
index eb746fdb3..c79759ed1 100644
--- a/internal/js-analysis/evaluators/core/JSDirective.ts
+++ b/internal/js-analysis/evaluators/core/JSDirective.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSDirective, jsDirective} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsDirective } from "@internal/ast";
 export default function JSDirective(node: AnyNode, scope: Scope) {
-	node = jsDirective.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsDirective.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/core/JSInterpreterDirective.ts b/internal/js-analysis/evaluators/core/JSInterpreterDirective.ts
index 8868c7bf1..b278d9dfb 100644
--- a/internal/js-analysis/evaluators/core/JSInterpreterDirective.ts
+++ b/internal/js-analysis/evaluators/core/JSInterpreterDirective.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSInterpreterDirective,
-	jsInterpreterDirective,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsInterpreterDirective, } from "@internal/ast";
 export default function JSInterpreterDirective(node: AnyNode, scope: Scope) {
-	node = jsInterpreterDirective.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsInterpreterDirective.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/core/JSRoot.ts b/internal/js-analysis/evaluators/core/JSRoot.ts
index aaa0fb18d..8c6778f3c 100644
--- a/internal/js-analysis/evaluators/core/JSRoot.ts
+++ b/internal/js-analysis/evaluators/core/JSRoot.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSRoot, jsRoot} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsRoot } from "@internal/ast";
 import JSBlockStatement from "../statements/JSBlockStatement";
-
 export default function JSRoot(node: AnyNode, scope: Scope) {
-	node = jsRoot.assert(node);
-	JSBlockStatement(node, scope);
+    node = jsRoot.assert(node);
+    JSBlockStatement(node, scope);
 }
diff --git a/internal/js-analysis/evaluators/expressions/JSArrayExpression.ts b/internal/js-analysis/evaluators/expressions/JSArrayExpression.ts
index ebbdf0ea5..5f2338a7b 100644
--- a/internal/js-analysis/evaluators/expressions/JSArrayExpression.ts
+++ b/internal/js-analysis/evaluators/expressions/JSArrayExpression.ts
@@ -4,29 +4,27 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSArrayExpression, jsArrayExpression} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsArrayExpression } from "@internal/ast";
 import InstanceT from "../../types/InstanceT";
 import OpenT from "../../types/OpenT";
-
 export default function JSArrayExpression(node: AnyNode, scope: Scope) {
-	node = jsArrayExpression.assert(node);
-	const elems = [];
-
-	for (const expr of node.elements) {
-		if (expr === undefined) {
-			// TODO array hole, add undefined here
-		} else {
-			elems.push(scope.evaluate(expr));
-		}
-	}
-
-	let value;
-	if (elems.length === 0) {
-		value = new OpenT(scope, node);
-	} else {
-		value = scope.createUnion(elems, node);
-	}
-	return new InstanceT(scope, node, scope.intrinsics.Array, [value]);
+    node = jsArrayExpression.assert(node);
+    const elems = [];
+    for (const expr of node.elements) {
+        if (expr === undefined) {
+            // TODO array hole, add undefined here
+        }
+        else {
+            elems.push(scope.evaluate(expr));
+        }
+    }
+    let value;
+    if (elems.length === 0) {
+        value = new OpenT(scope, node);
+    }
+    else {
+        value = scope.createUnion(elems, node);
+    }
+    return new InstanceT(scope, node, scope.intrinsics.Array, [value]);
 }
diff --git a/internal/js-analysis/evaluators/expressions/JSArrowFunctionExpression.ts b/internal/js-analysis/evaluators/expressions/JSArrowFunctionExpression.ts
index 86886fbee..595fcee5b 100644
--- a/internal/js-analysis/evaluators/expressions/JSArrowFunctionExpression.ts
+++ b/internal/js-analysis/evaluators/expressions/JSArrowFunctionExpression.ts
@@ -4,23 +4,15 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {FunctionScope, Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSArrowFunctionExpression,
-	jsArrowFunctionExpression,
-} from "@internal/ast";
+import { FunctionScope, Scope } from "../../scopes";
+import { AnyNode, jsArrowFunctionExpression, } from "@internal/ast";
 import executeFunction from "../../utils/executeFunction";
-
 export default function JSArrowFunctionExpression(node: AnyNode, scope: Scope) {
-	node = jsArrowFunctionExpression.assert(node);
-
-	let thisContext;
-	const funcScope = scope.findOptional(FunctionScope);
-	if (funcScope !== undefined) {
-		thisContext = funcScope.meta.thisContext;
-	}
-
-	return executeFunction(node, scope, true, thisContext);
+    node = jsArrowFunctionExpression.assert(node);
+    let thisContext;
+    const funcScope = scope.findOptional(FunctionScope);
+    if (funcScope !== undefined) {
+        thisContext = funcScope.meta.thisContext;
+    }
+    return executeFunction(node, scope, true, thisContext);
 }
diff --git a/internal/js-analysis/evaluators/expressions/JSCallExpression.ts b/internal/js-analysis/evaluators/expressions/JSCallExpression.ts
index 44d31f9a2..bff9fa042 100644
--- a/internal/js-analysis/evaluators/expressions/JSCallExpression.ts
+++ b/internal/js-analysis/evaluators/expressions/JSCallExpression.ts
@@ -4,20 +4,12 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSCallExpression, jsCallExpression} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsCallExpression } from "@internal/ast";
 import CallT from "../../types/CallT";
-
 export default function JSCallExpression(node: AnyNode, scope: Scope) {
-	node = jsCallExpression.assert(node);
-
-	return new CallT(
-		scope,
-		node,
-		scope.evaluate(node.callee),
-		node.arguments.map((arg) => {
-			return scope.evaluate(arg);
-		}),
-	);
+    node = jsCallExpression.assert(node);
+    return new CallT(scope, node, scope.evaluate(node.callee), node.arguments.map((arg) => {
+        return scope.evaluate(arg);
+    }));
 }
diff --git a/internal/js-analysis/evaluators/expressions/JSDoExpression.ts b/internal/js-analysis/evaluators/expressions/JSDoExpression.ts
index 96e4863f0..2df3a2d0e 100644
--- a/internal/js-analysis/evaluators/expressions/JSDoExpression.ts
+++ b/internal/js-analysis/evaluators/expressions/JSDoExpression.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSDoExpression, jsDoExpression} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsDoExpression } from "@internal/ast";
 export default function JSDoExpression(node: AnyNode, scope: Scope) {
-	node = jsDoExpression.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsDoExpression.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/expressions/JSFunctionExpression.ts b/internal/js-analysis/evaluators/expressions/JSFunctionExpression.ts
index c652c5dd7..bc33bdc6e 100644
--- a/internal/js-analysis/evaluators/expressions/JSFunctionExpression.ts
+++ b/internal/js-analysis/evaluators/expressions/JSFunctionExpression.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSFunctionExpression,
-	jsFunctionExpression,
-} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsFunctionExpression, } from "@internal/ast";
 import executeFunction from "../../utils/executeFunction";
-
 export default function JSFunctionExpression(node: AnyNode, scope: Scope) {
-	node = jsFunctionExpression.assert(node);
-	return executeFunction(node, scope, true);
+    node = jsFunctionExpression.assert(node);
+    return executeFunction(node, scope, true);
 }
diff --git a/internal/js-analysis/evaluators/expressions/JSLogicalExpression.ts b/internal/js-analysis/evaluators/expressions/JSLogicalExpression.ts
index da5b575c4..aa8b21af3 100644
--- a/internal/js-analysis/evaluators/expressions/JSLogicalExpression.ts
+++ b/internal/js-analysis/evaluators/expressions/JSLogicalExpression.ts
@@ -4,54 +4,45 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSLogicalExpression, jsLogicalExpression} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsLogicalExpression } from "@internal/ast";
 import T from "../../types/T";
 import UnionT from "../../types/UnionT";
-
 function uniq(args: Array<string>): Array<string> {
-	return [...new Set(args)];
+    return [...new Set(args)];
 }
-
 export default function JSLogicalExpression(node: AnyNode, scope: Scope) {
-	node = jsLogicalExpression.assert(node);
-
-	switch (node.operator) {
-		case "||": {
-			const left = scope.refine().evaluate(node.left);
-			const right = scope.refine().evaluate(node.right);
-
-			// create a new scope that has unions of all the refined bindings
-			const refinedScope = scope.refine();
-			const refinedNames = uniq([
-				...left.scope.getOwnBindingNames(),
-				...right.scope.getOwnBindingNames(),
-			]);
-			const mergeScopes = [left.scope, right.scope];
-			for (const name of refinedNames) {
-				const rawTypes: Set<T> = new Set();
-				for (const scope of mergeScopes) {
-					const binding = scope.getBinding(name);
-					if (binding !== undefined) {
-						rawTypes.add(binding);
-					}
-				}
-
-				const types = Array.from(rawTypes);
-				refinedScope.addBinding(name, refinedScope.createUnion(types));
-			}
-
-			return new UnionT(refinedScope, node, [left, right]);
-		}
-
-		case "&&": {
-			const left = scope.evaluate(node.left);
-			const right = left.scope.evaluate(node.right);
-			return new UnionT(right.scope, node, [left, right]);
-		}
-
-		default:
-			throw new Error("Unknown operator");
-	}
+    node = jsLogicalExpression.assert(node);
+    switch (node.operator) {
+        case "||": {
+            const left = scope.refine().evaluate(node.left);
+            const right = scope.refine().evaluate(node.right);
+            // create a new scope that has unions of all the refined bindings
+            const refinedScope = scope.refine();
+            const refinedNames = uniq([
+                ...left.scope.getOwnBindingNames(),
+                ...right.scope.getOwnBindingNames(),
+            ]);
+            const mergeScopes = [left.scope, right.scope];
+            for (const name of refinedNames) {
+                const rawTypes: Set<T> = new Set();
+                for (const scope of mergeScopes) {
+                    const binding = scope.getBinding(name);
+                    if (binding !== undefined) {
+                        rawTypes.add(binding);
+                    }
+                }
+                const types = Array.from(rawTypes);
+                refinedScope.addBinding(name, refinedScope.createUnion(types));
+            }
+            return new UnionT(refinedScope, node, [left, right]);
+        }
+        case "&&": {
+            const left = scope.evaluate(node.left);
+            const right = left.scope.evaluate(node.right);
+            return new UnionT(right.scope, node, [left, right]);
+        }
+        default:
+            throw new Error("Unknown operator");
+    }
 }
diff --git a/internal/js-analysis/evaluators/expressions/JSMemberExpression.ts b/internal/js-analysis/evaluators/expressions/JSMemberExpression.ts
index 43da074f0..19871c016 100644
--- a/internal/js-analysis/evaluators/expressions/JSMemberExpression.ts
+++ b/internal/js-analysis/evaluators/expressions/JSMemberExpression.ts
@@ -4,26 +4,18 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSMemberExpression, jsMemberExpression} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsMemberExpression } from "@internal/ast";
 import StringLiteralT from "../../types/StringLiteralT";
 import GetPropT from "../../types/GetPropT";
-
 export default function JSMemberExpression(node: AnyNode, scope: Scope) {
-	node = jsMemberExpression.assert(node);
-	if (node.property.type === "JSComputedMemberProperty") {
-		throw new Error("Computed properties not supportd yet");
-	}
-
-	if (node.property.value.type === "JSPrivateName") {
-		throw new Error("PrivateName in static member not supported yet");
-	}
-
-	const prop = new StringLiteralT(
-		scope,
-		node.property.value,
-		node.property.value.name,
-	);
-	return new GetPropT(scope, node, scope.evaluate(node.object), prop);
+    node = jsMemberExpression.assert(node);
+    if (node.property.type === "JSComputedMemberProperty") {
+        throw new Error("Computed properties not supportd yet");
+    }
+    if (node.property.value.type === "JSPrivateName") {
+        throw new Error("PrivateName in static member not supported yet");
+    }
+    const prop = new StringLiteralT(scope, node.property.value, node.property.value.name);
+    return new GetPropT(scope, node, scope.evaluate(node.object), prop);
 }
diff --git a/internal/js-analysis/evaluators/expressions/JSMetaProperty.ts b/internal/js-analysis/evaluators/expressions/JSMetaProperty.ts
index 6ed0b1d1b..1e648ff6d 100644
--- a/internal/js-analysis/evaluators/expressions/JSMetaProperty.ts
+++ b/internal/js-analysis/evaluators/expressions/JSMetaProperty.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSMetaProperty, jsMetaProperty} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsMetaProperty } from "@internal/ast";
 export default function JSMetaProperty(node: AnyNode, scope: Scope) {
-	node = jsMetaProperty.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsMetaProperty.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/expressions/JSNewExpression.ts b/internal/js-analysis/evaluators/expressions/JSNewExpression.ts
index 363910108..dd06db1e8 100644
--- a/internal/js-analysis/evaluators/expressions/JSNewExpression.ts
+++ b/internal/js-analysis/evaluators/expressions/JSNewExpression.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSNewExpression, jsNewExpression} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsNewExpression } from "@internal/ast";
 import InstanceT from "../../types/InstanceT";
-
 export default function JSNewExpression(node: AnyNode, scope: Scope) {
-	node = jsNewExpression.assert(node);
-	return new InstanceT(scope, node, scope.evaluate(node.callee), []);
+    node = jsNewExpression.assert(node);
+    return new InstanceT(scope, node, scope.evaluate(node.callee), []);
 }
diff --git a/internal/js-analysis/evaluators/expressions/JSOptionalCallExpression.ts b/internal/js-analysis/evaluators/expressions/JSOptionalCallExpression.ts
index dadaba92a..f8e208368 100644
--- a/internal/js-analysis/evaluators/expressions/JSOptionalCallExpression.ts
+++ b/internal/js-analysis/evaluators/expressions/JSOptionalCallExpression.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSOptionalCallExpression,
-	jsOptionalCallExpression,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsOptionalCallExpression, } from "@internal/ast";
 export default function JSOptionalCallExpression(node: AnyNode, scope: Scope) {
-	node = jsOptionalCallExpression.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsOptionalCallExpression.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/expressions/JSReferenceIdentifier.ts b/internal/js-analysis/evaluators/expressions/JSReferenceIdentifier.ts
index c516be270..2a82f6f16 100644
--- a/internal/js-analysis/evaluators/expressions/JSReferenceIdentifier.ts
+++ b/internal/js-analysis/evaluators/expressions/JSReferenceIdentifier.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSReferenceIdentifier,
-	jsReferenceIdentifier,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsReferenceIdentifier, } from "@internal/ast";
 export default function JSReferenceIdentifier(node: AnyNode, scope: Scope) {
-	node = jsReferenceIdentifier.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsReferenceIdentifier.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/expressions/JSSequenceExpression.ts b/internal/js-analysis/evaluators/expressions/JSSequenceExpression.ts
index af7505362..6e9dafbc6 100644
--- a/internal/js-analysis/evaluators/expressions/JSSequenceExpression.ts
+++ b/internal/js-analysis/evaluators/expressions/JSSequenceExpression.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSSequenceExpression,
-	jsSequenceExpression,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsSequenceExpression, } from "@internal/ast";
 export default function JSSequenceExpression(node: AnyNode, scope: Scope) {
-	node = jsSequenceExpression.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsSequenceExpression.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/expressions/JSSuper.ts b/internal/js-analysis/evaluators/expressions/JSSuper.ts
index 80a4cee50..730a0ee75 100644
--- a/internal/js-analysis/evaluators/expressions/JSSuper.ts
+++ b/internal/js-analysis/evaluators/expressions/JSSuper.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSSuper, jsSuper} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsSuper } from "@internal/ast";
 export default function JSSuper(node: AnyNode, scope: Scope) {
-	node = jsSuper.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsSuper.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/expressions/JSTaggedTemplateExpression.ts b/internal/js-analysis/evaluators/expressions/JSTaggedTemplateExpression.ts
index e5325f55f..651c54210 100644
--- a/internal/js-analysis/evaluators/expressions/JSTaggedTemplateExpression.ts
+++ b/internal/js-analysis/evaluators/expressions/JSTaggedTemplateExpression.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSTaggedTemplateExpression,
-	jsTaggedTemplateExpression,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsTaggedTemplateExpression, } from "@internal/ast";
 export default function JSTaggedTemplateExpression(node: AnyNode, scope: Scope) {
-	node = jsTaggedTemplateExpression.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsTaggedTemplateExpression.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/expressions/JSUpdateExpression.ts b/internal/js-analysis/evaluators/expressions/JSUpdateExpression.ts
index 0cda12fd8..8bbd454bb 100644
--- a/internal/js-analysis/evaluators/expressions/JSUpdateExpression.ts
+++ b/internal/js-analysis/evaluators/expressions/JSUpdateExpression.ts
@@ -4,15 +4,13 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSUpdateExpression, jsUpdateExpression} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsUpdateExpression } from "@internal/ast";
 import NumericT from "../../types/NumericT";
 import ExhaustiveT from "../../types/ExhaustiveT";
-
 export default function JSUpdateExpression(node: AnyNode, scope: Scope) {
-	node = jsUpdateExpression.assert(node);
-	const type = new NumericT(scope, node);
-	new ExhaustiveT(scope, node.argument, scope.evaluate(node.argument), type);
-	return type;
+    node = jsUpdateExpression.assert(node);
+    const type = new NumericT(scope, node);
+    new ExhaustiveT(scope, node.argument, scope.evaluate(node.argument), type);
+    return type;
 }
diff --git a/internal/js-analysis/evaluators/expressions/JSYieldExpression.ts b/internal/js-analysis/evaluators/expressions/JSYieldExpression.ts
index b0377ab3c..39a25f5d8 100644
--- a/internal/js-analysis/evaluators/expressions/JSYieldExpression.ts
+++ b/internal/js-analysis/evaluators/expressions/JSYieldExpression.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSYieldExpression, jsYieldExpression} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsYieldExpression } from "@internal/ast";
 export default function JSYieldExpression(node: AnyNode, scope: Scope) {
-	node = jsYieldExpression.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsYieldExpression.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/jsx/JSXAttribute.ts b/internal/js-analysis/evaluators/jsx/JSXAttribute.ts
index a17826c7e..f5ee0ea3b 100644
--- a/internal/js-analysis/evaluators/jsx/JSXAttribute.ts
+++ b/internal/js-analysis/evaluators/jsx/JSXAttribute.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSXAttribute, jsxAttribute} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsxAttribute } from "@internal/ast";
 export default function JSXAttribute(node: AnyNode, scope: Scope) {
-	node = jsxAttribute.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsxAttribute.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/jsx/JSXElement.ts b/internal/js-analysis/evaluators/jsx/JSXElement.ts
index 966be8122..704cc1673 100644
--- a/internal/js-analysis/evaluators/jsx/JSXElement.ts
+++ b/internal/js-analysis/evaluators/jsx/JSXElement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSXElement, jsxElement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsxElement } from "@internal/ast";
 export default function JSXElement(node: AnyNode, scope: Scope) {
-	node = jsxElement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsxElement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/jsx/JSXEmptyExpression.ts b/internal/js-analysis/evaluators/jsx/JSXEmptyExpression.ts
index b7279828e..6b386994a 100644
--- a/internal/js-analysis/evaluators/jsx/JSXEmptyExpression.ts
+++ b/internal/js-analysis/evaluators/jsx/JSXEmptyExpression.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSXEmptyExpression, jsxEmptyExpression} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsxEmptyExpression } from "@internal/ast";
 export default function JSXEmptyExpression(node: AnyNode, scope: Scope) {
-	node = jsxEmptyExpression.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsxEmptyExpression.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/jsx/JSXExpressionContainer.ts b/internal/js-analysis/evaluators/jsx/JSXExpressionContainer.ts
index b680ba15e..0b83d94bd 100644
--- a/internal/js-analysis/evaluators/jsx/JSXExpressionContainer.ts
+++ b/internal/js-analysis/evaluators/jsx/JSXExpressionContainer.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSXExpressionContainer,
-	jsxExpressionContainer,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsxExpressionContainer, } from "@internal/ast";
 export default function JSXExpressionContainer(node: AnyNode, scope: Scope) {
-	node = jsxExpressionContainer.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsxExpressionContainer.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/jsx/JSXFragment.ts b/internal/js-analysis/evaluators/jsx/JSXFragment.ts
index 5e918bb0b..fa1852727 100644
--- a/internal/js-analysis/evaluators/jsx/JSXFragment.ts
+++ b/internal/js-analysis/evaluators/jsx/JSXFragment.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSXFragment, jsxFragment} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsxFragment } from "@internal/ast";
 export default function JSXFragment(node: AnyNode, scope: Scope) {
-	node = jsxFragment.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsxFragment.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/jsx/JSXIdentifier.ts b/internal/js-analysis/evaluators/jsx/JSXIdentifier.ts
index 78fe7d565..a14d9bdfa 100644
--- a/internal/js-analysis/evaluators/jsx/JSXIdentifier.ts
+++ b/internal/js-analysis/evaluators/jsx/JSXIdentifier.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSXIdentifier, jsxIdentifier} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsxIdentifier } from "@internal/ast";
 export default function JSXIdentifier(node: AnyNode, scope: Scope) {
-	node = jsxIdentifier.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsxIdentifier.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/jsx/JSXMemberExpression.ts b/internal/js-analysis/evaluators/jsx/JSXMemberExpression.ts
index 52b10879c..4c189b496 100644
--- a/internal/js-analysis/evaluators/jsx/JSXMemberExpression.ts
+++ b/internal/js-analysis/evaluators/jsx/JSXMemberExpression.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSXMemberExpression, jsxMemberExpression} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsxMemberExpression } from "@internal/ast";
 export default function JSXMemberExpression(node: AnyNode, scope: Scope) {
-	node = jsxMemberExpression.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsxMemberExpression.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/jsx/JSXNamespacedName.ts b/internal/js-analysis/evaluators/jsx/JSXNamespacedName.ts
index 5711ca50a..5c9856752 100644
--- a/internal/js-analysis/evaluators/jsx/JSXNamespacedName.ts
+++ b/internal/js-analysis/evaluators/jsx/JSXNamespacedName.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSXNamespacedName, jsxNamespacedName} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsxNamespacedName } from "@internal/ast";
 export default function JSXNamespacedName(node: AnyNode, scope: Scope) {
-	node = jsxNamespacedName.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsxNamespacedName.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/jsx/JSXReferenceIdentifier.ts b/internal/js-analysis/evaluators/jsx/JSXReferenceIdentifier.ts
index c522e89c5..86fcd7943 100644
--- a/internal/js-analysis/evaluators/jsx/JSXReferenceIdentifier.ts
+++ b/internal/js-analysis/evaluators/jsx/JSXReferenceIdentifier.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSXReferenceIdentifier,
-	jsxReferenceIdentifier,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsxReferenceIdentifier, } from "@internal/ast";
 export default function JSXReferenceIdentifier(node: AnyNode, scope: Scope) {
-	node = jsxReferenceIdentifier.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsxReferenceIdentifier.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/jsx/JSXSpreadAttribute.ts b/internal/js-analysis/evaluators/jsx/JSXSpreadAttribute.ts
index ab1828d97..25361bb2f 100644
--- a/internal/js-analysis/evaluators/jsx/JSXSpreadAttribute.ts
+++ b/internal/js-analysis/evaluators/jsx/JSXSpreadAttribute.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSXSpreadAttribute, jsxSpreadAttribute} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsxSpreadAttribute } from "@internal/ast";
 export default function JSXSpreadAttribute(node: AnyNode, scope: Scope) {
-	node = jsxSpreadAttribute.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsxSpreadAttribute.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/jsx/JSXSpreadChild.ts b/internal/js-analysis/evaluators/jsx/JSXSpreadChild.ts
index 19a787751..59f75f217 100644
--- a/internal/js-analysis/evaluators/jsx/JSXSpreadChild.ts
+++ b/internal/js-analysis/evaluators/jsx/JSXSpreadChild.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSXSpreadChild, jsxSpreadChild} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsxSpreadChild } from "@internal/ast";
 export default function JSXSpreadChild(node: AnyNode, scope: Scope) {
-	node = jsxSpreadChild.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsxSpreadChild.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/jsx/JSXText.ts b/internal/js-analysis/evaluators/jsx/JSXText.ts
index e6422a5aa..dca1033eb 100644
--- a/internal/js-analysis/evaluators/jsx/JSXText.ts
+++ b/internal/js-analysis/evaluators/jsx/JSXText.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSXText, jsxText} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsxText } from "@internal/ast";
 export default function JSXText(node: AnyNode, scope: Scope) {
-	node = jsxText.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsxText.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/literals/JSBooleanLiteral.ts b/internal/js-analysis/evaluators/literals/JSBooleanLiteral.ts
index a6bd14ff7..e73b6abf5 100644
--- a/internal/js-analysis/evaluators/literals/JSBooleanLiteral.ts
+++ b/internal/js-analysis/evaluators/literals/JSBooleanLiteral.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSBooleanLiteral, jsBooleanLiteral} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsBooleanLiteral } from "@internal/ast";
 import BooleanLiteralT from "../../types/BooleanLiteralT";
-
 export default function JSBooleanLiteral(node: AnyNode, scope: Scope) {
-	node = jsBooleanLiteral.assert(node);
-	return new BooleanLiteralT(scope, node, node.value);
+    node = jsBooleanLiteral.assert(node);
+    return new BooleanLiteralT(scope, node, node.value);
 }
diff --git a/internal/js-analysis/evaluators/literals/JSNullLiteral.ts b/internal/js-analysis/evaluators/literals/JSNullLiteral.ts
index 24d6dd815..d4fd480c1 100644
--- a/internal/js-analysis/evaluators/literals/JSNullLiteral.ts
+++ b/internal/js-analysis/evaluators/literals/JSNullLiteral.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSNullLiteral, jsNullLiteral} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsNullLiteral } from "@internal/ast";
 import NullT from "../../types/NullT";
-
 export default function JSNullLiteral(node: AnyNode, scope: Scope) {
-	node = node = jsNullLiteral.assert(node);
-	return new NullT(scope, node);
+    node = node = jsNullLiteral.assert(node);
+    return new NullT(scope, node);
 }
diff --git a/internal/js-analysis/evaluators/literals/JSNumericLiteral.ts b/internal/js-analysis/evaluators/literals/JSNumericLiteral.ts
index 354e92961..37392ba12 100644
--- a/internal/js-analysis/evaluators/literals/JSNumericLiteral.ts
+++ b/internal/js-analysis/evaluators/literals/JSNumericLiteral.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSNumericLiteral, jsNumericLiteral} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsNumericLiteral } from "@internal/ast";
 import NumericLiteralT from "../../types/NumericLiteralT";
-
 export default function JSNumericLiteral(node: AnyNode, scope: Scope) {
-	node = jsNumericLiteral.assert(node);
-	return new NumericLiteralT(scope, node, node.value);
+    node = jsNumericLiteral.assert(node);
+    return new NumericLiteralT(scope, node, node.value);
 }
diff --git a/internal/js-analysis/evaluators/literals/JSRegExpLiteral.ts b/internal/js-analysis/evaluators/literals/JSRegExpLiteral.ts
index 10f1b1a3b..fcb9ac7a1 100644
--- a/internal/js-analysis/evaluators/literals/JSRegExpLiteral.ts
+++ b/internal/js-analysis/evaluators/literals/JSRegExpLiteral.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSRegExpLiteral, jsRegExpLiteral} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsRegExpLiteral } from "@internal/ast";
 export default function JSRegExpLiteral(node: AnyNode, scope: Scope) {
-	node = jsRegExpLiteral.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsRegExpLiteral.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/literals/JSStringLiteral.ts b/internal/js-analysis/evaluators/literals/JSStringLiteral.ts
index fe41870be..dd3c6949c 100644
--- a/internal/js-analysis/evaluators/literals/JSStringLiteral.ts
+++ b/internal/js-analysis/evaluators/literals/JSStringLiteral.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSStringLiteral, jsStringLiteral} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsStringLiteral } from "@internal/ast";
 import StringLiteralT from "../../types/StringLiteralT";
-
 export default function JSStringLiteral(node: AnyNode, scope: Scope) {
-	node = jsStringLiteral.assert(node);
-	return new StringLiteralT(scope, node, node.value);
+    node = jsStringLiteral.assert(node);
+    return new StringLiteralT(scope, node, node.value);
 }
diff --git a/internal/js-analysis/evaluators/literals/JSTemplateLiteral.ts b/internal/js-analysis/evaluators/literals/JSTemplateLiteral.ts
index 42abe6e61..2cd770cc8 100644
--- a/internal/js-analysis/evaluators/literals/JSTemplateLiteral.ts
+++ b/internal/js-analysis/evaluators/literals/JSTemplateLiteral.ts
@@ -4,21 +4,14 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSTemplateLiteral, jsTemplateLiteral} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsTemplateLiteral } from "@internal/ast";
 import ExhaustiveT from "../../types/ExhaustiveT";
 import StringT from "../../types/StringT";
-
 export default function JSTemplateLiteral(node: AnyNode, scope: Scope) {
-	node = jsTemplateLiteral.assert(node);
-	for (const expr of node.expressions) {
-		new ExhaustiveT(
-			scope,
-			expr,
-			scope.evaluate(expr),
-			new StringT(scope, undefined),
-		);
-	}
-	return new StringT(scope, node);
+    node = jsTemplateLiteral.assert(node);
+    for (const expr of node.expressions) {
+        new ExhaustiveT(scope, expr, scope.evaluate(expr), new StringT(scope, undefined));
+    }
+    return new StringT(scope, node);
 }
diff --git a/internal/js-analysis/evaluators/modules/JSExportAllDeclaration.ts b/internal/js-analysis/evaluators/modules/JSExportAllDeclaration.ts
index aa94adbfb..68d541a0b 100644
--- a/internal/js-analysis/evaluators/modules/JSExportAllDeclaration.ts
+++ b/internal/js-analysis/evaluators/modules/JSExportAllDeclaration.ts
@@ -4,20 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSExportAllDeclaration,
-	jsExportAllDeclaration,
-} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsExportAllDeclaration, } from "@internal/ast";
 import Hub from "../../Hub";
-
-export default function JSExportAllDeclaration(
-	node: AnyNode,
-	scope: Scope,
-	{evaluator}: Hub,
-) {
-	node = jsExportAllDeclaration.assert(node);
-	evaluator.addExportAll(node.source.value);
+export default function JSExportAllDeclaration(node: AnyNode, scope: Scope, { evaluator }: Hub) {
+    node = jsExportAllDeclaration.assert(node);
+    evaluator.addExportAll(node.source.value);
 }
diff --git a/internal/js-analysis/evaluators/modules/JSExportDefaultDeclaration.ts b/internal/js-analysis/evaluators/modules/JSExportDefaultDeclaration.ts
index a53ce6754..6ab53323a 100644
--- a/internal/js-analysis/evaluators/modules/JSExportDefaultDeclaration.ts
+++ b/internal/js-analysis/evaluators/modules/JSExportDefaultDeclaration.ts
@@ -4,24 +4,13 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSExportDefaultDeclaration,
-	jsExportDefaultDeclaration,
-} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsExportDefaultDeclaration, } from "@internal/ast";
 import Hub from "../../Hub";
-
-export default function JSExportDefaultDeclaration(
-	node: AnyNode,
-	scope: Scope,
-	{evaluator}: Hub,
-) {
-	node = jsExportDefaultDeclaration.assert(node);
-
-	const decl = node.declaration;
-	const declType = scope.evaluate(decl);
-	evaluator.addExport("default", declType);
-	return declType;
+export default function JSExportDefaultDeclaration(node: AnyNode, scope: Scope, { evaluator }: Hub) {
+    node = jsExportDefaultDeclaration.assert(node);
+    const decl = node.declaration;
+    const declType = scope.evaluate(decl);
+    evaluator.addExport("default", declType);
+    return declType;
 }
diff --git a/internal/js-analysis/evaluators/modules/JSExportDefaultSpecifier.ts b/internal/js-analysis/evaluators/modules/JSExportDefaultSpecifier.ts
index aa944e5ea..e3f712784 100644
--- a/internal/js-analysis/evaluators/modules/JSExportDefaultSpecifier.ts
+++ b/internal/js-analysis/evaluators/modules/JSExportDefaultSpecifier.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSExportDefaultSpecifier,
-	jsExportDefaultSpecifier,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsExportDefaultSpecifier, } from "@internal/ast";
 export default function JSExportDefaultSpecifier(node: AnyNode, scope: Scope) {
-	node = jsExportDefaultSpecifier.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsExportDefaultSpecifier.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/modules/JSExportExternalDeclaration.ts b/internal/js-analysis/evaluators/modules/JSExportExternalDeclaration.ts
index 8f1c3c5e1..83569849d 100644
--- a/internal/js-analysis/evaluators/modules/JSExportExternalDeclaration.ts
+++ b/internal/js-analysis/evaluators/modules/JSExportExternalDeclaration.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSExportExternalDeclaration,
-	jsExportExternalDeclaration,
-} from "@internal/ast";
-
+import { AnyNode, jsExportExternalDeclaration, } from "@internal/ast";
 export default function JSExportExternalDeclaration(node: AnyNode) {
-	node = jsExportExternalDeclaration.assert(node);
-	throw new Error("unimplemented");
+    node = jsExportExternalDeclaration.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/modules/JSExportExternalSpecifier.ts b/internal/js-analysis/evaluators/modules/JSExportExternalSpecifier.ts
index bb346d8c6..b649fc83c 100644
--- a/internal/js-analysis/evaluators/modules/JSExportExternalSpecifier.ts
+++ b/internal/js-analysis/evaluators/modules/JSExportExternalSpecifier.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSExportExternalSpecifier,
-	jsExportExternalSpecifier,
-} from "@internal/ast";
-
+import { AnyNode, jsExportExternalSpecifier, } from "@internal/ast";
 export default function JSExportExternalSpecifier(node: AnyNode) {
-	node = jsExportExternalSpecifier.assert(node);
-	throw new Error("unimplemented");
+    node = jsExportExternalSpecifier.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/modules/JSExportLocalSpecifier.ts b/internal/js-analysis/evaluators/modules/JSExportLocalSpecifier.ts
index 2696485d4..9f04d5d6a 100644
--- a/internal/js-analysis/evaluators/modules/JSExportLocalSpecifier.ts
+++ b/internal/js-analysis/evaluators/modules/JSExportLocalSpecifier.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSExportLocalSpecifier,
-	jsExportLocalSpecifier,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsExportLocalSpecifier, } from "@internal/ast";
 export default function JSExportLocalSpecifier(node: AnyNode, scope: Scope) {
-	node = jsExportLocalSpecifier.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsExportLocalSpecifier.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/modules/JSExportNamespaceSpecifier.ts b/internal/js-analysis/evaluators/modules/JSExportNamespaceSpecifier.ts
index 89fa30845..3961372d7 100644
--- a/internal/js-analysis/evaluators/modules/JSExportNamespaceSpecifier.ts
+++ b/internal/js-analysis/evaluators/modules/JSExportNamespaceSpecifier.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSExportNamespaceSpecifier,
-	jsExportNamespaceSpecifier,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsExportNamespaceSpecifier, } from "@internal/ast";
 export default function JSExportNamespaceSpecifier(node: AnyNode, scope: Scope) {
-	node = jsExportNamespaceSpecifier.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsExportNamespaceSpecifier.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/modules/JSImportCall.ts b/internal/js-analysis/evaluators/modules/JSImportCall.ts
index e8044de13..b2e233e50 100644
--- a/internal/js-analysis/evaluators/modules/JSImportCall.ts
+++ b/internal/js-analysis/evaluators/modules/JSImportCall.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSImportCall, jsImportCall} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsImportCall } from "@internal/ast";
 export default function JSImportCall(node: AnyNode, scope: Scope) {
-	node = jsImportCall.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsImportCall.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/modules/JSImportDeclaration.ts b/internal/js-analysis/evaluators/modules/JSImportDeclaration.ts
index 4c6d49f36..1eaf6bafe 100644
--- a/internal/js-analysis/evaluators/modules/JSImportDeclaration.ts
+++ b/internal/js-analysis/evaluators/modules/JSImportDeclaration.ts
@@ -4,55 +4,41 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {AnyNode, JSImportDeclaration, jsImportDeclaration} from "@internal/ast";
-import {Scope} from "../../scopes";
+import { AnyNode, jsImportDeclaration } from "@internal/ast";
+import { Scope } from "../../scopes";
 import ImportT from "../../types/ImportT";
-import {getImportSpecifiers} from "@internal/js-ast-utils";
-
+import { getImportSpecifiers } from "@internal/js-ast-utils";
 export default function JSImportDeclaration(node: AnyNode, scope: Scope) {
-	node = jsImportDeclaration.assert(node);
-
-	const source = node.source.value;
-
-	for (const specifier of getImportSpecifiers(node)) {
-		if (specifier.type === "JSImportSpecifier") {
-			const localName = specifier.local.name.name;
-			const importedName = specifier.imported.name;
-
-			const open = new ImportT(
-				scope,
-				specifier,
-				{
-					importedName,
-					source,
-				},
-			);
-			scope.addBinding(localName, open);
-		} else if (specifier.type === "JSImportDefaultSpecifier") {
-			const localName = specifier.local.name.name;
-			const open = new ImportT(
-				scope,
-				specifier,
-				{
-					importedName: "default",
-					source,
-				},
-			);
-			scope.addBinding(localName, open);
-		} else if (specifier.type === "JSImportNamespaceSpecifier") {
-			const localName = specifier.local.name.name;
-			const open = new ImportT(
-				scope,
-				specifier,
-				{
-					importedName: undefined,
-					source,
-				},
-			);
-			scope.addBinding(localName, open);
-		} else {
-			// TODO error
-		}
-	}
+    node = jsImportDeclaration.assert(node);
+    const source = node.source.value;
+    for (const specifier of getImportSpecifiers(node)) {
+        if (specifier.type === "JSImportSpecifier") {
+            const localName = specifier.local.name.name;
+            const importedName = specifier.imported.name;
+            const open = new ImportT(scope, specifier, {
+                importedName,
+                source
+            });
+            scope.addBinding(localName, open);
+        }
+        else if (specifier.type === "JSImportDefaultSpecifier") {
+            const localName = specifier.local.name.name;
+            const open = new ImportT(scope, specifier, {
+                importedName: "default",
+                source
+            });
+            scope.addBinding(localName, open);
+        }
+        else if (specifier.type === "JSImportNamespaceSpecifier") {
+            const localName = specifier.local.name.name;
+            const open = new ImportT(scope, specifier, {
+                importedName: undefined,
+                source
+            });
+            scope.addBinding(localName, open);
+        }
+        else {
+            // TODO error
+        }
+    }
 }
diff --git a/internal/js-analysis/evaluators/modules/JSImportDefaultSpecifier.ts b/internal/js-analysis/evaluators/modules/JSImportDefaultSpecifier.ts
index 691d70470..338131760 100644
--- a/internal/js-analysis/evaluators/modules/JSImportDefaultSpecifier.ts
+++ b/internal/js-analysis/evaluators/modules/JSImportDefaultSpecifier.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSImportDefaultSpecifier,
-	jsImportDefaultSpecifier,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsImportDefaultSpecifier, } from "@internal/ast";
 export default function JSImportDefaultSpecifier(node: AnyNode, scope: Scope) {
-	node = jsImportDefaultSpecifier.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsImportDefaultSpecifier.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/modules/JSImportNamespaceSpecifier.ts b/internal/js-analysis/evaluators/modules/JSImportNamespaceSpecifier.ts
index 35b5f26d8..25c279695 100644
--- a/internal/js-analysis/evaluators/modules/JSImportNamespaceSpecifier.ts
+++ b/internal/js-analysis/evaluators/modules/JSImportNamespaceSpecifier.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSImportNamespaceSpecifier,
-	jsImportNamespaceSpecifier,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsImportNamespaceSpecifier, } from "@internal/ast";
 export default function JSImportNamespaceSpecifier(node: AnyNode, scope: Scope) {
-	node = jsImportNamespaceSpecifier.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsImportNamespaceSpecifier.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/modules/JSImportSpecifier.ts b/internal/js-analysis/evaluators/modules/JSImportSpecifier.ts
index a4ff1ed9d..cb183e354 100644
--- a/internal/js-analysis/evaluators/modules/JSImportSpecifier.ts
+++ b/internal/js-analysis/evaluators/modules/JSImportSpecifier.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSImportSpecifier, jsImportSpecifier} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsImportSpecifier } from "@internal/ast";
 export default function JSImportSpecifier(node: AnyNode, scope: Scope) {
-	node = jsImportSpecifier.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsImportSpecifier.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/modules/JSImportSpecifierLocal.ts b/internal/js-analysis/evaluators/modules/JSImportSpecifierLocal.ts
index 238064626..abef4557a 100644
--- a/internal/js-analysis/evaluators/modules/JSImportSpecifierLocal.ts
+++ b/internal/js-analysis/evaluators/modules/JSImportSpecifierLocal.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSImportSpecifierLocal,
-	jsImportSpecifierLocal,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsImportSpecifierLocal, } from "@internal/ast";
 export default function JSImportSpecifierLocal(node: AnyNode, scope: Scope) {
-	node = jsImportSpecifierLocal.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsImportSpecifierLocal.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/objects/JSComputedPropertyKey.ts b/internal/js-analysis/evaluators/objects/JSComputedPropertyKey.ts
index 013a44d58..48223bd04 100644
--- a/internal/js-analysis/evaluators/objects/JSComputedPropertyKey.ts
+++ b/internal/js-analysis/evaluators/objects/JSComputedPropertyKey.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSComputedPropertyKey,
-	jsComputedPropertyKey,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsComputedPropertyKey, } from "@internal/ast";
 export default function JSComputedPropertyKey(node: AnyNode, scope: Scope) {
-	node = jsComputedPropertyKey.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsComputedPropertyKey.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/objects/JSObjectExpression.ts b/internal/js-analysis/evaluators/objects/JSObjectExpression.ts
index 8b9bc2e8b..18ea70b9f 100644
--- a/internal/js-analysis/evaluators/objects/JSObjectExpression.ts
+++ b/internal/js-analysis/evaluators/objects/JSObjectExpression.ts
@@ -4,54 +4,44 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSObjectExpression, jsObjectExpression} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsObjectExpression } from "@internal/ast";
 import ObjPropT from "../../types/ObjPropT";
 import ObjT from "../../types/ObjT";
-
 export default function JSObjectExpression(node: AnyNode, scope: Scope) {
-	node = jsObjectExpression.assert(node);
-	const props = [];
-
-	for (const prop of node.properties) {
-		if (prop.type === "JSSpreadProperty") {
-			// TODO
-		} else if (prop.type === "JSObjectProperty") {
-			if (prop.key.type === "JSComputedPropertyKey") {
-				// TODO
-			} else {
-				const {
-					key: {value: key},
-					value,
-				} = prop;
-
-				let keyStr;
-				if (key.type === "JSIdentifier") {
-					keyStr = key.name;
-				} else {
-					// TODO
-					continue;
-				}
-
-				if (keyStr === undefined) {
-					throw new Error("Expected keyStr");
-				}
-
-				props.push(new ObjPropT(scope, prop, keyStr, scope.evaluate(value)));
-			}
-		} else {
-			// TODO
-		}
-	}
-
-	return new ObjT(
-		scope,
-		node,
-		{
-			calls: [],
-			props,
-			proto: scope.intrinsics.ObjectPrototype,
-		},
-	);
+    node = jsObjectExpression.assert(node);
+    const props = [];
+    for (const prop of node.properties) {
+        if (prop.type === "JSSpreadProperty") {
+            // TODO
+        }
+        else if (prop.type === "JSObjectProperty") {
+            if (prop.key.type === "JSComputedPropertyKey") {
+                // TODO
+            }
+            else {
+                const { key: { value: key }, value, } = prop;
+                let keyStr;
+                if (key.type === "JSIdentifier") {
+                    keyStr = key.name;
+                }
+                else {
+                    // TODO
+                    continue;
+                }
+                if (keyStr === undefined) {
+                    throw new Error("Expected keyStr");
+                }
+                props.push(new ObjPropT(scope, prop, keyStr, scope.evaluate(value)));
+            }
+        }
+        else {
+            // TODO
+        }
+    }
+    return new ObjT(scope, node, {
+        calls: [],
+        props,
+        proto: scope.intrinsics.ObjectPrototype
+    });
 }
diff --git a/internal/js-analysis/evaluators/objects/JSObjectMethod.ts b/internal/js-analysis/evaluators/objects/JSObjectMethod.ts
index 2e9bdaa99..5b9d91d37 100644
--- a/internal/js-analysis/evaluators/objects/JSObjectMethod.ts
+++ b/internal/js-analysis/evaluators/objects/JSObjectMethod.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSObjectMethod, jsObjectMethod} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsObjectMethod } from "@internal/ast";
 export default function JSObjectMethod(node: AnyNode, scope: Scope) {
-	node = jsObjectMethod.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsObjectMethod.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/objects/JSObjectProperty.ts b/internal/js-analysis/evaluators/objects/JSObjectProperty.ts
index 33a265097..5f855174e 100644
--- a/internal/js-analysis/evaluators/objects/JSObjectProperty.ts
+++ b/internal/js-analysis/evaluators/objects/JSObjectProperty.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSObjectProperty, jsObjectProperty} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsObjectProperty } from "@internal/ast";
 export default function JSObjectProperty(node: AnyNode, scope: Scope) {
-	node = jsObjectProperty.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsObjectProperty.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/objects/JSSpreadProperty.ts b/internal/js-analysis/evaluators/objects/JSSpreadProperty.ts
index ae486748f..6d9bf8a67 100644
--- a/internal/js-analysis/evaluators/objects/JSSpreadProperty.ts
+++ b/internal/js-analysis/evaluators/objects/JSSpreadProperty.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSSpreadProperty, jsSpreadProperty} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsSpreadProperty } from "@internal/ast";
 export default function JSSpreadProperty(node: AnyNode, scope: Scope) {
-	node = jsSpreadProperty.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsSpreadProperty.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/objects/JSStaticPropertyKey.ts b/internal/js-analysis/evaluators/objects/JSStaticPropertyKey.ts
index 2a53e91b2..07efbae1d 100644
--- a/internal/js-analysis/evaluators/objects/JSStaticPropertyKey.ts
+++ b/internal/js-analysis/evaluators/objects/JSStaticPropertyKey.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSStaticPropertyKey, jsStaticPropertyKey} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsStaticPropertyKey } from "@internal/ast";
 export default function JSStaticPropertyKey(node: AnyNode, scope: Scope) {
-	node = jsStaticPropertyKey.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsStaticPropertyKey.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/patterns/JSAssignmentArrayPattern.ts b/internal/js-analysis/evaluators/patterns/JSAssignmentArrayPattern.ts
index cf61c0063..b7b3bda48 100644
--- a/internal/js-analysis/evaluators/patterns/JSAssignmentArrayPattern.ts
+++ b/internal/js-analysis/evaluators/patterns/JSAssignmentArrayPattern.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSAssignmentArrayPattern,
-	jsAssignmentArrayPattern,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsAssignmentArrayPattern, } from "@internal/ast";
 export default function JSAssignmentArrayPattern(node: AnyNode, scope: Scope) {
-	node = jsAssignmentArrayPattern.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsAssignmentArrayPattern.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/patterns/JSAssignmentAssignmentPattern.ts b/internal/js-analysis/evaluators/patterns/JSAssignmentAssignmentPattern.ts
index 11aa72a34..20818da9f 100644
--- a/internal/js-analysis/evaluators/patterns/JSAssignmentAssignmentPattern.ts
+++ b/internal/js-analysis/evaluators/patterns/JSAssignmentAssignmentPattern.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSAssignmentAssignmentPattern,
-	jsAssignmentAssignmentPattern,
-} from "@internal/ast";
-
+import { AnyNode, jsAssignmentAssignmentPattern, } from "@internal/ast";
 export default function JSAssignmentAssignmentPattern(node: AnyNode) {
-	node = jsAssignmentAssignmentPattern.assert(node);
-	throw new Error("unimplemented");
+    node = jsAssignmentAssignmentPattern.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/patterns/JSAssignmentObjectPattern.ts b/internal/js-analysis/evaluators/patterns/JSAssignmentObjectPattern.ts
index d9edba362..9b54bfd6f 100644
--- a/internal/js-analysis/evaluators/patterns/JSAssignmentObjectPattern.ts
+++ b/internal/js-analysis/evaluators/patterns/JSAssignmentObjectPattern.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSAssignmentObjectPattern,
-	jsAssignmentObjectPattern,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsAssignmentObjectPattern, } from "@internal/ast";
 export default function JSAssignmentObjectPattern(node: AnyNode, scope: Scope) {
-	node = jsAssignmentObjectPattern.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsAssignmentObjectPattern.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/patterns/JSAssignmentObjectPatternProperty.ts b/internal/js-analysis/evaluators/patterns/JSAssignmentObjectPatternProperty.ts
index f988393d7..940892a12 100644
--- a/internal/js-analysis/evaluators/patterns/JSAssignmentObjectPatternProperty.ts
+++ b/internal/js-analysis/evaluators/patterns/JSAssignmentObjectPatternProperty.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSAssignmentObjectPatternProperty,
-	jsAssignmentObjectPatternProperty,
-} from "@internal/ast";
-
+import { AnyNode, jsAssignmentObjectPatternProperty, } from "@internal/ast";
 export default function JSAssignmentObjectPatternProperty(node: AnyNode) {
-	node = jsAssignmentObjectPatternProperty.assert(node);
-	throw new Error("unimplemented");
+    node = jsAssignmentObjectPatternProperty.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/patterns/JSBindingAssignmentPattern.ts b/internal/js-analysis/evaluators/patterns/JSBindingAssignmentPattern.ts
index fd15a321f..4f6afbf1d 100644
--- a/internal/js-analysis/evaluators/patterns/JSBindingAssignmentPattern.ts
+++ b/internal/js-analysis/evaluators/patterns/JSBindingAssignmentPattern.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSBindingAssignmentPattern,
-	jsBindingAssignmentPattern,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsBindingAssignmentPattern, } from "@internal/ast";
 export default function JSBindingAssignmentPattern(node: AnyNode, scope: Scope) {
-	node = jsBindingAssignmentPattern.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsBindingAssignmentPattern.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/patterns/JSBindingIdentifier.ts b/internal/js-analysis/evaluators/patterns/JSBindingIdentifier.ts
index cba49c4ce..7a4358af9 100644
--- a/internal/js-analysis/evaluators/patterns/JSBindingIdentifier.ts
+++ b/internal/js-analysis/evaluators/patterns/JSBindingIdentifier.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSBindingIdentifier, jsBindingIdentifier} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsBindingIdentifier } from "@internal/ast";
 export default function JSBindingIdentifier(node: AnyNode, scope: Scope) {
-	node = jsBindingIdentifier.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsBindingIdentifier.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/patterns/JSBindingObjectPattern.ts b/internal/js-analysis/evaluators/patterns/JSBindingObjectPattern.ts
index 279fec1c2..a71f0bd73 100644
--- a/internal/js-analysis/evaluators/patterns/JSBindingObjectPattern.ts
+++ b/internal/js-analysis/evaluators/patterns/JSBindingObjectPattern.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSBindingObjectPattern,
-	jsBindingObjectPattern,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsBindingObjectPattern, } from "@internal/ast";
 export default function JSBindingObjectPattern(node: AnyNode, scope: Scope) {
-	node = jsBindingObjectPattern.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsBindingObjectPattern.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/patterns/JSBindingObjectPatternProperty.ts b/internal/js-analysis/evaluators/patterns/JSBindingObjectPatternProperty.ts
index cb74d7126..c5d6c9f8a 100644
--- a/internal/js-analysis/evaluators/patterns/JSBindingObjectPatternProperty.ts
+++ b/internal/js-analysis/evaluators/patterns/JSBindingObjectPatternProperty.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSBindingObjectPatternProperty,
-	jsBindingObjectPatternProperty,
-} from "@internal/ast";
-
+import { AnyNode, jsBindingObjectPatternProperty, } from "@internal/ast";
 export default function JSBindingObjectPatternProperty(node: AnyNode) {
-	node = jsBindingObjectPatternProperty.assert(node);
-	throw new Error("unimplemented");
+    node = jsBindingObjectPatternProperty.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/patterns/JSPatternMeta.ts b/internal/js-analysis/evaluators/patterns/JSPatternMeta.ts
index 6590f285e..448eca8ca 100644
--- a/internal/js-analysis/evaluators/patterns/JSPatternMeta.ts
+++ b/internal/js-analysis/evaluators/patterns/JSPatternMeta.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSPatternMeta, jsPatternMeta} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsPatternMeta } from "@internal/ast";
 export default function JSPatternMeta(node: AnyNode, scope: Scope) {
-	node = jsPatternMeta.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsPatternMeta.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpAlternation.ts b/internal/js-analysis/evaluators/regex/JSRegExpAlternation.ts
index c39c5711b..2c5394e86 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpAlternation.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpAlternation.ts
@@ -4,10 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {AnyNode, JSRegExpAlternation, jsRegExpAlternation} from "@internal/ast";
-
+import { AnyNode, jsRegExpAlternation } from "@internal/ast";
 export default function JSRegExpAlternation(node: AnyNode) {
-	node = jsRegExpAlternation.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpAlternation.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpAnyCharacter.ts b/internal/js-analysis/evaluators/regex/JSRegExpAnyCharacter.ts
index 06b8ca13c..6f91ea509 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpAnyCharacter.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpAnyCharacter.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSRegExpAnyCharacter,
-	jsRegExpAnyCharacter,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpAnyCharacter, } from "@internal/ast";
 export default function JSRegExpAnyCharacter(node: AnyNode) {
-	node = jsRegExpAnyCharacter.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpAnyCharacter.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpCharSet.ts b/internal/js-analysis/evaluators/regex/JSRegExpCharSet.ts
index ce6c4e0c5..9462af972 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpCharSet.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpCharSet.ts
@@ -4,10 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {AnyNode, JSRegExpCharSet, jsRegExpCharSet} from "@internal/ast";
-
+import { AnyNode, jsRegExpCharSet } from "@internal/ast";
 export default function JSRegExpCharSet(node: AnyNode) {
-	node = jsRegExpCharSet.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpCharSet.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpCharSetRange.ts b/internal/js-analysis/evaluators/regex/JSRegExpCharSetRange.ts
index 40395fcfa..6b9f24b95 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpCharSetRange.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpCharSetRange.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSRegExpCharSetRange,
-	jsRegExpCharSetRange,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpCharSetRange, } from "@internal/ast";
 export default function JSRegExpCharSetRange(node: AnyNode) {
-	node = jsRegExpCharSetRange.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpCharSetRange.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpCharacter.ts b/internal/js-analysis/evaluators/regex/JSRegExpCharacter.ts
index b5911416c..9004f405e 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpCharacter.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpCharacter.ts
@@ -4,10 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {AnyNode, JSRegExpCharacter, jsRegExpCharacter} from "@internal/ast";
-
+import { AnyNode, jsRegExpCharacter } from "@internal/ast";
 export default function JSRegExpCharacter(node: AnyNode) {
-	node = jsRegExpCharacter.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpCharacter.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpControlCharacter.ts b/internal/js-analysis/evaluators/regex/JSRegExpControlCharacter.ts
index 27e573b47..7276cb865 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpControlCharacter.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpControlCharacter.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSRegExpControlCharacter,
-	jsRegExpControlCharacter,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpControlCharacter, } from "@internal/ast";
 export default function JSRegExpControlCharacter(node: AnyNode) {
-	node = jsRegExpControlCharacter.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpControlCharacter.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpDigitCharacter.ts b/internal/js-analysis/evaluators/regex/JSRegExpDigitCharacter.ts
index a99213331..f6aee0b36 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpDigitCharacter.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpDigitCharacter.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSRegExpDigitCharacter,
-	jsRegExpDigitCharacter,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpDigitCharacter, } from "@internal/ast";
 export default function JSRegExpDigitCharacter(node: AnyNode) {
-	node = jsRegExpDigitCharacter.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpDigitCharacter.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpEndCharacter.ts b/internal/js-analysis/evaluators/regex/JSRegExpEndCharacter.ts
index c94b8fc22..204256129 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpEndCharacter.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpEndCharacter.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSRegExpEndCharacter,
-	jsRegExpEndCharacter,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpEndCharacter, } from "@internal/ast";
 export default function JSRegExpEndCharacter(node: AnyNode) {
-	node = jsRegExpEndCharacter.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpEndCharacter.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpGroupCapture.ts b/internal/js-analysis/evaluators/regex/JSRegExpGroupCapture.ts
index 99fed6007..540ed6a8b 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpGroupCapture.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpGroupCapture.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSRegExpGroupCapture,
-	jsRegExpGroupCapture,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpGroupCapture, } from "@internal/ast";
 export default function JSRegExpGroupCapture(node: AnyNode) {
-	node = jsRegExpGroupCapture.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpGroupCapture.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpGroupNonCapture.ts b/internal/js-analysis/evaluators/regex/JSRegExpGroupNonCapture.ts
index 8acb558f3..6004830df 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpGroupNonCapture.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpGroupNonCapture.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSRegExpGroupNonCapture,
-	jsRegExpGroupNonCapture,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpGroupNonCapture, } from "@internal/ast";
 export default function JSRegExpGroupNonCapture(node: AnyNode) {
-	node = jsRegExpGroupNonCapture.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpGroupNonCapture.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpNamedBackReference.ts b/internal/js-analysis/evaluators/regex/JSRegExpNamedBackReference.ts
index 7fa6d771c..6f2685236 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpNamedBackReference.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpNamedBackReference.ts
@@ -4,14 +4,8 @@
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
-
-import {
-	AnyNode,
-	JSRegExpNamedBackReference,
-	jsRegExpNamedBackReference,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpNamedBackReference, } from "@internal/ast";
 export default function JSRegExpNamedBackReference(node: AnyNode) {
-	node = jsRegExpNamedBackReference.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpNamedBackReference.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpNonDigitCharacter.ts b/internal/js-analysis/evaluators/regex/JSRegExpNonDigitCharacter.ts
index a8c1ae85f..2969da15b 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpNonDigitCharacter.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpNonDigitCharacter.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSRegExpNonDigitCharacter,
-	jsRegExpNonDigitCharacter,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpNonDigitCharacter, } from "@internal/ast";
 export default function JSRegExpNonDigitCharacter(node: AnyNode) {
-	node = jsRegExpNonDigitCharacter.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpNonDigitCharacter.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpNonWhiteSpaceCharacter.ts b/internal/js-analysis/evaluators/regex/JSRegExpNonWhiteSpaceCharacter.ts
index 250d0b4f1..a4060ea73 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpNonWhiteSpaceCharacter.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpNonWhiteSpaceCharacter.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSRegExpNonWhiteSpaceCharacter,
-	jsRegExpNonWhiteSpaceCharacter,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpNonWhiteSpaceCharacter, } from "@internal/ast";
 export default function JSRegExpNonWhiteSpaceCharacter(node: AnyNode) {
-	node = jsRegExpNonWhiteSpaceCharacter.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpNonWhiteSpaceCharacter.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpNonWordBoundaryCharacter.ts b/internal/js-analysis/evaluators/regex/JSRegExpNonWordBoundaryCharacter.ts
index 9e8a9b6c0..a246b33b9 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpNonWordBoundaryCharacter.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpNonWordBoundaryCharacter.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSRegExpNonWordBoundaryCharacter,
-	jsRegExpNonWordBoundaryCharacter,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpNonWordBoundaryCharacter, } from "@internal/ast";
 export default function JSRegExpNonWordBoundaryCharacter(node: AnyNode) {
-	node = jsRegExpNonWordBoundaryCharacter.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpNonWordBoundaryCharacter.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpNonWordCharacter.ts b/internal/js-analysis/evaluators/regex/JSRegExpNonWordCharacter.ts
index 334c04dfe..8e11e6f4b 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpNonWordCharacter.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpNonWordCharacter.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSRegExpNonWordCharacter,
-	jsRegExpNonWordCharacter,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpNonWordCharacter, } from "@internal/ast";
 export default function JSRegExpNonWordCharacter(node: AnyNode) {
-	node = jsRegExpNonWordCharacter.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpNonWordCharacter.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpNumericBackReference.ts b/internal/js-analysis/evaluators/regex/JSRegExpNumericBackReference.ts
index 0db2b1dd6..df8629c0b 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpNumericBackReference.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpNumericBackReference.ts
@@ -4,14 +4,8 @@
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
-
-import {
-	AnyNode,
-	JSRegExpNumericBackReference,
-	jsRegExpNumericBackReference,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpNumericBackReference, } from "@internal/ast";
 export default function JSRegExpNumericBackReference(node: AnyNode) {
-	node = jsRegExpNumericBackReference.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpNumericBackReference.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpQuantified.ts b/internal/js-analysis/evaluators/regex/JSRegExpQuantified.ts
index 1c9b4ead7..e32eec7d6 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpQuantified.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpQuantified.ts
@@ -4,10 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {AnyNode, JSRegExpQuantified, jsRegExpQuantified} from "@internal/ast";
-
+import { AnyNode, jsRegExpQuantified } from "@internal/ast";
 export default function JSRegExpQuantified(node: AnyNode) {
-	node = jsRegExpQuantified.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpQuantified.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpStartCharacter.ts b/internal/js-analysis/evaluators/regex/JSRegExpStartCharacter.ts
index 456b183e3..f63d2024e 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpStartCharacter.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpStartCharacter.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSRegExpStartCharacter,
-	jsRegExpStartCharacter,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpStartCharacter, } from "@internal/ast";
 export default function JSRegExpStartCharacter(node: AnyNode) {
-	node = jsRegExpStartCharacter.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpStartCharacter.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpSubExpression.ts b/internal/js-analysis/evaluators/regex/JSRegExpSubExpression.ts
index f9a733bb0..2d7662754 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpSubExpression.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpSubExpression.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSRegExpSubExpression,
-	jsRegExpSubExpression,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpSubExpression, } from "@internal/ast";
 export default function JSRegExpSubExpression(node: AnyNode) {
-	node = jsRegExpSubExpression.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpSubExpression.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpWhiteSpaceCharacter.ts b/internal/js-analysis/evaluators/regex/JSRegExpWhiteSpaceCharacter.ts
index 6a3ef3889..30c441049 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpWhiteSpaceCharacter.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpWhiteSpaceCharacter.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSRegExpWhiteSpaceCharacter,
-	jsRegExpWhiteSpaceCharacter,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpWhiteSpaceCharacter, } from "@internal/ast";
 export default function JSRegExpWhiteSpaceCharacter(node: AnyNode) {
-	node = jsRegExpWhiteSpaceCharacter.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpWhiteSpaceCharacter.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpWordBoundaryCharacter.ts b/internal/js-analysis/evaluators/regex/JSRegExpWordBoundaryCharacter.ts
index 02777f3b3..f26938df9 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpWordBoundaryCharacter.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpWordBoundaryCharacter.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSRegExpWordBoundaryCharacter,
-	jsRegExpWordBoundaryCharacter,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpWordBoundaryCharacter, } from "@internal/ast";
 export default function JSRegExpWordBoundaryCharacter(node: AnyNode) {
-	node = jsRegExpWordBoundaryCharacter.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpWordBoundaryCharacter.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/regex/JSRegExpWordCharacter.ts b/internal/js-analysis/evaluators/regex/JSRegExpWordCharacter.ts
index 56a0f0889..a623490a0 100644
--- a/internal/js-analysis/evaluators/regex/JSRegExpWordCharacter.ts
+++ b/internal/js-analysis/evaluators/regex/JSRegExpWordCharacter.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSRegExpWordCharacter,
-	jsRegExpWordCharacter,
-} from "@internal/ast";
-
+import { AnyNode, jsRegExpWordCharacter, } from "@internal/ast";
 export default function JSRegExpWordCharacter(node: AnyNode) {
-	node = jsRegExpWordCharacter.assert(node);
-	throw new Error("unimplemented");
+    node = jsRegExpWordCharacter.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/statements/JSBlockStatement.ts b/internal/js-analysis/evaluators/statements/JSBlockStatement.ts
index 290341be0..b1add1702 100644
--- a/internal/js-analysis/evaluators/statements/JSBlockStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSBlockStatement.ts
@@ -4,64 +4,52 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSBlockStatement, jsBlockStatement} from "@internal/ast";
-import {getBindingIdentifiers, isTypeNode} from "@internal/js-ast-utils";
+import { Scope } from "../../scopes";
+import { AnyNode, jsBlockStatement } from "@internal/ast";
+import { getBindingIdentifiers, isTypeNode } from "@internal/js-ast-utils";
 import BlockT from "../../types/BlockT";
-
 function shouldHoistExecute(node: undefined | AnyNode): boolean {
-	if (node === undefined) {
-		return false;
-	}
-
-	if (node.type === "JSFunctionDeclaration" || isTypeNode(node)) {
-		return true;
-	}
-
-	if (
-		node.type === "JSExportLocalDeclaration" ||
-		node.type === "JSExportDefaultDeclaration"
-	) {
-		return shouldHoistExecute(node.declaration);
-	}
-
-	return false;
+    if (node === undefined) {
+        return false;
+    }
+    if (node.type === "JSFunctionDeclaration" || isTypeNode(node)) {
+        return true;
+    }
+    if (node.type === "JSExportLocalDeclaration" ||
+        node.type === "JSExportDefaultDeclaration") {
+        return shouldHoistExecute(node.declaration);
+    }
+    return false;
 }
-
 export default function JSBlockStatement(node: AnyNode, scope: Scope) {
-	node = node.type === "JSRoot" ? node : jsBlockStatement.assert(node);
-
-	// Declare variables
-	for (const child of node.body) {
-		if (child.type === "JSImportDeclaration") {
-			scope.evaluate(child);
-		}
-
-		const declarations = getBindingIdentifiers(child);
-		for (const id of declarations) {
-			scope.declareBinding(id.name, id);
-		}
-	}
-
-	const types = [];
-
-	// Execute hoisted nodes
-	const body = [];
-	for (const child of node.body) {
-		if (child.type === "JSImportDeclaration") {
-			// already executed
-		} else if (shouldHoistExecute(child)) {
-			types.push(scope.evaluate(child));
-		} else {
-			body.push(child);
-		}
-	}
-
-	// Execute rest
-	for (const child of body) {
-		types.push(scope.evaluate(child));
-	}
-
-	return new BlockT(scope, node, types);
+    node = node.type === "JSRoot" ? node : jsBlockStatement.assert(node);
+    // Declare variables
+    for (const child of node.body) {
+        if (child.type === "JSImportDeclaration") {
+            scope.evaluate(child);
+        }
+        const declarations = getBindingIdentifiers(child);
+        for (const id of declarations) {
+            scope.declareBinding(id.name, id);
+        }
+    }
+    const types = [];
+    // Execute hoisted nodes
+    const body = [];
+    for (const child of node.body) {
+        if (child.type === "JSImportDeclaration") {
+            // already executed
+        }
+        else if (shouldHoistExecute(child)) {
+            types.push(scope.evaluate(child));
+        }
+        else {
+            body.push(child);
+        }
+    }
+    // Execute rest
+    for (const child of body) {
+        types.push(scope.evaluate(child));
+    }
+    return new BlockT(scope, node, types);
 }
diff --git a/internal/js-analysis/evaluators/statements/JSBreakStatement.ts b/internal/js-analysis/evaluators/statements/JSBreakStatement.ts
index 465a4409c..179d91c24 100644
--- a/internal/js-analysis/evaluators/statements/JSBreakStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSBreakStatement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSBreakStatement, jsBreakStatement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsBreakStatement } from "@internal/ast";
 export default function JSBreakStatement(node: AnyNode, scope: Scope) {
-	node = jsBreakStatement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsBreakStatement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/statements/JSContinueStatement.ts b/internal/js-analysis/evaluators/statements/JSContinueStatement.ts
index 3d3a31bf5..ee97e5eb9 100644
--- a/internal/js-analysis/evaluators/statements/JSContinueStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSContinueStatement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSContinueStatement, jsContinueStatement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsContinueStatement } from "@internal/ast";
 export default function JSContinueStatement(node: AnyNode, scope: Scope) {
-	node = jsContinueStatement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsContinueStatement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/statements/JSDebuggerStatement.ts b/internal/js-analysis/evaluators/statements/JSDebuggerStatement.ts
index 0b0903740..c3f71bb4e 100644
--- a/internal/js-analysis/evaluators/statements/JSDebuggerStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSDebuggerStatement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSDebuggerStatement, jsDebuggerStatement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsDebuggerStatement } from "@internal/ast";
 export default function JSDebuggerStatement(node: AnyNode, scope: Scope) {
-	node = jsDebuggerStatement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsDebuggerStatement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/statements/JSDoWhileStatement.ts b/internal/js-analysis/evaluators/statements/JSDoWhileStatement.ts
index dbb0fbddd..3db8149c2 100644
--- a/internal/js-analysis/evaluators/statements/JSDoWhileStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSDoWhileStatement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSDoWhileStatement, jsDoWhileStatement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsDoWhileStatement } from "@internal/ast";
 export default function JSDoWhileStatement(node: AnyNode, scope: Scope) {
-	node = jsDoWhileStatement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsDoWhileStatement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/statements/JSEmptyStatement.ts b/internal/js-analysis/evaluators/statements/JSEmptyStatement.ts
index f122dc229..4b1f875a3 100644
--- a/internal/js-analysis/evaluators/statements/JSEmptyStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSEmptyStatement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSEmptyStatement, jsEmptyStatement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsEmptyStatement } from "@internal/ast";
 export default function JSEmptyStatement(node: AnyNode, scope: Scope) {
-	node = jsEmptyStatement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsEmptyStatement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/statements/JSExpressionStatement.ts b/internal/js-analysis/evaluators/statements/JSExpressionStatement.ts
index dcf8999bb..0a063907d 100644
--- a/internal/js-analysis/evaluators/statements/JSExpressionStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSExpressionStatement.ts
@@ -4,16 +4,9 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSExpressionStatement,
-	jsExpressionStatement,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsExpressionStatement, } from "@internal/ast";
 export default function JSExpressionStatement(node: AnyNode, scope: Scope) {
-	node = jsExpressionStatement.assert(node);
-
-	return scope.evaluate(node.expression);
+    node = jsExpressionStatement.assert(node);
+    return scope.evaluate(node.expression);
 }
diff --git a/internal/js-analysis/evaluators/statements/JSForInStatement.ts b/internal/js-analysis/evaluators/statements/JSForInStatement.ts
index 0cf12996e..61d236fcc 100644
--- a/internal/js-analysis/evaluators/statements/JSForInStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSForInStatement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSForInStatement, jsForInStatement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsForInStatement } from "@internal/ast";
 export default function JSForInStatement(node: AnyNode, scope: Scope) {
-	node = jsForInStatement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsForInStatement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/statements/JSForOfStatement.ts b/internal/js-analysis/evaluators/statements/JSForOfStatement.ts
index 2b80048e9..b9ae2db76 100644
--- a/internal/js-analysis/evaluators/statements/JSForOfStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSForOfStatement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSForOfStatement, jsForOfStatement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsForOfStatement } from "@internal/ast";
 export default function JSForOfStatement(node: AnyNode, scope: Scope) {
-	node = jsForOfStatement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsForOfStatement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/statements/JSForStatement.ts b/internal/js-analysis/evaluators/statements/JSForStatement.ts
index bc3289c46..624ed2a35 100644
--- a/internal/js-analysis/evaluators/statements/JSForStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSForStatement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSForStatement, jsForStatement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsForStatement } from "@internal/ast";
 export default function JSForStatement(node: AnyNode, scope: Scope) {
-	node = jsForStatement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsForStatement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/statements/JSFunctionDeclaration.ts b/internal/js-analysis/evaluators/statements/JSFunctionDeclaration.ts
index 2a3723f68..d7894abfa 100644
--- a/internal/js-analysis/evaluators/statements/JSFunctionDeclaration.ts
+++ b/internal/js-analysis/evaluators/statements/JSFunctionDeclaration.ts
@@ -4,21 +4,14 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	JSFunctionDeclaration,
-	jsFunctionDeclaration,
-} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, jsFunctionDeclaration, } from "@internal/ast";
 import executeFunction from "../../utils/executeFunction";
-
 export default function JSFunctionDeclaration(node: AnyNode, scope: Scope) {
-	node = jsFunctionDeclaration.assert(node);
-
-	const func = executeFunction(node, scope, false);
-	if (node.id !== undefined) {
-		scope.addBinding(node.id.name, func);
-	}
-	return func;
+    node = jsFunctionDeclaration.assert(node);
+    const func = executeFunction(node, scope, false);
+    if (node.id !== undefined) {
+        scope.addBinding(node.id.name, func);
+    }
+    return func;
 }
diff --git a/internal/js-analysis/evaluators/statements/JSIfStatement.ts b/internal/js-analysis/evaluators/statements/JSIfStatement.ts
index 779d808b5..6c530d94e 100644
--- a/internal/js-analysis/evaluators/statements/JSIfStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSIfStatement.ts
@@ -4,31 +4,25 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {RefineScope, Scope} from "../../scopes";
-import {AnyNode, JSIfStatement, jsIfStatement} from "@internal/ast";
+import { RefineScope, Scope } from "../../scopes";
+import { AnyNode, jsIfStatement } from "@internal/ast";
 import BooleanT from "../../types/BooleanT";
 import ExhaustiveT from "../../types/ExhaustiveT";
 import UnionT from "../../types/UnionT";
-
 export default function JSIfStatement(node: AnyNode, scope: Scope) {
-	node =
-		node.type === "JSConditionalExpression" ? node : jsIfStatement.assert(node);
-
-	const test = scope.evaluate(node.test);
-	new ExhaustiveT(scope, node, test, new BooleanT(scope, undefined));
-
-	const hasRefinedTest: boolean = test.scope instanceof RefineScope;
-
-	const consequentScope: Scope = hasRefinedTest ? test.scope : scope;
-	const consequent = consequentScope.evaluate(node.consequent);
-
-	if (node.alternate === undefined) {
-		return consequent;
-	} else {
-		const alternateScope = scope.fork();
-
-		/*if (hasRefinedTest) {
+    node =
+        node.type === "JSConditionalExpression" ? node : jsIfStatement.assert(node);
+    const test = scope.evaluate(node.test);
+    new ExhaustiveT(scope, node, test, new BooleanT(scope, undefined));
+    const hasRefinedTest: boolean = test.scope instanceof RefineScope;
+    const consequentScope: Scope = hasRefinedTest ? test.scope : scope;
+    const consequent = consequentScope.evaluate(node.consequent);
+    if (node.alternate === undefined) {
+        return consequent;
+    }
+    else {
+        const alternateScope = scope.fork();
+        /*if (hasRefinedTest) {
       // get bindings from 'test.scope and flip them
       for (const name of test.scope.getOwnBindingNames()) {
         const outerBinding = scope.getBinding(name);
@@ -41,10 +35,6 @@ export default function JSIfStatement(node: AnyNode, scope: Scope) {
         alternateScope.addBinding(name, opposite);
       }
     }*/
-		return new UnionT(
-			scope,
-			undefined,
-			[consequent, alternateScope.evaluate(node.alternate)],
-		);
-	}
+        return new UnionT(scope, undefined, [consequent, alternateScope.evaluate(node.alternate)]);
+    }
 }
diff --git a/internal/js-analysis/evaluators/statements/JSLabeledStatement.ts b/internal/js-analysis/evaluators/statements/JSLabeledStatement.ts
index c579fc8c4..2b345b893 100644
--- a/internal/js-analysis/evaluators/statements/JSLabeledStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSLabeledStatement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSLabeledStatement, jsLabeledStatement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsLabeledStatement } from "@internal/ast";
 export default function JSLabeledStatement(node: AnyNode, scope: Scope) {
-	node = jsLabeledStatement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsLabeledStatement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/statements/JSReturnStatement.ts b/internal/js-analysis/evaluators/statements/JSReturnStatement.ts
index ebe09f22f..79fdc9c77 100644
--- a/internal/js-analysis/evaluators/statements/JSReturnStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSReturnStatement.ts
@@ -4,17 +4,16 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {FunctionScope, Scope} from "../../scopes";
-import {AnyNode, JSReturnStatement, jsReturnStatement} from "@internal/ast";
-
+import { FunctionScope, Scope } from "../../scopes";
+import { AnyNode, jsReturnStatement } from "@internal/ast";
 export default function JSReturnStatement(node: AnyNode, scope: Scope) {
-	node = jsReturnStatement.assert(node);
-	const funcScope = scope.find(FunctionScope);
-	if (node.argument === undefined) {
-		// TODO connect to undefined
-	} else {
-		const type = scope.evaluate(node.argument);
-		funcScope.meta.returnType.shouldMatch(type);
-	}
+    node = jsReturnStatement.assert(node);
+    const funcScope = scope.find(FunctionScope);
+    if (node.argument === undefined) {
+        // TODO connect to undefined
+    }
+    else {
+        const type = scope.evaluate(node.argument);
+        funcScope.meta.returnType.shouldMatch(type);
+    }
 }
diff --git a/internal/js-analysis/evaluators/statements/JSSwitchStatement.ts b/internal/js-analysis/evaluators/statements/JSSwitchStatement.ts
index ab29e5072..ec1249d06 100644
--- a/internal/js-analysis/evaluators/statements/JSSwitchStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSSwitchStatement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSSwitchStatement, jsSwitchStatement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsSwitchStatement } from "@internal/ast";
 export default function JSSwitchStatement(node: AnyNode, scope: Scope) {
-	node = jsSwitchStatement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsSwitchStatement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/statements/JSThrowStatement.ts b/internal/js-analysis/evaluators/statements/JSThrowStatement.ts
index afefac127..8c1e8128a 100644
--- a/internal/js-analysis/evaluators/statements/JSThrowStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSThrowStatement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSThrowStatement, jsThrowStatement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsThrowStatement } from "@internal/ast";
 export default function JSThrowStatement(node: AnyNode, scope: Scope) {
-	node = jsThrowStatement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsThrowStatement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/statements/JSTryStatement.ts b/internal/js-analysis/evaluators/statements/JSTryStatement.ts
index 698b3e6f3..45a137510 100644
--- a/internal/js-analysis/evaluators/statements/JSTryStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSTryStatement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSTryStatement, jsTryStatement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsTryStatement } from "@internal/ast";
 export default function JSTryStatement(node: AnyNode, scope: Scope) {
-	node = jsTryStatement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsTryStatement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/statements/JSVariableDeclarationStatement.ts b/internal/js-analysis/evaluators/statements/JSVariableDeclarationStatement.ts
index 52fc55fcf..706fbc9b2 100644
--- a/internal/js-analysis/evaluators/statements/JSVariableDeclarationStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSVariableDeclarationStatement.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSVariableDeclarationStatement,
-	jsVariableDeclarationStatement,
-} from "@internal/ast";
-
+import { AnyNode, jsVariableDeclarationStatement, } from "@internal/ast";
 export default function JSVariableDeclarationStatement(node: AnyNode) {
-	node = jsVariableDeclarationStatement.assert(node);
-	throw new Error("unimplemented");
+    node = jsVariableDeclarationStatement.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/statements/JSWhileStatement.ts b/internal/js-analysis/evaluators/statements/JSWhileStatement.ts
index 7c0c079df..0204359df 100644
--- a/internal/js-analysis/evaluators/statements/JSWhileStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSWhileStatement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSWhileStatement, jsWhileStatement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsWhileStatement } from "@internal/ast";
 export default function JSWhileStatement(node: AnyNode, scope: Scope) {
-	node = jsWhileStatement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsWhileStatement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/statements/JSWithStatement.ts b/internal/js-analysis/evaluators/statements/JSWithStatement.ts
index 1db8d6383..fdf771833 100644
--- a/internal/js-analysis/evaluators/statements/JSWithStatement.ts
+++ b/internal/js-analysis/evaluators/statements/JSWithStatement.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, JSWithStatement, jsWithStatement} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, jsWithStatement } from "@internal/ast";
 export default function JSWithStatement(node: AnyNode, scope: Scope) {
-	node = jsWithStatement.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = jsWithStatement.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/temp/JSAmbiguousFlowTypeCastExpression.ts b/internal/js-analysis/evaluators/temp/JSAmbiguousFlowTypeCastExpression.ts
index 4f6069dc6..3e6cbaa4a 100644
--- a/internal/js-analysis/evaluators/temp/JSAmbiguousFlowTypeCastExpression.ts
+++ b/internal/js-analysis/evaluators/temp/JSAmbiguousFlowTypeCastExpression.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	JSAmbiguousFlowTypeCastExpression,
-	jsAmbiguousFlowTypeCastExpression,
-} from "@internal/ast";
-
+import { AnyNode, jsAmbiguousFlowTypeCastExpression, } from "@internal/ast";
 export default function JSAmbiguousFlowTypeCastExpression(node: AnyNode) {
-	node = jsAmbiguousFlowTypeCastExpression.assert(node);
-	throw new Error("unimplemented");
+    node = jsAmbiguousFlowTypeCastExpression.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSAnyKeywordTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSAnyKeywordTypeAnnotation.ts
index 4cec2b95d..642646230 100644
--- a/internal/js-analysis/evaluators/typescript/TSAnyKeywordTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSAnyKeywordTypeAnnotation.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSAnyKeywordTypeAnnotation,
-	tsAnyKeywordTypeAnnotation,
-} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, tsAnyKeywordTypeAnnotation, } from "@internal/ast";
 import AnyT from "../../types/AnyT";
-
 export default function TSAnyKeywordTypeAnnotation(node: AnyNode, scope: Scope) {
-	node = tsAnyKeywordTypeAnnotation.assert(node);
-	return new AnyT(scope, node);
+    node = tsAnyKeywordTypeAnnotation.assert(node);
+    return new AnyT(scope, node);
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSArrayType.ts b/internal/js-analysis/evaluators/typescript/TSArrayType.ts
index 3dfa5e498..4614bf153 100644
--- a/internal/js-analysis/evaluators/typescript/TSArrayType.ts
+++ b/internal/js-analysis/evaluators/typescript/TSArrayType.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSArrayType, tsArrayType} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsArrayType } from "@internal/ast";
 export default function TSArrayType(node: AnyNode, scope: Scope) {
-	node = tsArrayType.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsArrayType.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSAsExpression.ts b/internal/js-analysis/evaluators/typescript/TSAsExpression.ts
index eed5d655a..c34ee23c9 100644
--- a/internal/js-analysis/evaluators/typescript/TSAsExpression.ts
+++ b/internal/js-analysis/evaluators/typescript/TSAsExpression.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSAsExpression, tsAsExpression} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsAsExpression } from "@internal/ast";
 export default function TSAsExpression(node: AnyNode, scope: Scope) {
-	node = tsAsExpression.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsAsExpression.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSAssignmentAsExpression.ts b/internal/js-analysis/evaluators/typescript/TSAssignmentAsExpression.ts
index 819e6863d..e5c52ecaa 100644
--- a/internal/js-analysis/evaluators/typescript/TSAssignmentAsExpression.ts
+++ b/internal/js-analysis/evaluators/typescript/TSAssignmentAsExpression.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	TSAssignmentAsExpression,
-	tsAssignmentAsExpression,
-} from "@internal/ast";
-
+import { AnyNode, tsAssignmentAsExpression, } from "@internal/ast";
 export default function TSAssignmentAsExpression(node: AnyNode) {
-	node = tsAssignmentAsExpression.assert(node);
-	throw new Error("unimplemented");
+    node = tsAssignmentAsExpression.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSAssignmentNonNullExpression.ts b/internal/js-analysis/evaluators/typescript/TSAssignmentNonNullExpression.ts
index 1cc71cf95..dd0866d2f 100644
--- a/internal/js-analysis/evaluators/typescript/TSAssignmentNonNullExpression.ts
+++ b/internal/js-analysis/evaluators/typescript/TSAssignmentNonNullExpression.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	TSAssignmentNonNullExpression,
-	tsAssignmentNonNullExpression,
-} from "@internal/ast";
-
+import { AnyNode, tsAssignmentNonNullExpression, } from "@internal/ast";
 export default function TSAssignmentNonNullExpression(node: AnyNode) {
-	node = tsAssignmentNonNullExpression.assert(node);
-	throw new Error("unimplemented");
+    node = tsAssignmentNonNullExpression.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSAssignmentTypeAssertion.ts b/internal/js-analysis/evaluators/typescript/TSAssignmentTypeAssertion.ts
index f09a37d72..da13fe638 100644
--- a/internal/js-analysis/evaluators/typescript/TSAssignmentTypeAssertion.ts
+++ b/internal/js-analysis/evaluators/typescript/TSAssignmentTypeAssertion.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	TSAssignmentTypeAssertion,
-	tsAssignmentTypeAssertion,
-} from "@internal/ast";
-
+import { AnyNode, tsAssignmentTypeAssertion, } from "@internal/ast";
 export default function TSAssignmentTypeAssertion(node: AnyNode) {
-	node = tsAssignmentTypeAssertion.assert(node);
-	throw new Error("unimplemented");
+    node = tsAssignmentTypeAssertion.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSBigIntKeywordTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSBigIntKeywordTypeAnnotation.ts
index 9c9304562..aebc9c0fe 100644
--- a/internal/js-analysis/evaluators/typescript/TSBigIntKeywordTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSBigIntKeywordTypeAnnotation.ts
@@ -4,19 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSBigIntKeywordTypeAnnotation,
-	tsBigIntKeywordTypeAnnotation,
-} from "@internal/ast";
-
-export default function TSBigIntKeywordTypeAnnotation(
-	node: AnyNode,
-	scope: Scope,
-) {
-	node = tsBigIntKeywordTypeAnnotation.assert(node);
-	scope;
-	throw new Error("unimplemented");
+import { Scope } from "../../scopes";
+import { AnyNode, tsBigIntKeywordTypeAnnotation, } from "@internal/ast";
+export default function TSBigIntKeywordTypeAnnotation(node: AnyNode, scope: Scope) {
+    node = tsBigIntKeywordTypeAnnotation.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSBigIntLiteralTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSBigIntLiteralTypeAnnotation.ts
index ae919c28b..33c9f223a 100644
--- a/internal/js-analysis/evaluators/typescript/TSBigIntLiteralTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSBigIntLiteralTypeAnnotation.ts
@@ -1,10 +1,5 @@
-import {
-	AnyNode,
-	TSBigIntLiteralTypeAnnotation,
-	tsBigIntLiteralTypeAnnotation,
-} from "@internal/ast";
-
+import { AnyNode, tsBigIntLiteralTypeAnnotation, } from "@internal/ast";
 export default function TSBigIntLiteralTypeAnnotation(node: AnyNode) {
-	node = tsBigIntLiteralTypeAnnotation.assert(node);
-	throw new Error("unimplemented");
+    node = tsBigIntLiteralTypeAnnotation.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSBooleanKeywordTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSBooleanKeywordTypeAnnotation.ts
index 30f68f7a9..1e1734011 100644
--- a/internal/js-analysis/evaluators/typescript/TSBooleanKeywordTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSBooleanKeywordTypeAnnotation.ts
@@ -4,19 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSBooleanKeywordTypeAnnotation,
-	tsBooleanKeywordTypeAnnotation,
-} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, tsBooleanKeywordTypeAnnotation, } from "@internal/ast";
 import BooleanT from "../../types/BooleanT";
-
-export default function TSBooleanKeywordTypeAnnotation(
-	node: AnyNode,
-	scope: Scope,
-) {
-	node = tsBooleanKeywordTypeAnnotation.assert(node);
-	return new BooleanT(scope, node);
+export default function TSBooleanKeywordTypeAnnotation(node: AnyNode, scope: Scope) {
+    node = tsBooleanKeywordTypeAnnotation.assert(node);
+    return new BooleanT(scope, node);
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSBooleanLiteralTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSBooleanLiteralTypeAnnotation.ts
index ce5904e0f..546998b0c 100644
--- a/internal/js-analysis/evaluators/typescript/TSBooleanLiteralTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSBooleanLiteralTypeAnnotation.ts
@@ -4,19 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSBooleanLiteralTypeAnnotation,
-	tsBooleanLiteralTypeAnnotation,
-} from "@internal/ast";
-
-export default function TSBooleanLiteralTypeAnnotation(
-	node: AnyNode,
-	scope: Scope,
-) {
-	node = tsBooleanLiteralTypeAnnotation.assert(node);
-	scope;
-	throw new Error("unimplemented");
+import { Scope } from "../../scopes";
+import { AnyNode, tsBooleanLiteralTypeAnnotation, } from "@internal/ast";
+export default function TSBooleanLiteralTypeAnnotation(node: AnyNode, scope: Scope) {
+    node = tsBooleanLiteralTypeAnnotation.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSCallSignatureDeclaration.ts b/internal/js-analysis/evaluators/typescript/TSCallSignatureDeclaration.ts
index 1159de6aa..955edfb6d 100644
--- a/internal/js-analysis/evaluators/typescript/TSCallSignatureDeclaration.ts
+++ b/internal/js-analysis/evaluators/typescript/TSCallSignatureDeclaration.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	TSCallSignatureDeclaration,
-	tsCallSignatureDeclaration,
-} from "@internal/ast";
-
+import { AnyNode, tsCallSignatureDeclaration, } from "@internal/ast";
 export default function TSCallSignatureDeclaration(node: AnyNode) {
-	node = tsCallSignatureDeclaration.assert(node);
-	throw new Error("unimplemented");
+    node = tsCallSignatureDeclaration.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSConditionalType.ts b/internal/js-analysis/evaluators/typescript/TSConditionalType.ts
index 0ec4f6bd8..21c36d044 100644
--- a/internal/js-analysis/evaluators/typescript/TSConditionalType.ts
+++ b/internal/js-analysis/evaluators/typescript/TSConditionalType.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSConditionalType, tsConditionalType} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsConditionalType } from "@internal/ast";
 export default function TSConditionalType(node: AnyNode, scope: Scope) {
-	node = tsConditionalType.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsConditionalType.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSConstKeyword.ts b/internal/js-analysis/evaluators/typescript/TSConstKeyword.ts
index 186aa07f7..bc0b65471 100644
--- a/internal/js-analysis/evaluators/typescript/TSConstKeyword.ts
+++ b/internal/js-analysis/evaluators/typescript/TSConstKeyword.ts
@@ -1,8 +1,7 @@
-import {Scope} from "../../scopes";
-import {AnyNode, TSConstKeyword, tsConstKeyword} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsConstKeyword } from "@internal/ast";
 export default function TSConstKeyword(node: AnyNode, scope: Scope) {
-	node = tsConstKeyword.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsConstKeyword.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSConstructSignatureDeclaration.ts b/internal/js-analysis/evaluators/typescript/TSConstructSignatureDeclaration.ts
index 8779dd79a..5b5653232 100644
--- a/internal/js-analysis/evaluators/typescript/TSConstructSignatureDeclaration.ts
+++ b/internal/js-analysis/evaluators/typescript/TSConstructSignatureDeclaration.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	TSConstructSignatureDeclaration,
-	tsConstructSignatureDeclaration,
-} from "@internal/ast";
-
+import { AnyNode, tsConstructSignatureDeclaration, } from "@internal/ast";
 export default function TSConstructSignatureDeclaration(node: AnyNode) {
-	node = tsConstructSignatureDeclaration.assert(node);
-	throw new Error("unimplemented");
+    node = tsConstructSignatureDeclaration.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSConstructorType.ts b/internal/js-analysis/evaluators/typescript/TSConstructorType.ts
index fcf3f7a11..c934ff2d4 100644
--- a/internal/js-analysis/evaluators/typescript/TSConstructorType.ts
+++ b/internal/js-analysis/evaluators/typescript/TSConstructorType.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSConstructorType, tsConstructorType} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsConstructorType } from "@internal/ast";
 export default function TSConstructorType(node: AnyNode, scope: Scope) {
-	node = tsConstructorType.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsConstructorType.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSDeclareFunction.ts b/internal/js-analysis/evaluators/typescript/TSDeclareFunction.ts
index 13b0dd0bf..7879269d8 100644
--- a/internal/js-analysis/evaluators/typescript/TSDeclareFunction.ts
+++ b/internal/js-analysis/evaluators/typescript/TSDeclareFunction.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSDeclareFunction, tsDeclareFunction} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsDeclareFunction } from "@internal/ast";
 export default function TSDeclareFunction(node: AnyNode, scope: Scope) {
-	node = tsDeclareFunction.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsDeclareFunction.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSDeclareMethod.ts b/internal/js-analysis/evaluators/typescript/TSDeclareMethod.ts
index aaeae458a..664ed71d8 100644
--- a/internal/js-analysis/evaluators/typescript/TSDeclareMethod.ts
+++ b/internal/js-analysis/evaluators/typescript/TSDeclareMethod.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSDeclareMethod, tsDeclareMethod} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsDeclareMethod } from "@internal/ast";
 export default function TSDeclareMethod(node: AnyNode, scope: Scope) {
-	node = tsDeclareMethod.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsDeclareMethod.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSEmptyKeywordTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSEmptyKeywordTypeAnnotation.ts
index 720b20c7b..897564bac 100644
--- a/internal/js-analysis/evaluators/typescript/TSEmptyKeywordTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSEmptyKeywordTypeAnnotation.ts
@@ -4,19 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSEmptyKeywordTypeAnnotation,
-	tsEmptyKeywordTypeAnnotation,
-} from "@internal/ast";
-
-export default function TSEmptyKeywordTypeAnnotation(
-	node: AnyNode,
-	scope: Scope,
-) {
-	node = tsEmptyKeywordTypeAnnotation.assert(node);
-	scope;
-	throw new Error("unimplemented");
+import { Scope } from "../../scopes";
+import { AnyNode, tsEmptyKeywordTypeAnnotation, } from "@internal/ast";
+export default function TSEmptyKeywordTypeAnnotation(node: AnyNode, scope: Scope) {
+    node = tsEmptyKeywordTypeAnnotation.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSEnumDeclaration.ts b/internal/js-analysis/evaluators/typescript/TSEnumDeclaration.ts
index b7ebbc21d..fbc6ebb37 100644
--- a/internal/js-analysis/evaluators/typescript/TSEnumDeclaration.ts
+++ b/internal/js-analysis/evaluators/typescript/TSEnumDeclaration.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSEnumDeclaration, tsEnumDeclaration} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsEnumDeclaration } from "@internal/ast";
 export default function TSEnumDeclaration(node: AnyNode, scope: Scope) {
-	node = tsEnumDeclaration.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsEnumDeclaration.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSEnumMember.ts b/internal/js-analysis/evaluators/typescript/TSEnumMember.ts
index 0512d0e32..42ed0a830 100644
--- a/internal/js-analysis/evaluators/typescript/TSEnumMember.ts
+++ b/internal/js-analysis/evaluators/typescript/TSEnumMember.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSEnumMember, tsEnumMember} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsEnumMember } from "@internal/ast";
 export default function TSEnumMember(node: AnyNode, scope: Scope) {
-	node = tsEnumMember.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsEnumMember.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSExportAssignment.ts b/internal/js-analysis/evaluators/typescript/TSExportAssignment.ts
index 067dc01e0..9439f1b22 100644
--- a/internal/js-analysis/evaluators/typescript/TSExportAssignment.ts
+++ b/internal/js-analysis/evaluators/typescript/TSExportAssignment.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSExportAssignment, tsExportAssignment} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsExportAssignment } from "@internal/ast";
 export default function TSExportAssignment(node: AnyNode, scope: Scope) {
-	node = tsExportAssignment.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsExportAssignment.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSExpressionWithTypeArguments.ts b/internal/js-analysis/evaluators/typescript/TSExpressionWithTypeArguments.ts
index fbe48b844..2c40d2c3b 100644
--- a/internal/js-analysis/evaluators/typescript/TSExpressionWithTypeArguments.ts
+++ b/internal/js-analysis/evaluators/typescript/TSExpressionWithTypeArguments.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	TSExpressionWithTypeArguments,
-	tsExpressionWithTypeArguments,
-} from "@internal/ast";
-
+import { AnyNode, tsExpressionWithTypeArguments, } from "@internal/ast";
 export default function TSExpressionWithTypeArguments(node: AnyNode) {
-	node = tsExpressionWithTypeArguments.assert(node);
-	throw new Error("unimplemented");
+    node = tsExpressionWithTypeArguments.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSExternalModuleReference.ts b/internal/js-analysis/evaluators/typescript/TSExternalModuleReference.ts
index 9ae3359ee..124b4aeef 100644
--- a/internal/js-analysis/evaluators/typescript/TSExternalModuleReference.ts
+++ b/internal/js-analysis/evaluators/typescript/TSExternalModuleReference.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	TSExternalModuleReference,
-	tsExternalModuleReference,
-} from "@internal/ast";
-
+import { AnyNode, tsExternalModuleReference, } from "@internal/ast";
 export default function TSExternalModuleReference(node: AnyNode) {
-	node = tsExternalModuleReference.assert(node);
-	throw new Error("unimplemented");
+    node = tsExternalModuleReference.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSFunctionType.ts b/internal/js-analysis/evaluators/typescript/TSFunctionType.ts
index 309369df5..6e9ba2a41 100644
--- a/internal/js-analysis/evaluators/typescript/TSFunctionType.ts
+++ b/internal/js-analysis/evaluators/typescript/TSFunctionType.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSFunctionType, tsFunctionType} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsFunctionType } from "@internal/ast";
 export default function TSFunctionType(node: AnyNode, scope: Scope) {
-	node = tsFunctionType.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsFunctionType.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSImportEqualsDeclaration.ts b/internal/js-analysis/evaluators/typescript/TSImportEqualsDeclaration.ts
index 42aa5ad00..5a4655375 100644
--- a/internal/js-analysis/evaluators/typescript/TSImportEqualsDeclaration.ts
+++ b/internal/js-analysis/evaluators/typescript/TSImportEqualsDeclaration.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	TSImportEqualsDeclaration,
-	tsImportEqualsDeclaration,
-} from "@internal/ast";
-
+import { AnyNode, tsImportEqualsDeclaration, } from "@internal/ast";
 export default function TSImportEqualsDeclaration(node: AnyNode) {
-	node = tsImportEqualsDeclaration.assert(node);
-	throw new Error("unimplemented");
+    node = tsImportEqualsDeclaration.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSImportType.ts b/internal/js-analysis/evaluators/typescript/TSImportType.ts
index 4b212261c..a1cb17943 100644
--- a/internal/js-analysis/evaluators/typescript/TSImportType.ts
+++ b/internal/js-analysis/evaluators/typescript/TSImportType.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSImportType, tsImportType} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsImportType } from "@internal/ast";
 export default function TSImportType(node: AnyNode, scope: Scope) {
-	node = tsImportType.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsImportType.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSIndexSignature.ts b/internal/js-analysis/evaluators/typescript/TSIndexSignature.ts
index 4d82bc457..797d1405d 100644
--- a/internal/js-analysis/evaluators/typescript/TSIndexSignature.ts
+++ b/internal/js-analysis/evaluators/typescript/TSIndexSignature.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSIndexSignature, tsIndexSignature} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsIndexSignature } from "@internal/ast";
 export default function TSIndexSignature(node: AnyNode, scope: Scope) {
-	node = tsIndexSignature.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsIndexSignature.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSIndexedAccessType.ts b/internal/js-analysis/evaluators/typescript/TSIndexedAccessType.ts
index 8f72facc9..866565266 100644
--- a/internal/js-analysis/evaluators/typescript/TSIndexedAccessType.ts
+++ b/internal/js-analysis/evaluators/typescript/TSIndexedAccessType.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSIndexedAccessType, tsIndexedAccessType} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsIndexedAccessType } from "@internal/ast";
 export default function TSIndexedAccessType(node: AnyNode, scope: Scope) {
-	node = tsIndexedAccessType.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsIndexedAccessType.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSInferType.ts b/internal/js-analysis/evaluators/typescript/TSInferType.ts
index d13e639ae..659dab959 100644
--- a/internal/js-analysis/evaluators/typescript/TSInferType.ts
+++ b/internal/js-analysis/evaluators/typescript/TSInferType.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSInferType, tsInferType} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsInferType } from "@internal/ast";
 export default function TSInferType(node: AnyNode, scope: Scope) {
-	node = tsInferType.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsInferType.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSInterfaceBody.ts b/internal/js-analysis/evaluators/typescript/TSInterfaceBody.ts
index 796f035f7..686e03d68 100644
--- a/internal/js-analysis/evaluators/typescript/TSInterfaceBody.ts
+++ b/internal/js-analysis/evaluators/typescript/TSInterfaceBody.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSInterfaceBody, tsInterfaceBody} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsInterfaceBody } from "@internal/ast";
 export default function TSInterfaceBody(node: AnyNode, scope: Scope) {
-	node = tsInterfaceBody.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsInterfaceBody.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSInterfaceDeclaration.ts b/internal/js-analysis/evaluators/typescript/TSInterfaceDeclaration.ts
index 59aaeb2bb..62b26faef 100644
--- a/internal/js-analysis/evaluators/typescript/TSInterfaceDeclaration.ts
+++ b/internal/js-analysis/evaluators/typescript/TSInterfaceDeclaration.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSInterfaceDeclaration,
-	tsInterfaceDeclaration,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsInterfaceDeclaration, } from "@internal/ast";
 export default function TSInterfaceDeclaration(node: AnyNode, scope: Scope) {
-	node = tsInterfaceDeclaration.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsInterfaceDeclaration.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSIntersectionTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSIntersectionTypeAnnotation.ts
index d9d4e8b02..6b3f5565e 100644
--- a/internal/js-analysis/evaluators/typescript/TSIntersectionTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSIntersectionTypeAnnotation.ts
@@ -4,26 +4,12 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSIntersectionTypeAnnotation,
-	tsIntersectionTypeAnnotation,
-} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, tsIntersectionTypeAnnotation, } from "@internal/ast";
 import IntersectionT from "../../types/IntersectionT";
-
-export default function TSIntersectionTypeAnnotation(
-	node: AnyNode,
-	scope: Scope,
-) {
-	node = tsIntersectionTypeAnnotation.assert(node);
-
-	return new IntersectionT(
-		scope,
-		node,
-		node.types.map((type) => {
-			return scope.evaluate(type);
-		}),
-	);
+export default function TSIntersectionTypeAnnotation(node: AnyNode, scope: Scope) {
+    node = tsIntersectionTypeAnnotation.assert(node);
+    return new IntersectionT(scope, node, node.types.map((type) => {
+        return scope.evaluate(type);
+    }));
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSMappedType.ts b/internal/js-analysis/evaluators/typescript/TSMappedType.ts
index 6f7eb1479..b0d9bcbca 100644
--- a/internal/js-analysis/evaluators/typescript/TSMappedType.ts
+++ b/internal/js-analysis/evaluators/typescript/TSMappedType.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSMappedType, tsMappedType} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsMappedType } from "@internal/ast";
 export default function TSMappedType(node: AnyNode, scope: Scope) {
-	node = tsMappedType.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsMappedType.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSMethodSignature.ts b/internal/js-analysis/evaluators/typescript/TSMethodSignature.ts
index 4af32d4df..4bf323890 100644
--- a/internal/js-analysis/evaluators/typescript/TSMethodSignature.ts
+++ b/internal/js-analysis/evaluators/typescript/TSMethodSignature.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSMethodSignature, tsMethodSignature} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsMethodSignature } from "@internal/ast";
 export default function TSMethodSignature(node: AnyNode, scope: Scope) {
-	node = tsMethodSignature.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsMethodSignature.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSMixedKeywordTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSMixedKeywordTypeAnnotation.ts
index e7795fa7f..0a064e57d 100644
--- a/internal/js-analysis/evaluators/typescript/TSMixedKeywordTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSMixedKeywordTypeAnnotation.ts
@@ -4,19 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSMixedKeywordTypeAnnotation,
-	tsMixedKeywordTypeAnnotation,
-} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, tsMixedKeywordTypeAnnotation, } from "@internal/ast";
 import MixedT from "../../types/MixedT";
-
-export default function TSMixedKeywordTypeAnnotation(
-	node: AnyNode,
-	scope: Scope,
-) {
-	node = tsMixedKeywordTypeAnnotation.assert(node);
-	return new MixedT(scope, node);
+export default function TSMixedKeywordTypeAnnotation(node: AnyNode, scope: Scope) {
+    node = tsMixedKeywordTypeAnnotation.assert(node);
+    return new MixedT(scope, node);
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSModuleBlock.ts b/internal/js-analysis/evaluators/typescript/TSModuleBlock.ts
index b96aa0af8..b7730bdf0 100644
--- a/internal/js-analysis/evaluators/typescript/TSModuleBlock.ts
+++ b/internal/js-analysis/evaluators/typescript/TSModuleBlock.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSModuleBlock, tsModuleBlock} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsModuleBlock } from "@internal/ast";
 export default function TSModuleBlock(node: AnyNode, scope: Scope) {
-	node = tsModuleBlock.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsModuleBlock.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSModuleDeclaration.ts b/internal/js-analysis/evaluators/typescript/TSModuleDeclaration.ts
index b58d3ee21..903f95ee1 100644
--- a/internal/js-analysis/evaluators/typescript/TSModuleDeclaration.ts
+++ b/internal/js-analysis/evaluators/typescript/TSModuleDeclaration.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSModuleDeclaration, tsModuleDeclaration} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsModuleDeclaration } from "@internal/ast";
 export default function TSModuleDeclaration(node: AnyNode, scope: Scope) {
-	node = tsModuleDeclaration.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsModuleDeclaration.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSNamespaceExportDeclaration.ts b/internal/js-analysis/evaluators/typescript/TSNamespaceExportDeclaration.ts
index 30de85be4..d19b0c615 100644
--- a/internal/js-analysis/evaluators/typescript/TSNamespaceExportDeclaration.ts
+++ b/internal/js-analysis/evaluators/typescript/TSNamespaceExportDeclaration.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	TSNamespaceExportDeclaration,
-	tsNamespaceExportDeclaration,
-} from "@internal/ast";
-
+import { AnyNode, tsNamespaceExportDeclaration, } from "@internal/ast";
 export default function TSNamespaceExportDeclaration(node: AnyNode) {
-	node = tsNamespaceExportDeclaration.assert(node);
-	throw new Error("unimplemented");
+    node = tsNamespaceExportDeclaration.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSNeverKeywordTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSNeverKeywordTypeAnnotation.ts
index 8632b9d59..85f4bd5ab 100644
--- a/internal/js-analysis/evaluators/typescript/TSNeverKeywordTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSNeverKeywordTypeAnnotation.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	TSNeverKeywordTypeAnnotation,
-	tsNeverKeywordTypeAnnotation,
-} from "@internal/ast";
-
+import { AnyNode, tsNeverKeywordTypeAnnotation, } from "@internal/ast";
 export default function TSNeverKeywordTypeAnnotation(node: AnyNode) {
-	node = tsNeverKeywordTypeAnnotation.assert(node);
-	throw new Error("unimplemented");
+    node = tsNeverKeywordTypeAnnotation.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSNonNullExpression.ts b/internal/js-analysis/evaluators/typescript/TSNonNullExpression.ts
index 6ab458469..76a13b5e5 100644
--- a/internal/js-analysis/evaluators/typescript/TSNonNullExpression.ts
+++ b/internal/js-analysis/evaluators/typescript/TSNonNullExpression.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSNonNullExpression, tsNonNullExpression} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsNonNullExpression } from "@internal/ast";
 export default function TSNonNullExpression(node: AnyNode, scope: Scope) {
-	node = tsNonNullExpression.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsNonNullExpression.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSNullKeywordTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSNullKeywordTypeAnnotation.ts
index ad72b79fb..023318e6a 100644
--- a/internal/js-analysis/evaluators/typescript/TSNullKeywordTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSNullKeywordTypeAnnotation.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSNullKeywordTypeAnnotation,
-	tsNullKeywordTypeAnnotation,
-} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, tsNullKeywordTypeAnnotation, } from "@internal/ast";
 import NullT from "../../types/NullT";
-
 export default function TSNullKeywordTypeAnnotation(node: AnyNode, scope: Scope) {
-	node = tsNullKeywordTypeAnnotation.assert(node);
-	return new NullT(scope, node);
+    node = tsNullKeywordTypeAnnotation.assert(node);
+    return new NullT(scope, node);
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSNumberKeywordTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSNumberKeywordTypeAnnotation.ts
index 3f852cfd7..579b6b756 100644
--- a/internal/js-analysis/evaluators/typescript/TSNumberKeywordTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSNumberKeywordTypeAnnotation.ts
@@ -4,19 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSNumberKeywordTypeAnnotation,
-	tsNumberKeywordTypeAnnotation,
-} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, tsNumberKeywordTypeAnnotation, } from "@internal/ast";
 import NumericT from "../../types/NumericT";
-
-export default function TSNumberKeywordTypeAnnotation(
-	node: AnyNode,
-	scope: Scope,
-) {
-	node = tsNumberKeywordTypeAnnotation.assert(node);
-	return new NumericT(scope, node);
+export default function TSNumberKeywordTypeAnnotation(node: AnyNode, scope: Scope) {
+    node = tsNumberKeywordTypeAnnotation.assert(node);
+    return new NumericT(scope, node);
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSNumericLiteralTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSNumericLiteralTypeAnnotation.ts
index a6b06609a..3471c9014 100644
--- a/internal/js-analysis/evaluators/typescript/TSNumericLiteralTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSNumericLiteralTypeAnnotation.ts
@@ -4,19 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSNumericLiteralTypeAnnotation,
-	tsNumericLiteralTypeAnnotation,
-} from "@internal/ast";
-
-export default function TSNumericLiteralTypeAnnotation(
-	node: AnyNode,
-	scope: Scope,
-) {
-	node = tsNumericLiteralTypeAnnotation.assert(node);
-	scope;
-	throw new Error("unimplemented");
+import { Scope } from "../../scopes";
+import { AnyNode, tsNumericLiteralTypeAnnotation, } from "@internal/ast";
+export default function TSNumericLiteralTypeAnnotation(node: AnyNode, scope: Scope) {
+    node = tsNumericLiteralTypeAnnotation.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSObjectKeywordTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSObjectKeywordTypeAnnotation.ts
index 2790ccff6..c1862dcf0 100644
--- a/internal/js-analysis/evaluators/typescript/TSObjectKeywordTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSObjectKeywordTypeAnnotation.ts
@@ -4,19 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSObjectKeywordTypeAnnotation,
-	tsObjectKeywordTypeAnnotation,
-} from "@internal/ast";
-
-export default function TSObjectKeywordTypeAnnotation(
-	node: AnyNode,
-	scope: Scope,
-) {
-	node = tsObjectKeywordTypeAnnotation.assert(node);
-	scope;
-	throw new Error("unimplemented");
+import { Scope } from "../../scopes";
+import { AnyNode, tsObjectKeywordTypeAnnotation, } from "@internal/ast";
+export default function TSObjectKeywordTypeAnnotation(node: AnyNode, scope: Scope) {
+    node = tsObjectKeywordTypeAnnotation.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSObjectTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSObjectTypeAnnotation.ts
index dd5cba27f..03db94ae8 100644
--- a/internal/js-analysis/evaluators/typescript/TSObjectTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSObjectTypeAnnotation.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSObjectTypeAnnotation,
-	tsObjectTypeAnnotation,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsObjectTypeAnnotation, } from "@internal/ast";
 export default function TSObjectTypeAnnotation(node: AnyNode, scope: Scope) {
-	node = tsObjectTypeAnnotation.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsObjectTypeAnnotation.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSParenthesizedType.ts b/internal/js-analysis/evaluators/typescript/TSParenthesizedType.ts
index 35b9f6fc6..c299462b8 100644
--- a/internal/js-analysis/evaluators/typescript/TSParenthesizedType.ts
+++ b/internal/js-analysis/evaluators/typescript/TSParenthesizedType.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSParenthesizedType, tsParenthesizedType} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsParenthesizedType } from "@internal/ast";
 export default function TSParenthesizedType(node: AnyNode, scope: Scope) {
-	node = tsParenthesizedType.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsParenthesizedType.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSPropertySignature.ts b/internal/js-analysis/evaluators/typescript/TSPropertySignature.ts
index d9b4f382e..ee643fe93 100644
--- a/internal/js-analysis/evaluators/typescript/TSPropertySignature.ts
+++ b/internal/js-analysis/evaluators/typescript/TSPropertySignature.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSPropertySignature, tsPropertySignature} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsPropertySignature } from "@internal/ast";
 export default function TSPropertySignature(node: AnyNode, scope: Scope) {
-	node = tsPropertySignature.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsPropertySignature.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSQualifiedName.ts b/internal/js-analysis/evaluators/typescript/TSQualifiedName.ts
index 775ab946b..579377582 100644
--- a/internal/js-analysis/evaluators/typescript/TSQualifiedName.ts
+++ b/internal/js-analysis/evaluators/typescript/TSQualifiedName.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSQualifiedName, tsQualifiedName} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsQualifiedName } from "@internal/ast";
 export default function TSQualifiedName(node: AnyNode, scope: Scope) {
-	node = tsQualifiedName.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsQualifiedName.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSSignatureDeclarationMeta.ts b/internal/js-analysis/evaluators/typescript/TSSignatureDeclarationMeta.ts
index 49791240c..695b323be 100644
--- a/internal/js-analysis/evaluators/typescript/TSSignatureDeclarationMeta.ts
+++ b/internal/js-analysis/evaluators/typescript/TSSignatureDeclarationMeta.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSSignatureDeclarationMeta,
-	tsSignatureDeclarationMeta,
-} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsSignatureDeclarationMeta, } from "@internal/ast";
 export default function TSSignatureDeclarationMeta(node: AnyNode, scope: Scope) {
-	node = tsSignatureDeclarationMeta.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsSignatureDeclarationMeta.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSStringKeywordTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSStringKeywordTypeAnnotation.ts
index b924ed797..b0cb4140e 100644
--- a/internal/js-analysis/evaluators/typescript/TSStringKeywordTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSStringKeywordTypeAnnotation.ts
@@ -4,19 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSStringKeywordTypeAnnotation,
-	tsStringKeywordTypeAnnotation,
-} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, tsStringKeywordTypeAnnotation, } from "@internal/ast";
 import StringT from "../../types/StringT";
-
-export default function TSStringKeywordTypeAnnotation(
-	node: AnyNode,
-	scope: Scope,
-) {
-	node = tsStringKeywordTypeAnnotation.assert(node);
-	return new StringT(scope, node);
+export default function TSStringKeywordTypeAnnotation(node: AnyNode, scope: Scope) {
+    node = tsStringKeywordTypeAnnotation.assert(node);
+    return new StringT(scope, node);
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSStringLiteralTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSStringLiteralTypeAnnotation.ts
index 9bcf1d37f..608ffbf0b 100644
--- a/internal/js-analysis/evaluators/typescript/TSStringLiteralTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSStringLiteralTypeAnnotation.ts
@@ -4,19 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSStringLiteralTypeAnnotation,
-	tsStringLiteralTypeAnnotation,
-} from "@internal/ast";
-
-export default function TSStringLiteralTypeAnnotation(
-	node: AnyNode,
-	scope: Scope,
-) {
-	node = tsStringLiteralTypeAnnotation.assert(node);
-	scope;
-	throw new Error("unimplemented");
+import { Scope } from "../../scopes";
+import { AnyNode, tsStringLiteralTypeAnnotation, } from "@internal/ast";
+export default function TSStringLiteralTypeAnnotation(node: AnyNode, scope: Scope) {
+    node = tsStringLiteralTypeAnnotation.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSSymbolKeywordTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSSymbolKeywordTypeAnnotation.ts
index 65ec039cf..6b6513fb7 100644
--- a/internal/js-analysis/evaluators/typescript/TSSymbolKeywordTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSSymbolKeywordTypeAnnotation.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	TSSymbolKeywordTypeAnnotation,
-	tsSymbolKeywordTypeAnnotation,
-} from "@internal/ast";
-
+import { AnyNode, tsSymbolKeywordTypeAnnotation, } from "@internal/ast";
 export default function TSSymbolKeywordTypeAnnotation(node: AnyNode) {
-	node = tsSymbolKeywordTypeAnnotation.assert(node);
-	throw new Error("unimplemented");
+    node = tsSymbolKeywordTypeAnnotation.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSTemplateLiteralTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSTemplateLiteralTypeAnnotation.ts
index 4ec1b9136..49a2167d7 100644
--- a/internal/js-analysis/evaluators/typescript/TSTemplateLiteralTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSTemplateLiteralTypeAnnotation.ts
@@ -4,19 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSTemplateLiteralTypeAnnotation,
-	tsTemplateLiteralTypeAnnotation,
-} from "@internal/ast";
-
-export default function TSTemplateLiteralTypeAnnotation(
-	node: AnyNode,
-	scope: Scope,
-) {
-	node = tsTemplateLiteralTypeAnnotation.assert(node);
-	scope;
-	throw new Error("unimplemented");
+import { Scope } from "../../scopes";
+import { AnyNode, tsTemplateLiteralTypeAnnotation, } from "@internal/ast";
+export default function TSTemplateLiteralTypeAnnotation(node: AnyNode, scope: Scope) {
+    node = tsTemplateLiteralTypeAnnotation.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSThisType.ts b/internal/js-analysis/evaluators/typescript/TSThisType.ts
index 1b76cc21d..8e28e719b 100644
--- a/internal/js-analysis/evaluators/typescript/TSThisType.ts
+++ b/internal/js-analysis/evaluators/typescript/TSThisType.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSThisType, tsThisType} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsThisType } from "@internal/ast";
 export default function TSThisType(node: AnyNode, scope: Scope) {
-	node = tsThisType.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsThisType.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSTupleElement.ts b/internal/js-analysis/evaluators/typescript/TSTupleElement.ts
index 655f6edf9..9fdbc1b9c 100644
--- a/internal/js-analysis/evaluators/typescript/TSTupleElement.ts
+++ b/internal/js-analysis/evaluators/typescript/TSTupleElement.ts
@@ -1,6 +1,5 @@
-import {AnyNode, TSTupleElement, tsTupleElement} from "@internal/ast";
-
+import { AnyNode, tsTupleElement } from "@internal/ast";
 export default function TSTupleElement(node: AnyNode) {
-	node = tsTupleElement.assert(node);
-	throw new Error("unimplemented");
+    node = tsTupleElement.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSTupleType.ts b/internal/js-analysis/evaluators/typescript/TSTupleType.ts
index af21611ad..8c233b5fe 100644
--- a/internal/js-analysis/evaluators/typescript/TSTupleType.ts
+++ b/internal/js-analysis/evaluators/typescript/TSTupleType.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSTupleType, tsTupleType} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsTupleType } from "@internal/ast";
 export default function TSTupleType(node: AnyNode, scope: Scope) {
-	node = tsTupleType.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsTupleType.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSTypeAlias.ts b/internal/js-analysis/evaluators/typescript/TSTypeAlias.ts
index ecc3bd281..a89e61acc 100644
--- a/internal/js-analysis/evaluators/typescript/TSTypeAlias.ts
+++ b/internal/js-analysis/evaluators/typescript/TSTypeAlias.ts
@@ -4,19 +4,15 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSTypeAlias, tsTypeAlias} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsTypeAlias } from "@internal/ast";
 export default function TSTypeAlias(node: AnyNode, scope: Scope) {
-	node = tsTypeAlias.assert(node);
-
-	const typeScope = scope.fork();
-	if (node.typeParameters) {
-		typeScope.evaluate(node.typeParameters);
-	}
-
-	const right = typeScope.evaluate(node.right);
-	scope.addBinding(node.id.name, right);
-	return right;
+    node = tsTypeAlias.assert(node);
+    const typeScope = scope.fork();
+    if (node.typeParameters) {
+        typeScope.evaluate(node.typeParameters);
+    }
+    const right = typeScope.evaluate(node.right);
+    scope.addBinding(node.id.name, right);
+    return right;
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSTypeAssertion.ts b/internal/js-analysis/evaluators/typescript/TSTypeAssertion.ts
index 99cb5f5b5..7e331654d 100644
--- a/internal/js-analysis/evaluators/typescript/TSTypeAssertion.ts
+++ b/internal/js-analysis/evaluators/typescript/TSTypeAssertion.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSTypeAssertion, tsTypeAssertion} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsTypeAssertion } from "@internal/ast";
 export default function TSTypeAssertion(node: AnyNode, scope: Scope) {
-	node = tsTypeAssertion.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsTypeAssertion.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSTypeOperator.ts b/internal/js-analysis/evaluators/typescript/TSTypeOperator.ts
index fbd1f5e8c..75e6ebb21 100644
--- a/internal/js-analysis/evaluators/typescript/TSTypeOperator.ts
+++ b/internal/js-analysis/evaluators/typescript/TSTypeOperator.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSTypeOperator, tsTypeOperator} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsTypeOperator } from "@internal/ast";
 export default function TSTypeOperator(node: AnyNode, scope: Scope) {
-	node = tsTypeOperator.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsTypeOperator.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSTypeParameter.ts b/internal/js-analysis/evaluators/typescript/TSTypeParameter.ts
index c7158046e..bf51e325f 100644
--- a/internal/js-analysis/evaluators/typescript/TSTypeParameter.ts
+++ b/internal/js-analysis/evaluators/typescript/TSTypeParameter.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSTypeParameter, tsTypeParameter} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsTypeParameter } from "@internal/ast";
 export default function TSTypeParameter(node: AnyNode, scope: Scope) {
-	node = tsTypeParameter.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsTypeParameter.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSTypeParameterDeclaration.ts b/internal/js-analysis/evaluators/typescript/TSTypeParameterDeclaration.ts
index aeba76269..d7faee755 100644
--- a/internal/js-analysis/evaluators/typescript/TSTypeParameterDeclaration.ts
+++ b/internal/js-analysis/evaluators/typescript/TSTypeParameterDeclaration.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	TSTypeParameterDeclaration,
-	tsTypeParameterDeclaration,
-} from "@internal/ast";
-
+import { AnyNode, tsTypeParameterDeclaration, } from "@internal/ast";
 export default function TSTypeParameterDeclaration(node: AnyNode) {
-	node = tsTypeParameterDeclaration.assert(node);
-	throw new Error("unimplemented");
+    node = tsTypeParameterDeclaration.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSTypeParameterInstantiation.ts b/internal/js-analysis/evaluators/typescript/TSTypeParameterInstantiation.ts
index 13df2f3f6..4dca246a6 100644
--- a/internal/js-analysis/evaluators/typescript/TSTypeParameterInstantiation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSTypeParameterInstantiation.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	TSTypeParameterInstantiation,
-	tsTypeParameterInstantiation,
-} from "@internal/ast";
-
+import { AnyNode, tsTypeParameterInstantiation, } from "@internal/ast";
 export default function TSTypeParameterInstantiation(node: AnyNode) {
-	node = tsTypeParameterInstantiation.assert(node);
-	throw new Error("unimplemented");
+    node = tsTypeParameterInstantiation.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSTypePredicate.ts b/internal/js-analysis/evaluators/typescript/TSTypePredicate.ts
index 48a2ecba3..59b9cbd0a 100644
--- a/internal/js-analysis/evaluators/typescript/TSTypePredicate.ts
+++ b/internal/js-analysis/evaluators/typescript/TSTypePredicate.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSTypePredicate, tsTypePredicate} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsTypePredicate } from "@internal/ast";
 export default function TSTypePredicate(node: AnyNode, scope: Scope) {
-	node = tsTypePredicate.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsTypePredicate.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSTypeQuery.ts b/internal/js-analysis/evaluators/typescript/TSTypeQuery.ts
index 230ce1350..65402738c 100644
--- a/internal/js-analysis/evaluators/typescript/TSTypeQuery.ts
+++ b/internal/js-analysis/evaluators/typescript/TSTypeQuery.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSTypeQuery, tsTypeQuery} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsTypeQuery } from "@internal/ast";
 export default function TSTypeQuery(node: AnyNode, scope: Scope) {
-	node = tsTypeQuery.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsTypeQuery.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSTypeReference.ts b/internal/js-analysis/evaluators/typescript/TSTypeReference.ts
index e8b902741..aa313c98f 100644
--- a/internal/js-analysis/evaluators/typescript/TSTypeReference.ts
+++ b/internal/js-analysis/evaluators/typescript/TSTypeReference.ts
@@ -4,12 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {AnyNode, TSTypeReference, tsTypeReference} from "@internal/ast";
-
+import { Scope } from "../../scopes";
+import { AnyNode, tsTypeReference } from "@internal/ast";
 export default function TSTypeReference(node: AnyNode, scope: Scope) {
-	node = tsTypeReference.assert(node);
-	scope;
-	throw new Error("unimplemented");
+    node = tsTypeReference.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSUndefinedKeywordTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSUndefinedKeywordTypeAnnotation.ts
index 75d583fc2..93b5ea91a 100644
--- a/internal/js-analysis/evaluators/typescript/TSUndefinedKeywordTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSUndefinedKeywordTypeAnnotation.ts
@@ -4,14 +4,8 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {
-	AnyNode,
-	TSUndefinedKeywordTypeAnnotation,
-	tsUndefinedKeywordTypeAnnotation,
-} from "@internal/ast";
-
+import { AnyNode, tsUndefinedKeywordTypeAnnotation, } from "@internal/ast";
 export default function TSUndefinedKeywordTypeAnnotation(node: AnyNode) {
-	node = tsUndefinedKeywordTypeAnnotation.assert(node);
-	throw new Error("unimplemented");
+    node = tsUndefinedKeywordTypeAnnotation.assert(node);
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSUnionTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSUnionTypeAnnotation.ts
index 03eef94aa..4a71d87d8 100644
--- a/internal/js-analysis/evaluators/typescript/TSUnionTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSUnionTypeAnnotation.ts
@@ -4,23 +4,12 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSUnionTypeAnnotation,
-	tsUnionTypeAnnotation,
-} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, tsUnionTypeAnnotation, } from "@internal/ast";
 import UnionT from "../../types/UnionT";
-
 export default function TSUnionTypeAnnotation(node: AnyNode, scope: Scope) {
-	node = tsUnionTypeAnnotation.assert(node);
-
-	return new UnionT(
-		scope,
-		node,
-		node.types.map((type) => {
-			return scope.evaluate(type);
-		}),
-	);
+    node = tsUnionTypeAnnotation.assert(node);
+    return new UnionT(scope, node, node.types.map((type) => {
+        return scope.evaluate(type);
+    }));
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSUnknownKeywordTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSUnknownKeywordTypeAnnotation.ts
index 25384ddf2..6fb91a941 100644
--- a/internal/js-analysis/evaluators/typescript/TSUnknownKeywordTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSUnknownKeywordTypeAnnotation.ts
@@ -4,19 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSUnknownKeywordTypeAnnotation,
-	tsUnknownKeywordTypeAnnotation,
-} from "@internal/ast";
-
-export default function TSUnknownKeywordTypeAnnotation(
-	node: AnyNode,
-	scope: Scope,
-) {
-	node = tsUnknownKeywordTypeAnnotation.assert(node);
-	scope;
-	throw new Error("unimplemented");
+import { Scope } from "../../scopes";
+import { AnyNode, tsUnknownKeywordTypeAnnotation, } from "@internal/ast";
+export default function TSUnknownKeywordTypeAnnotation(node: AnyNode, scope: Scope) {
+    node = tsUnknownKeywordTypeAnnotation.assert(node);
+    scope;
+    throw new Error("unimplemented");
 }
diff --git a/internal/js-analysis/evaluators/typescript/TSVoidKeywordTypeAnnotation.ts b/internal/js-analysis/evaluators/typescript/TSVoidKeywordTypeAnnotation.ts
index 217f955fa..34cb025d2 100644
--- a/internal/js-analysis/evaluators/typescript/TSVoidKeywordTypeAnnotation.ts
+++ b/internal/js-analysis/evaluators/typescript/TSVoidKeywordTypeAnnotation.ts
@@ -4,16 +4,10 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-
-import {Scope} from "../../scopes";
-import {
-	AnyNode,
-	TSVoidKeywordTypeAnnotation,
-	tsVoidKeywordTypeAnnotation,
-} from "@internal/ast";
+import { Scope } from "../../scopes";
+import { AnyNode, tsVoidKeywordTypeAnnotation, } from "@internal/ast";
 import VoidT from "../../types/VoidT";
-
 export default function TSVoidKeywordTypeAnnotation(node: AnyNode, scope: Scope) {
-	node = tsVoidKeywordTypeAnnotation.assert(node);
-	return new VoidT(scope, node);
+    node = tsVoidKeywordTypeAnnotation.assert(node);
+    return new VoidT(scope, node);
 }
